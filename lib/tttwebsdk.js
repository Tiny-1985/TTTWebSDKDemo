/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/3tmodule/iplocation.js":
/*!************************************!*\
  !*** ./lib/3tmodule/iplocation.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\r\nconst retry = __webpack_require__(/*! retry */ \"./node_modules/retry/index.js\");\r\nconst uuid = __webpack_require__(/*! ../utils */ \"./lib/utils.js\").uuid;\r\nconst logger = __webpack_require__(/*! ../logger */ \"./lib/logger.js\")('IPLocation');\r\nlet iplocationAddress = __webpack_require__(/*! ../config */ \"./lib/config.js\").iplocationAddress;\r\nlet iplocationPort = __webpack_require__(/*! ../config */ \"./lib/config.js\").iplocationPort;\r\nlet mediaServerAddress = __webpack_require__(/*! ../config */ \"./lib/config.js\").mediaServerAddress\r\n\r\n/**\r\n * Retry operation's paramters.\r\n */\r\nconst WS_DEFAULT_RETRY_OPTIONS = retry.operation({\r\n\tretries: 4,\r\n\tfactor: 2,\r\n\tminTimeout: 1 * 1000,\r\n\tmaxTimeout: 2 * 1000,\r\n\trandomize: true,\r\n});\r\n\r\n/**\r\n * Get latest ip host service.\r\n */\r\nclass IPLocation extends events.EventEmitter\r\n{\r\n\tconstructor(appId, uid, successfulCB, failedCB)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis.appId = appId;\r\n\t\tthis.connectId = uuid();\r\n\t\tthis._url = `wss://${iplocationAddress}:${iplocationPort}/iplocation/`;\r\n\r\n\t\tlogger.debug(`constructor: ${this._url}`);\r\n\r\n\t\t// send to iplocation server's info.\r\n\t\tthis._wsjson = {\r\n\t\t\t\"eType\": 1,\r\n\t\t\t\"sSEQID\": \"111111111\",\r\n\t\t\t\"mProtocolMsg\": {\r\n\t\t\t\t\"sVersion\": \"Test_4.2.0.777\",\r\n\t\t\t\t\"bLoadBalance\": false,\r\n\t\t\t\t\"bReConnect\": false,\r\n\t\t\t\t\"bVipUser\": false,\r\n\t\t\t\t\"sIDentify\": \"7B4FCDBC0914E7182B8EC357F07498F1\",\r\n\t\t\t\t\"sSecret\": \"c052cd055acfabc5\",\r\n\t\t\t\t\"sVerifyCode\": \"abcd\",\r\n\t\t\t\t\"sAppID\": appId,\r\n\t\t\t\t\"nUserID\": +uid,\r\n\t\t\t\t\"sClientVer\": \"web_1.0\",\r\n\t\t\t\t\"sConnectID\": this.connectId,\r\n\t\t\t\t\"mIpAddrMsg\": {\r\n\t\t\t\t\t\"bFec\": false,\r\n\t\t\t\t\t\"sIp\": iplocationAddress,\r\n\t\t\t\t\t\"nPort\": 0\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// WebSocket instance.\r\n\t\tthis._ws = null;\r\n\r\n\t\t// Closed flag.\r\n\t\tthis._closed = false;\r\n\r\n\t\t// succuss & failure callbacks.\r\n\t\tthis._successcb = successfulCB;\r\n\t\tthis._failcb = failedCB;\r\n\r\n\t\tthis.reconnectTimes = 1;\r\n\t\tthis.firstConnectTime = Date.now();\r\n\t\tthis.connectedTime = 0;\r\n\t\tthis._hasSolve = false; // 是否已成功得到 IP location 结果\r\n\t\tthis._sendRetry = {\r\n\t\t\tretry: 5,\r\n\t\t\ttimer: 0\r\n\t\t}\r\n\t\tthis._setWebSocket();\r\n\t}\r\n\r\n\tstatic set IplocationAddress(value)\r\n\t{\r\n\t\tlogger.debug(`set IplocationAddress: ${value}`);\r\n\r\n\t\tiplocationAddress = value;\r\n\t}\r\n\r\n\tstatic get IplocationAddress()\r\n\t{\r\n\t\treturn iplocationAddress;\r\n\t}\r\n\r\n\tstatic set IplocationPort(port)\r\n\t{\r\n\t\tlogger.debug(`set IplocationPort: ${port}`);\r\n\r\n\t\tif (!/^[1-5][0-9]{2,4}$/.test(port))\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tiplocationPort = port;\r\n\t}\r\n\r\n\tstatic get IplocationPort()\r\n\t{\r\n\t\treturn iplocationPort;\r\n\t}\r\n\r\n\tstatic set MediaServerAddress(value)\r\n\t{\r\n\t\tmediaServerAddress = value;\r\n\t}\r\n\r\n\tstatic get MediaServerAddress()\r\n\t{\r\n\t\treturn mediaServerAddress;\r\n\t}\r\n\r\n\tgetIpLocationVar()\r\n\t{\r\n\t\treturn this.svcHost;\r\n\t}\r\n\r\n\tclose()\r\n\t{\r\n\t\tthis._closed = true;\r\n\t\tif (this._ws !== null)\r\n\t\t{\r\n\t\t\tthis._ws.close();\r\n\t\t\tthis._ws = null;\r\n\t\t}\r\n\t}\r\n\r\n\t_setWebSocket()\r\n\t{\r\n\t\tconst operation = retry.operation(WS_DEFAULT_RETRY_OPTIONS);\r\n\t\tlet wasConnected = false;\r\n\r\n\t\toperation.attempt((currentAttempt) =>\r\n\t\t{\r\n\t\t\tif (this._closed)\r\n\t\t\t{\r\n\t\t\t\toperation.stop();\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlogger.debug(`_setWebSocket() connecting... [currentAttempt: ${currentAttempt}`);\r\n\r\n\t\t\tthis._ws = new WebSocket(\r\n\t\t\t\tthis._url\r\n\t\t\t);\r\n\r\n\t\t\tthis._ws.onopen = () =>\r\n\t\t\t{\r\n\t\t\t\tif (this._closed)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\twasConnected = true;\r\n\t\t\t\tthis.connectedTime = Date.now();\r\n\t\t\t\tthis._ws.send(JSON.stringify(this._wsjson));\r\n\t\t\t\tthis._sendRetry.timer = setInterval(() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif (this._hasSolve)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// \r\n\t\t\t\t\tif (this._sendRetry.retry === 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis._ws.close();\r\n\t\t\t\t\t\toperation.retry(true);\r\n\t\t\t\t\t\tclearInterval(this._sendRetry.timer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis._ws.send(JSON.stringify(this._wsjson));\r\n\t\t\t\t\t--this._sendRetry.retry;\r\n\t\t\t\t}, 500);\r\n\r\n\t\t\t\tlogger.debug('WebSocket event [open]');\r\n\t\t\t};\r\n\r\n\t\t\tthis._ws.onclose = (event) =>\r\n\t\t\t{\r\n\t\t\t\tif (this._closed)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tlogger.warn(`WebSocket event [close] -- ${JSON.stringify(event)}`);\r\n\r\n\t\t\t\t// Don't retry if code is 4000 (closed by the server).\r\n\t\t\t\tif (event.code !== 4000)\r\n\t\t\t\t{\r\n\t\t\t\t\t// If it was not connected, try again.\r\n\t\t\t\t\tif (!wasConnected)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (this._closed)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tif (operation.retry(true))\r\n\t\t\t\t\t\t\t++this.reconnectTimes;\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// If it was connected, start from scratch.\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toperation.stop();\r\n\r\n\t\t\t\t\t\tif (this._closed)\r\n\t\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t\tthis._setWebSocket();\r\n\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._closed = true;\r\n\t\t\t};\r\n\r\n\t\t\tthis._ws.onerror = (e) =>\r\n\t\t\t{\r\n\t\t\t\tif (this._closed)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t/*\r\n\t\t\t\tlogger.error('WebSocket event [error]');\r\n\t\t\t\tthis._failcb(`websocket event [error]`);\r\n\r\n\t\t\t\tthis.close();\r\n\t\t\t\t*/\r\n\r\n\t\t\t\tlogger.error(`WebSocket event [error] - error ${e.toString()} - nothing todo.`);\r\n\t\t\t};\r\n\r\n\t\t\tthis._ws.onmessage = (event) =>\r\n\t\t\t{\r\n\t\t\t\tif (this._closed)\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\tlet msg = JSON.parse(event.data);\r\n\t\t\t\t// \r\n\t\t\t\tif (msg.eResult !== 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis._failcb(`msg.eResult: ${msg.eResult}`);\r\n\r\n\t\t\t\t\tthis.close();\r\n\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tconst evtobj = msg.mProtocolMsg.mIpAddrMsg;\r\n\t\t\t\t\tthis.svcHost = {\r\n\t\t\t\t\t\tip: evtobj.sIp,\r\n\t\t\t\t\t\tdomain: evtobj.sDomain,\r\n\t\t\t\t\t\tport: evtobj.nPort\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tif (mediaServerAddress !== '')\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.svcHost = {\r\n\t\t\t\t\t\t\tip: evtobj.sIp,\r\n\t\t\t\t\t\t\tdomain: mediaServerAddress,\r\n\t\t\t\t\t\t\tport: evtobj.nPort\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (!!this._sendRetry.timer)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tclearInterval(this._sendRetry.timer);\r\n\t\t\t\t\t\tthis._sendRetry.timer = 0;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// \r\n\t\t\t\t\tthis._hasSolve = true;\r\n\r\n\t\t\t\t\tthis._successcb(this.svcHost, msg.mProtocolMsg.mGWIpAddrMsgList);\r\n\r\n\t\t\t\t\tthis.close();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t});\r\n\t}\r\n}\r\n\r\nmodule.exports = IPLocation;\r\n\n\n//# sourceURL=webpack:///./lib/3tmodule/iplocation.js?");

/***/ }),

/***/ "./lib/TTTRtcWeb.js":
/*!**************************!*\
  !*** ./lib/TTTRtcWeb.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {const EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst Stream = __webpack_require__(/*! ./stream */ \"./lib/stream.js\");\nconst Client = __webpack_require__(/*! ./client */ \"./lib/client.js\");\nconst mediasoupClient = __webpack_require__(/*! ./mslib */ \"./lib/mslib/index.js\");\nconst config = __webpack_require__(/*! ./config */ \"./lib/config.js\");\nconst logger = __webpack_require__(/*! ./logger */ \"./lib/logger.js\")('<TTTRtcWeb>');\nconst IpLocation = __webpack_require__(/*! ./3tmodule/iplocation */ \"./lib/3tmodule/iplocation.js\");\nconst pkg = __webpack_require__(/*! ../package.json */ \"./package.json\")\n\n/**\n * 3TRTC Class. There is enter pointer of websdk.\n * The APIs documents hosted on the ./docs forder, please reference at there.\n */\nclass TTTRtcWeb extends EventEmitter\n{\n\tconstructor()\n\t{\n\t\tsuper();\n\n\t\tthis._client = null;\n\t\tthis._stream = null;\n\t\tthis._isAuth = false;\n\n\t\t// \n\t\tthis.getDevices((devices) => {\n\t\t\tlogger.debug(`this.getDevices - devices: ${JSON.stringify(devices)}`);\n\t\t}, (err) => {\n\t\t\tconst errMsg = err.name + err.message + '\\n';\n\t\t\tlogger.warn(`this.getDevices error - ${errMsg}`);\n\t\t});\n\n\t\tglobal.g_tttRtcWeb = this;\n\t}\n\n    /**\n     * Check browser is support webrtc.\n     * @return Returns a Boolean indicating if the current browser/device is supported by mediasoup-client.\n     */\n\tcheckSystemRequirements()\n\t{\n\t\treturn RTCPeerConnection && navigator.mediaDevices.getUserMedia && mediasoupClient.isDeviceSupported();\n\t}\n\n    /**\n     * Enumerate all the devices of this computer. e.g.: mics, webcams, speakers.\n     * @param onSuccess\n     * @param onFailure\n     * Field\tType\tDescription\n     *  flag\tString\tBrowser/device identifier.\n     *  name\tString\tBrowser/device descriptive name (taken from User-Agent.\n     *  version\tString\tBrowser/device version.\n     *  bowser\tObject\tObject produced by the _detect() method of the bowser library.\n     */\n\tgetDevices(onSuccess, onFailure)\n\t{\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API getDevices() error - parameter: onSuccess invalid');\n\t\t\tthrow new TypeError('onSuccess parameter must be a function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API getDevices() error - parameter: onFailure invalid');\n\t\t\tthrow new TypeError('onFailure parameter must be a function.');\n\t\t}\n\n\t\tif (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices)\n\t\t{\n\t\t\tlogger.error(\"enumerateDevices() not supported.\");\n\t\t\tthrow Error('websdk - system Not supported');\n\t\t}\n\n\t\t// List cameras and microphones.\n\t\tnavigator.mediaDevices.enumerateDevices()\n\t\t\t.then((devices) =>\n\t\t\t{\n\t\t\t\tonSuccess(devices);\n\t\t\t})\n\t\t\t.catch((err) =>\n\t\t\t{\n\t\t\t\tonFailure(err);\n\t\t\t});\n\t}\n\n    /**\n     * Set logger level.\n     * @param {string} logLevel -- 见 config.js 中 logLevel\n     */\n\tsetLogLevel(logLevel)\n\t{\n\t\tlogger._setLoggerLevel(logLevel);\n\t}\n\n\t/**\n\t * Get version of SDK 3TTech.cn\n\t * @returns {string}\n\t */\n\tgetVersion()\n\t{\n\t\treturn pkg.version;\n\t}\n\n    /**\n     * Create stream object.\n     * @param {object} spec. \n     *  {\n     *      streamId: '',\n     *      audio: true|false,\n     *      video: true|false,\n     *      attribute: {\n     *          resolution: 'sif|vga|hd20' // ref: config.js\n     *          minFrameRate: number,\n     *          maxFrameRate: number,\n     *          idealFrameRate: number\n     *      }\n     *      screen: true|false,\n     *      cameraId: string,\n     *      microphoneId: string\n     *  }\n     */\n\tcreateStream(spec)\n\t{\n\t\tif (!this.checkSystemRequirements())\n\t\t{\n\t\t\tlogger.error('createClient() - checkSystemRequirements not supported.');\n\t\t\tthrow Error('websdk - system Not supported');\n\t\t}\n\n\t\tthis._stream = new Stream(spec);\n\t\treturn this._stream;\n\t}\n\n\t/**\n\t * Create client object.\n\t * @param {Object} config.\n     *  {\n     *      role: '1|2|3' //1: master, 2: vice, 3: audience\n     *  }\n\t */\n\tcreateClient(config)\n\t{\n\t\tif (!this.checkSystemRequirements())\n\t\t{\n\t\t\tlogger.error('createClient() - checkSystemRequirements not supported.');\n\t\t\tthrow Error('websdk - system Not supported');\n\t\t}\n\n\t\t// \n\t\tthis._client = new Client(config);\n\t\tglobal.g_client = this._client;\n\t\treturn this._client;\n\t}\n\n    /**\n     * get peerconnection stats.\n     */\n\tgetStats()\n\t{\n\t\tif (this._client == null)\n\t\t{\n\t\t\tthrow Error('client is null, please create it before.');\n\t\t}\n\n\t\treturn this._client.getNetState();\n\t}\n\n    /**\n     * set server urls.\n     * @param {*} rootUrl \n     */\n\tsetServerUrl(rootUrl)\n\t{\n\t\tif (!rootUrl || rootUrl.trim() === '')\n\t\t{\n\t\t\tthrow new TypeError('rootUrl');\n\t\t}\n\n\t\tIpLocation.MediaServerAddress = rootUrl.trim();\n\t}\n\n    /**\n     * set iplocation host.\n     * @param {string} iplocation \n     */\n\tsetIpLocationAddress(iplocation)\n\t{\n\t\tif (!iplocation || iplocation.trim() === '')\n\t\t{\n\t\t\tthrow new TypeError('iplocation');\n\t\t}\n\n\t\tIpLocation.IplocationAddress = iplocation;\n\t}\n\n\t/**\n\t * set iplocation port\n\t * @param {number} iplocation port \n\t */\n\tsetIpLocationPort(port)\n\t{\n\t\tIpLocation.IplocationPort = port;\n\t}\n\n    /**\n     * Dev's can leaverage this method for internal domain deployment.\n     * @param {Any} conf \n     * {\n     *  urls: 'turn server addresses, \n     *  credential: 'as key word mean',\n     *  username: 'as key word mean'\n     * } \n     */\n\tsetTurnConf(conf)\n\t{\n\t\tClient.TurnConf = conf;\n\t}\n}\n\nmodule.exports = TTTRtcWeb;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./lib/TTTRtcWeb.js?");

/***/ }),

/***/ "./lib/client.js":
/*!***********************!*\
  !*** ./lib/client.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {const IPLocation = __webpack_require__(/*! ./3tmodule/iplocation */ \"./lib/3tmodule/iplocation.js\");\nconst config = __webpack_require__(/*! ./config */ \"./lib/config.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"./lib/utils.js\");\nconst Stream = __webpack_require__(/*! ./stream */ \"./lib/stream.js\");\nconst mediasoupClient = __webpack_require__(/*! ./mslib */ \"./lib/mslib/index.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nconst protooClient = __webpack_require__(/*! ./protoo */ \"./lib/protoo/index.js\");\nconst Stats = __webpack_require__(/*! ./stats */ \"./lib/stats.js\");\nconst logger = __webpack_require__(/*! ./logger */ \"./lib/logger.js\")('<Client>');\n\nconst getStats = __webpack_require__(/*! ./getStats */ \"./lib/getStats.js\");\n/**\n * @type {Any} TURN'sconfigure for internal domain.\n */\nlet turnConf = {};\n\nconst clientConnState = {\n\tDISCONNECTED: 'DISCONNECTED', // 连接断开。该状态表示 SDK 处于以下任一阶段：1. 调用 Client.join 加入频道前的初始化阶段；2. 调用 Client.leave 后的离开频道阶段\n\tCONNECTING: 'CONNECTING',   // 正在连接中。在调用 Client.join 或者连接中断自动重连的时候为此状态。\n\tCONNECTED: 'CONNECTED',\n\tDISCONNECTING: 'DISCONNECTING' // 正在断开连接。在调用 Client.leave 的时候为此状态。\n};\n\nclass Client extends EventEmitter\n{\n\tconstructor(config = {})\n\t{\n\t\tsuper();\n\n\t\t// Whether we should be a spy.\n\t\tthis._spy = false;\n\n\t\t// Closed flag.\n\t\tthis._closed = false;\n\n\t\t// My peer name.\n\t\tthis._peerName = '';\n\n\t\t// Transport for sending.\n\t\t// The defualt sending tranport.\n\t\tthis._sendTransport = null;\n\n\t\t// Transport for receiving.\n\t\tthis._recvTransport = null;\n\n\t\t// Local multiple webcam's producers.\n\t\t// There have only two tracks(mic/audio and webcam/video) or one track binding to one stream.\n\t\t// The key is StreamID, value is producer.\n\t\t// There produces contianer consists the peer's streams.\n\t\tthis._mapWebcamProducers = new Map();\n\n\t\t// Local multiple mic's producers.\n\t\t// key is streamID, value is producer.\n\t\tthis._mapMicProducers = new Map();\n\n\t\t// local multiple webcam's sending transports\n\t\t// The key is streamid, value transport. \n\t\t// It's associate with map webcam producers.\n\t\tthis._mapVideoSendTransports = new Map();\n\n\t\t// 仅仅用于记录\n\t\tthis._publishStreams = new Map();\n\n\t\tthis._protoo = null;\n\n\t\t// \n\t\tthis._remoteVideos = new Map();\n\n\t\t// only for stat\n\t\tthis._publishs = new Map();\n\t\tthis._subscribes = new Map();\n\n\t\t// 当前 protooTransport 的连接状态\n\t\tthis._protooTransportStat = false;\n\n\t\tthis._room = null;\n\n\t\t// Screen, tab or even video producer.\n\t\tthis._screenProducer = null;\n\n\t\t// Screen transport.\n\t\t// NOTE: screens are special stream thus take it. \n\t\tthis._screenTransport = null;\n\n\t\t// \n\t\tthis.iceRestartTimer = null;\n\n\t\t// 仅仅用于记录\n\t\tthis._iceSendDisconnectedCnt = 0;\n\t\tthis._iceRecvDisconnectedCnt = 0;\n\n\t\t// The peers.\n\t\t// Peer's have two produce maps, one is mic_producers, anthor is webcam_producer.\n\t\t// The peers's key is peer_id, value is peer. \n\t\tthis._peers = new Map();\n\n\t\t// transports stats.\n\t\tthis._stats = new Stats();\n\n\t\t//Subscribes the transport to RTC stats retrieved via the stats event.\n\t\tthis._interval = 3000;\n\n\t\t// IPIP return mechine's ip.\n\t\tthis._ip = '';\n\n\t\tthis._options = {};\n\n\t\t// config\n\t\tthis._config = config;\n\n\t\t// using simulcast.\n\t\tthis._useSimulcast = false;\n\n\t\tthis._tryJoin = 0;\n\t\tthis._joinTimer = null;\n\n\t\t// client conn state\n\t\tthis._connState = clientConnState.DISCONNECTED;\n\n\t\t// is joined room.\n\t\tthis._joined = false;\n\n\t\tthis._appId = '';\n\t\tthis._uid = '';\n\t\tthis._roomId = '';\n\n\t\t//\n\t\tthis._disableRtmpVideo = Boolean(config.disableRtmpVideo);\n\n\t\tthis._timesOfLinkGW = 1;\n\t\tthis._linkGWTime = 0;\n\t\tthis._sendGWTime = undefined;\n\t\tthis._sendEnterTime = undefined;\n\n\t\tglobal.g_appid = '';\n\t\tglobal.g_userid = '';\n\t\tglobal.g_roomid = '';\n\t\tglobal.g_server = '';\n\n\t\t// rtmp url validate.\n\t\tif (typeof config.rtmpUrl === 'string' && config.rtmpUrl.length > 0)\n\t\t{\n\t\t\t/*\n\t\t\tlet pattern = new RegExp('^(rtmp?:\\\\/\\\\/)?' + // protocol\n\t\t\t\t'((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|' + // domain name\n\t\t\t\t'((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))' + // OR ip (v4) address\n\t\t\t\t'(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*' + // port and path\n\t\t\t\t'(\\\\?[;:&a-z\\\\d%_.~+=-]*)?' + // query string\n\t\t\t\t'(\\\\#[-a-z\\\\d_]*)?$', 'i'); // fragment locator\n\t\t\tif (!pattern.test(config.rtmpUrl))\n\t\t\t{\n\t\t\t\tlogger.error('API createClient() error - config: rtmpUrl is invalide.');\n\t\t\t\tthrow new TypeError('rtmp url is invalid')\n\t\t\t}\n\t\t\t*/\n\n\t\t\tthis._valid_rtmp_url = config.rtmpUrl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._valid_rtmp_url = '';\n\t\t}\n\n\t\tif (!/^[123]$/.test(config.role))\n\t\t{\n\t\t\tlogger.error('API createClient() error - config: role must be set as 1: master, 2: vice 3: audience.');\n\t\t\tthrow new TypeError('role must be set as 1: master, 2: vice 3: audience');\n\t\t}\n\t\tthis._role = config.role + '';\n\n\t\tlogger.debug(`API createClient() success - ${JSON.stringify(config)}`);\n\n\t\t// only for stat\n\t\tthis._statsInterval = null;\n\t}\n\n\t// join room timeout period.\n\tstatic get JOIN_ROOM_TIME_OUT()\n\t{\n\t\treturn 2000;// 10000;\n\t}\n\n\t// ice reconnect waiting time.\n\tstatic get TIMEOUT_ICE_DISCONNECTED()\n\t{\n\t\treturn 10000;\n\t}\n\n\t// limit ice retry number of times.\n\tstatic get ICE_RETRY_NUM_TIME()\n\t{\n\t\treturn 10\n\t}\n\n    /**\n     * @param {Any} conf TURN configure.\n     * Set TURN server configure.\n     */\n\tstatic set TurnConf(conf)\n\t{\n\t\tif (typeof conf === 'undefined' || conf === null)\n\t\t{\n\t\t\tthrow new TypeError('turn configure')\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tturnConf.urls = conf.urls;\n\t\t\tturnConf.credential = conf.credential;\n\t\t\tturnConf.username = conf.username;\n\t\t\tturnConf.iceTransportPolicy = conf.iceTransportPolicy;\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tthrow e;\n\t\t}\n\t}\n\n\t// \n\t_startStatInterval()\n\t{\n\t\t// only for stat\n\t\tthis._statsInterval = setInterval(() =>\n\t\t{\n\t\t\tlet pubs = [];\n\t\t\tthis._publishs.forEach((s, key) =>\n\t\t\t{\n\t\t\t\tpubs.push(s);\n\t\t\t});\n\n\t\t\tlet subs = [];\n\t\t\tthis._subscribes.forEach((s, key) =>\n\t\t\t{\n\t\t\t\tsubs.push(s);\n\t\t\t});\n\n\t\t\tlet remoteVideos = [];\n\t\t\tthis._remoteVideos.forEach((s, key) =>\n\t\t\t{\n\t\t\t\tremoteVideos.push(s);\n\t\t\t})\n\n\t\t\t// \n\t\t\tconst jsonMain = {\n\t\t\t\thost: this._ip,\n\t\t\t\tappId: this._appId,\n\t\t\t\tuserId: this._uid,\n\t\t\t\trole: this._role,\n\t\t\t\troomId: this._roomId,\n\t\t\t\tconnState: this._connState,\n\t\t\t\tjoined: this._joined,\n\t\t\t\ticeSendDisconnCnt: this._iceSendDisconnectedCnt,\n\t\t\t\ticeRecvDisconnCnt: this._iceRecvDisconnectedCnt,\n\t\t\t\tpublishs: pubs,\n\t\t\t\tsubscribes: subs,\n\t\t\t\tremoteVideos\n\t\t\t}\n\t\t\tlogger.debug(`<CLIENT_STAT> ${JSON.stringify(jsonMain)}`);\n\n\t\t\t// \n\t\t}, 15000);\n\t}\n\n\t_stopStatInterval()\n\t{\n\t\tif (this._statsInterval === null)\n\t\t\treturn;\n\n\t\tclearInterval(this._statsInterval);\n\t\tthis._statsInterval = null;\n\t}\n\n\tget producerStreams()\n\t{\n\t\tlet streams = [];\n\n\t\tthis._publishStreams.forEach((s, key) =>\n\t\t{\n\t\t\tif (!s)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet item = {\n\t\t\t\tstreamId: s.streamID,\n\t\t\t\ttype: s.streamType,\n\t\t\t\tuserId: s.userID,\n\t\t\t\tspecialCameraId: s.specialCameraId,\n\t\t\t\tspecialMicId: s.specialMicId,\n\t\t\t\thasVideo: s.hasVideo(),\n\t\t\t\thasAudio: s.hasAudio()\n\t\t\t};\n\n\t\t\tstreams.push(item);\n\t\t});\n\n\t\treturn streams;\n\t}\n\n\tget consumerStreams()\n\t{\n\t\tlet streams = [];\n\n\t\tthis._peers.forEach((value, key) =>\n\t\t{\n\t\t\tif (!value.streams)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvalue.streams.forEach((s, index) =>\n\t\t\t{\n\t\t\t\tif (!s)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlet item = {\n\t\t\t\t\tstreamId: s.streamID,\n\t\t\t\t\ttype: s.streamType,\n\t\t\t\t\tuserId: s.userID,\n\t\t\t\t\tspecialCameraId: s.specialCameraId,\n\t\t\t\t\tspecialMicId: s.specialMicId,\n\t\t\t\t\thasVideo: s.hasVideo(),\n\t\t\t\t\thasAudio: s.hasAudio()\n\t\t\t\t};\n\n\t\t\t\t// \n\t\t\t\tstreams.push(item);\n\t\t\t});\n\t\t});\n\n\t\treturn streams;\n\t}\n\n\t// \n\tget micProducers()\n\t{\n\t\tlet producers = [];\n\n\t\tthis._mapMicProducers.forEach((value, key) =>\n\t\t{\n\t\t\tlet item = {\n\t\t\t\tstreamId: key,\n\t\t\t\tappData: value.appData\n\t\t\t};\n\n\t\t\t// \n\t\t\tproducers.push(item);\n\t\t});\n\n\t\treturn producers;\n\t}\n\n\tget webcamProducers()\n\t{\n\t\tlet producers = [];\n\n\t\tthis._mapWebcamProducers.forEach((value, key) =>\n\t\t{\n\t\t\tlet item = {\n\t\t\t\tstreamId: key,\n\t\t\t\tappData: value.appData\n\t\t\t};\n\n\t\t\t// \n\t\t\tproducers.push(item);\n\t\t});\n\n\t\treturn producers;\n\t}\n\n\tget screenProducers()\n\t{\n\t\tlet producers = [];\n\n\t\tif (this._screenProducer != null)\n\t\t{\n\t\t\tlet item = {\n\t\t\t\tstreamId: 'x_screen',\n\t\t\t\tappData: this._screenProducer.appData\n\t\t\t};\n\n\t\t\t// \n\t\t\tproducers.push(item);\n\t\t}\n\n\t\treturn producers;\n\t}\n\n\t/**\n\t * Initialize client object.\n\t * @param {string} appId\n     * @param {string|number} uid\n\t * @param {function} onSuccess\n\t * @param {function} onFailure\n\t */\n\tinit(appId, uid, onSuccess, onFailure)\n\t{\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API init() error - parameter: onSuccess invalid');\n\t\t\tthrow new TypeError('onSuccess parameter must be a function.')\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API init() error - parameter: onFailure invalid');\n\t\t\tthrow new TypeError('onFailure parameter must be a function.')\n\t\t}\n\n\t\tif (!appId || ('' + appId).trim() === '')\n\t\t{\n\t\t\tlogger.error('API init() error - parameter: appId invalid');\n\t\t\treturn onFailure(new TypeError('must be set appid'));\n\t\t}\n\n\t\tif (!/^[1-9][0-9]{0,18}$/.test(uid))\n\t\t{\n\t\t\tlogger.error('API init() error - parameter: userId invalid');\n\t\t\treturn onFailure(new TypeError('userId must be number'));\n\t\t}\n\n\t\t/*\n\t\tif (uid > (Math.pow(2, 32) - 1))\n\t\t{\n\t\t\tlogger.error('API init() error - parameter: userId is out of range.');\n\t\t\treturn onFailure(new Error('userId number is out of range.'));\n\t\t}\n\t\t*/\n\n\t\tthis._uid = '' + uid;\n\n\t\tglobal.g_appid = appId;\n\t\tglobal.g_userid = this._uid;\n\n\t\tlogger.debug(`API init() appId: ${appId} uid: ${uid}`);\n\n\t\tthis._appId = appId;\n\t\tthis._stats.setAppid(appId);\n\n\t\t// \n\t\tthis._startStatInterval();\n\n\t\tif (config.privateNet)\n\t\t{\n\t\t\tthis._ip = config.mediaServerAddress;\n\n\t\t\tlogger.debug(`API init() success - server: ${this._ip}`);\n\t\t\treturn onSuccess();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._ipLocation = new IPLocation(appId, +uid, (ipRes, gwInfo) =>\n\t\t\t{\n\t\t\t\tlogger.debug(`API init() iplocation success - server: ${ipRes.domain}`);\n\n\t\t\t\tthis._stats.setDomain(ipRes.domain);\n\t\t\t\tthis._stats.setGWInfo(gwInfo);\n\t\t\t\tthis._stats.setIPlocationInfo(this._ipLocation);\n\n\t\t\t\t// \n\t\t\t\tthis._ip = ipRes.domain;\n\n\t\t\t\treturn onSuccess();\n\t\t\t}, (e) =>\n\t\t\t{\n\t\t\t\t// \n\t\t\t\tthis._stopStatInterval();\n\n\t\t\t\t// \n\t\t\t\tlogger.error(`API init() failed - iplocation error: ${JSON.stringify(e)}`);\n\n\t\t\t\treturn onFailure(`API init() failed - iplocation error: ${JSON.stringify(e)}`);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Join room.\n\t * @param {string|number} roomId.\n\t * @param {function} onSuccess success call back function.\n\t * @param {function} onFailure failure call back function.\n\t */\n\tjoin(roomId, onSuccess, onFailure, options = {})\n\t{\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API join() error - parameter: onSuccess invalid');\n\t\t\tthrow new TypeError('onSuccess parameter must be a function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API join() error - parameter: onFailure invalid');\n\t\t\tthrow new TypeError('onFailure parameter must be a function.');\n\t\t}\n\n\t\tif (!/^[1-9][0-9]{0,18}$/.test(roomId))\n\t\t{\n\t\t\tlogger.error('API join() error - parameter: roomId invalid');\n\t\t\treturn onFailure(new TypeError('roomId must be number'));\n\t\t}\n\n\t\t/*\n\t\tif (roomId > (Math.pow(2, 32) - 1))\n\t\t{\n\t\t\tlogger.error('API join() error - parameter: roomId is out of range.');\n\t\t\treturn onFailure(new Error('roomId number is out of range.'));\n\t\t}\n\t\t*/\n\n\t\tlogger.debug(`API join() params roomId: ${roomId} role: ${this._role} - tryJoin: ${this._tryJoin}`);\n\n\t\tconst peerName = this._uid;\n\t\t\n\t\t// turn server leaverage udp protocol.\n\t\tconst forceTcp = false;\n\n\t\t// \n\t\tthis._options = options;\n\n\t\troomId += '';\n\t\tthis._roomId = roomId;\n\n\t\t// for log\n\t\tglobal.g_roomid = roomId;\n\t\tglobal.g_server = this._ip;\n\t\t// \n\n\t\tthis._stats.setRoomId(roomId);\n\t\tthis._stats.setUserId(peerName);\n\t\tthis._stats.setRoleType(+this._role);\n\n\t\tlet deviceInfo = mediasoupClient.getDeviceInfo();\n\t\tthis._stats.setDeviceInfo(deviceInfo);\n\n\t\tthis._peerName = peerName;\n\t\tlet protooUrl = utils.getProtooUrl(peerName, roomId, this._appId, this._ip);\n\t\t/*\n\t\tif (config.privateNet)\n\t\t{\n\t\t\tprotooUrl = utils.getProtooUrl(peerName, roomId, this._appId, config.mediaServerAddress);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprotooUrl = utils.getProtooUrl(peerName, roomId, this._appId, this._ipLocation.getIpLocationVar().domain);\n\t\t}\n\t\t*/\n\n\t\tthis._linkGWTime = Date.now();\n\t\t// protoo-client Peer instance.\n\t\tthis._protoo = new protooClient.Peer(protooUrl);\n\t\tif (!this._protoo)\n\t\t{\n\t\t\tthis._innerClose();\n\n\t\t\t// \n\t\t\tlogger.error('API join() error - new protooClient.Peer failed.');\n\t\t\tonFailure('new protooClient.Peer failed.');\n\t\t\treturn;\n\t\t}\n\n\t\t// \n\t\tthis.emit('connection-state-change', {\n\t\t\tprevState: this._connState,\n\t\t\tcurState: clientConnState.CONNECTING\n\t\t});\n\t\tthis._connState = clientConnState.CONNECTING;\n\n\t\t// Using default setting.\n\t\tif (!config.privateNet)\n\t\t{\n\t\t\tturnConf.urls = turnConf.urls || `turn:${this._ip}:3478`;\n\t\t\tturnConf.credential = turnConf.credential || config.clientConfig.turnServer.password;\n\t\t\tturnConf.username = turnConf.username || config.clientConfig.turnServer.username;\n\t\t\tturnConf.iceTransportPolicy = turnConf.iceTransportPolicy || config.clientConfig.turnServer.iceTransportPolicy;\n\t\t}\n\t\telse if (typeof turnConf.urls === 'undefined' || turnConf.urls === null)\n\t\t{ // using default configure if not set by dev.\n\t\t\tturnConf.urls = `turn:${this._ip}:3478`;\n\t\t\tturnConf.credential = config.clientConfig.turnServer.password;\n\t\t\tturnConf.username = config.clientConfig.turnServer.username;\n\t\t\tturnConf.iceTransportPolicy = config.clientConfig.turnServer.iceTransportPolicy;\n\t\t}\n\n\t\t// mediasoup client Room instance.\n\t\tthis._room = new mediasoupClient.Room({\n\t\t\trequestTimeout: 30000,\n\t\t\ttransportOptions: {\n\t\t\t\tudp: !forceTcp,\n\t\t\t\ttcp: Boolean(forceTcp)\n\t\t\t},\n\t\t\tspy: this._spy,\n\t\t\ticeTransportPolicy: turnConf.iceTransportPolicy, // relay, all\n\t\t\tturnServers: [{\n\t\t\t\t'urls': turnConf.urls,\n\t\t\t\t'credential': turnConf.credential,\n\t\t\t\t'username': turnConf.username\n\t\t\t}]\n\t\t});\n\n\t\tthis._join({\n\t\t\tdisplayName: peerName,\n\t\t\tdevice: 'webcam',\n\t\t\toptions\n\t\t}, onSuccess, onFailure);\n\t}\n\n\t_join({ displayName, device, options }, onSuccess, onFailure)\n\t{\n\t\tthis._protoo.on('open', () =>\n\t\t{\n\t\t\tlogger.debug('protooPeer event -- [open] - will _joinRoom...');\n\t\t\tthis._stats.setWsState('open');\n\n\t\t\tthis._protooTransportStat = true;\n\n\t\t\tthis._sendGWTime = Date.now();\n\t\t\tthis._linkGWTime = this._sendGWTime - this._linkGWTime;\n\n\t\t\tthis._joinRoom({ displayName, device, options }, onSuccess, onFailure);\n\t\t});\n\n\t\tthis._protoo.on('conn-reconn', () =>\n\t\t{\n\t\t\tlogger.debug('protooPeer event -- [conn-reconn]');\n\t\t\tthis._stats.setWsState('open');\n\n\t\t\t// \n\t\t\tthis._protooTransportStat = true;\n\t\t\t// \n\t\t\tthis.emit('connection-state-change', {\n\t\t\t\tprevState: this._connState,\n\t\t\t\tcurState: clientConnState.CONNECTED\n\t\t\t});\n\t\t\tthis._connState = clientConnState.CONNECTED;\n\t\t});\n\n\t\t// \n\t\tthis._protoo.on('conn-interrupt', () =>\n\t\t{\n\t\t\tlogger.debug('protooPeer event -- [conn-interrupt]');\n\t\t\tthis._stats.setWsState('close');\n\n\t\t\t// \n\t\t\tthis._protooTransportStat = false;\n\t\t});\n\n\t\tthis._protoo.on('reinit', () =>\n\t\t{\n\t\t\tlogger.debug('protooPeer event -- [reinit] -- Emit [reinit] to APP');\n\t\t\tthis._stats.setWsState('open');\n\n\t\t\t// \n\t\t\tthis._innerClose();\n\n\t\t\tthis.emit('reinit');\n\t\t\t// \n\t\t\tthis._protooTransportStat = true;\n\n\t\t\tthis._joinRoom({ displayName, device, options: this._options }, () => { }, () => { });\n\t\t});\n\n\t\tthis._protoo.on('connecting', (currentAttempt) => \n\t\t{\n\t\t\t// \n\t\t\tthis.emit('connection-state-change', {\n\t\t\t\tprevState: this._connState,\n\t\t\t\tcurState: clientConnState.CONNECTING\n\t\t\t});\n\t\t\tthis._connState = clientConnState.CONNECTING;\n\t\t});\n\n\t\tthis._protoo.on('close', () =>\n\t\t{\n\t\t\tthis._stats.setWsState('close');\n\n\t\t\t// \n\t\t\tthis._protooTransportStat = false;\n\n\t\t\t// \n\t\t\tthis._joined = false;\n\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\t// \n\t\t\tthis.emit('connection-state-change', {\n\t\t\t\tprevState: this._connState,\n\t\t\t\tcurState: clientConnState.DISCONNECTED\n\t\t\t});\n\t\t\tthis._connState = clientConnState.DISCONNECTED;\n\n\t\t\tlogger.warn('API protooPeer event -- [close] -- Emit [disconnected] to APP');\n\t\t\tthis.emit('disconnected');\n\n\t\t\tthis.close();\n\t\t});\n\n\t\tthis._protoo.on('request', (request, accept, reject) =>\n\t\t{\n\t\t\t// logger.debug(\n\t\t\t//     '_handleProtooRequest() [method:%s, data:%o]',\n\t\t\t//     request.method, request.data);\n\t\t\tswitch (request.method)\n\t\t\t{\n\t\t\t\tcase 'mediasoup-notification':\n\t\t\t\t\t{\n\t\t\t\t\t\taccept();\n\n\t\t\t\t\t\tconst notification = request.data;\n\n\t\t\t\t\t\tif (this._room !== null)\n\t\t\t\t\t\t\tthis._room.receiveNotification(notification);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase 'display-name-changed':\n\t\t\t\t\t{\n\t\t\t\t\t\taccept();\n\n\t\t\t\t\t\t// eslint-disable-next-line no-shadow\n\t\t\t\t\t\tconst { peerName, displayName, oldDisplayName } = request.data;\n\n\t\t\t\t\t\tif (this._room !== null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// NOTE: Hack, we shouldn't do this, but this is just a demo.\n\t\t\t\t\t\t\tconst peer = this._room.getPeerByName(peerName);\n\n\t\t\t\t\t\t\tif (!peer)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlogger.error('display-name-changed peer not found');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpeer.appData.displayName = displayName;\n\t\t\t\t\t\t\tlogger.debug(`display-name-changed displayName: ${displayName} peerName: ${peerName}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase '3T_applySpeak':\n\t\t\t\t\t{\n\t\t\t\t\t\taccept();\n\t\t\t\t\t\t// auto aprove(not deny) the applying.\n\t\t\t\t\t\tthis._protoo.send('approveSpeak', request.data);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase 'active-speaker':\n\t\t\t\t\t{\n\t\t\t\t\t\taccept();\n\t\t\t\t\t\tconst { peerName } = request.data;\n\t\t\t\t\t\t// logger.debug('RoomActiveSpeaker', peerName);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.error(`protoo.requst event -- [${request.method}] unknown protoo method`);\n\n\t\t\t\t\t\treject(404, 'unknown method');\n\t\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// NOTE: Custom defined signals by server notification.\n\t\tthis._protoo.on('notification', notification =>\n\t\t{\n\t\t\tswitch (notification.method)\n\t\t\t{\n\t\t\t\tcase '3T_sessionid': // define by BIG-NET.\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { sessionId } = notification.data;\n\t\t\t\t\t\tlogger.debug(`protooPeer event -- [notification:3T_sessionid] - ${sessionId}`);\n\n\t\t\t\t\t\tthis._stats.setSessionId(sessionId);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase '3T_connectid': // define by BIG-NET.\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { connectId } = notification.data;\n\t\t\t\t\t\tthis._stats.setConnectionId(connectId);\n\n\t\t\t\t\t\tlogger.debug(`protooPeer event -- [notification:3T_connectid] - ${connectId}`);\n\n\t\t\t\t\t\tonSuccess('You are join the room');\n\n\t\t\t\t\t\tthis._joined = true;\n\n\t\t\t\t\t\tlogger.debug('API protooPeer event -- [notification:3T_connectid] -- Emit [enter] to APP');\n\n\t\t\t\t\t\t// \n\t\t\t\t\t\tthis.emit('connection-state-change', {\n\t\t\t\t\t\t\tprevState: this._connState,\n\t\t\t\t\t\t\tcurState: clientConnState.CONNECTED\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthis._connState = clientConnState.CONNECTED;\n\n\t\t\t\t\t\t// \n\t\t\t\t\t\tif (!!this._joinTimer)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclearTimeout(this._joinTimer);\n\t\t\t\t\t\t\tthis._joinTimer = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase '3T_kickout': // kickout notified by svc and the leave by client ourself.\n\t\t\t\t\t{\n\t\t\t\t\t\t// if (this._role == '1') {\n\t\t\t\t\t\t//     logger.error('I was master in room, then cannot be kickout');\n\t\t\t\t\t\t// } else {\n\t\t\t\t\t\t//     this.emit('kickoout', notification.data);\n\t\t\t\t\t\t//     this.close();\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tlogger.debug(`API protooPeer event -- [notification:3T_kickout] - Emit [kickout] to APP - ${JSON.stringify(notification.data)}`);\n\n\t\t\t\t\t\tthis.emit('kickout', notification.data);\n\t\t\t\t\t\tthis.close();\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase '3T_CDN_URL': // suport CND subscribed.\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { CDN_url } = notification.data;\n\n\t\t\t\t\t\tlogger.debug(`API protooPeer event -- [notification:3T_CDN_URL] url: ${CDN_url} - Emit [CDN_url] to APP`);\n\n\t\t\t\t\t\tthis.emit({ 'CDN_url': CDN_url });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase 'active-speaker':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { peerName } = notification.data;\n\n\t\t\t\t\t\t// logger.debug('RoomActiveSpeaker', peerName);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tcase '3T_audiencevisible':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { peerId } = notification.data;\n\n\t\t\t\t\t\tlogger.debug(`API protooPeer event -- [notification:3T_audiencevisible] peerId: ${peerId} - Emit [peer-join] to APP`);\n\t\t\t\t\t\tconst peer = this._peers.get(peerId);\n\t\t\t\t\t\tif (peer)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.emit('peer-join', { userID: peerId, peer })\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\tcase '3T_changerole':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { peerId, role } = notification.data;\n\n\t\t\t\t\t\tlogger.debug(`API protooPeer event -- [notification:3T_changerole] peerId: ${peerId} - role: ${role}`);\n\t\t\t\t\t\tconst peer = this._peers.get(peerId);\n\t\t\t\t\t\tpeer.appData.role = role.toString();\n\t\t\t\t\t\tif (peer)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (peer.appData.role === '2')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlogger.debug(`API protooPeer event -- [notification:3T_changerole] peerId: ${peerId} role: ${role} - Emit [peer-join] to APP`);\n\t\t\t\t\t\t\t\tthis.emit('peer-join', { userID: peerId, peer });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (peer.appData.role === '3')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlogger.debug(`API protooPeer event -- [notification:3T_changerole] peerId: ${peerId} role: ${role} - Emit [peer-leave] to APP`);\n\t\t\t\t\t\t\t\tthis.emit('peer-leave', { userID: peerId, streams: [] });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\tcase '3T_rtmpfailure':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { roomId, url } = notification.data;\n\n\t\t\t\t\t\tlogger.debug(`API protooPeer event -- [notification:3T_rtmpfailure] url: ${url} - Emit [rtmp-failure] to APP`);\n\t\t\t\t\t\tthis.emit('rtmp-failure', { url, channelId: roomId });\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\tcase '3T_rtmpsuccess':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { roomId, url } = notification.data;\n\n\t\t\t\t\t\tlogger.debug(`API protooPeer event -- [notification:3T_rtmpsuccess] url: ${url} - Emit [rtmp-success] to APP`);\n\t\t\t\t\t\tthis.emit('rtmp-success', { url, channelId: roomId });\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\tcase '3T_needrefreshtoken': // close to expire.\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.debug(`API protooPeer event -- [notification:3T_needrefreshtoken] - Emit [onTokenPrivilegeWillExpire] to APP`);\n\t\t\t\t\t\tthis.emit('onTokenPrivilegeWillExpire');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.error(`protoo.requst event -- [${notification.method}] unknown protoo method`);\n\n\t\t\t\t\t\t// reject(404, 'unknown method');\n\t\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t_joinRoom({ displayName, device, options }, onSuccess, onFailure)\n\t{\n\t\tlogger.debug('this._joinRoom() try to join room...');\n\t\t// NOTE: We allow rejoining (room.join()) the same mediasoup Room when Protoo\n\t\t// WebSocket re-connects, so we must clean existing event listeners. Otherwise\n\t\t// they will be called twice after the reconnection.\n\t\tthis._room.removeAllListeners();\n\n\t\tthis._room.on('close', (originator, appData) =>\n\t\t{\n\t\t\tif (originator === 'remote')\n\t\t\t{\n\t\t\t\tlogger.warn(`room event -- mediasoup Peer/Room remotely closed -- appData: ${JSON.stringify(appData)}`);\n\n\t\t\t\tthis._stats.stopHeartBeat();\n\t\t\t}\n\t\t});\n\n\t\tthis._room.on('request', (request, callback, errback) =>\n\t\t{\n\t\t\t// logger.debug(`room event -- sending mediasoup [request:${request.method}]: ${JSON.stringify(request)}`);\n\t\t\tlogger.debug(`room event -- [request:${request.method}] sending to mediasoup `);\n\n\t\t\tthis._protoo.send('mediasoup-request', request)\n\t\t\t\t.then(callback)\n\t\t\t\t.catch(errback);\n\t\t});\n\n\t\tthis._room.on('notify', (notification) =>\n\t\t{\n\t\t\t// logger.debug(`room event -- sending mediasoup [notification:${notification.method}]: ${JSON.stringify(notification)}`);\n\t\t\tlogger.debug(`room event -- [notification:${notification.method}] sending to mediasoup`);\n\n\t\t\tif (this._closed)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._protoo.send('mediasoup-notification', notification)\n\t\t\t\t.catch((error) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(`Send mediasoup notification failed - ${error.toString()}`);\n\t\t\t\t});\n\t\t});\n\n\t\tthis._room.on('newpeer', (peer) =>\n\t\t{\n\t\t\tlogger.debug(`room event -- [newpeer] peerName: ${peer.name}`);\n\t\t\tthis._peers.set(peer.name, peer);\n\t\t\tthis._handlePeer(peer);\n\t\t});\n\n\t\tthis._joinTimer = setTimeout(() =>\n\t\t{\n\t\t\tif (this._joined)\n\t\t\t{\n\t\t\t\tif (!!this._joinTimer)\n\t\t\t\t{\n\t\t\t\t\tclearTimeout(this._joinTimer);\n\t\t\t\t}\n\t\t\t\tthis._joinTimer = null;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._tryJoin++;\n\t\t\t// \n\t\t\tif (+this._tryJoin < 3)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\tthis._innerClose();\n\n\t\t\t\tthis._room = null;\n\t\t\t\t// \n\n\t\t\t\t// Close protoo Peer (wait a bit so mediasoup-client can send\n\t\t\t\t// the 'leaveRoom' notification).\n\t\t\t\tif (this._protoo)\n\t\t\t\t{\n\t\t\t\t\tthis._protoo.close();\n\t\t\t\t\tthis._protoo = null;\n\t\t\t\t}\n\n\t\t\t\t// \n\t\t\t\tsetTimeout(() =>\n\t\t\t\t{\n\t\t\t\t\tthis.join(this._roomId, onSuccess, onFailure, this._options);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogger.warn('timeout -- join room timeout');\n\t\t\t\tthis._joinTimer = null;\n\n\t\t\t\tthis.close();\n\t\t\t\tthis._stats.sendTimeOutLog(this._timesOfLinkGW, +Client.JOIN_ROOM_TIME_OUT * 3);\n\t\t\t\tonFailure('join room timeout');\n\t\t\t}\n\t\t}, Client.JOIN_ROOM_TIME_OUT);\n\n\t\tlet appData = {\n\t\t\tdisplayName,\n\t\t\tdevice,\n\t\t\t'role': this._role,\n\t\t\ttoken: options.token || ''\n\t\t};\n\t\t// master role application data.\n\t\tif (this._role === '1' && this._valid_rtmp_url !== '')\n\t\t{\n\t\t\tappData.rtmpUrl = this._valid_rtmp_url;\n\t\t\tappData.disableRtmpVideo = this._disableRtmpVideo;\n\t\t}\n\n\t\tthis._room.join(this._peerName, appData)\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// 首先中止 ice restart timer\n\t\t\t\tthis._stopIceRestartTimer();\n\n\t\t\t\t// Create Transport for sending (unless we are spy).\n\t\t\t\tif (!this._spy)\n\t\t\t\t{\n\t\t\t\t\tthis._sendTransport = this._room.createTransport('send', { media: 'SEND_MIC_WEBCAM' });\n\n\t\t\t\t\tthis._sendTransport.on('close', (originator) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.debug(`_sendTransport event -- [close] originator: ${JSON.stringify(originator)}`);\n\t\t\t\t\t});\n\n\t\t\t\t\t// this._sendTransport.enableStats(this._interval);\n\n\t\t\t\t\t// this._sendTransport.on('stats', (stats) => {\n\t\t\t\t\t//     this._stats.pushStats(stats);\n\t\t\t\t\t// });\n\n\t\t\t\t\tthis._sendTransport.on('connectionstatechange', (connectionstate) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.debug(`_sendTransport event -- [connectionstatechange] connectionstat: ${connectionstate}`);\n\n\t\t\t\t\t\tif (connectionstate === 'disconnected')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// only for stat\n\t\t\t\t\t\t\tthis._iceSendDisconnectedCnt++;\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\tlogger.debug(`_sendTransport event -- [connectionstatechange:disconnected] - will restart ice after ${Client.TIMEOUT_ICE_DISCONNECTED}s`);\n\t\t\t\t\t\t\tsetTimeout(() =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis._retryRestartIce(this._sendTransport);\n\t\t\t\t\t\t\t}, Client.TIMEOUT_ICE_DISCONNECTED);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (connectionstate === 'failed')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger.debug('_sendTransport event -- [connectionstatechange:failed] - will restart ice');\n\t\t\t\t\t\t\t// Can't receved failed event on the chrome 76.0.3809.87 64 bits version.\n\t\t\t\t\t\t\tthis._retryRestartIce(this._sendTransport);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (connectionstate === 'connected')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger.debug('_sendTransport event -- [connectionstatechange:connected]');\n\t\t\t\t\t\t\t// for webrtc internals\n\t\t\t\t\t\t\tgetStats(this._sendTransport._handler._pc, (result) =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// console.log(`<STAT> _sendTransport -- ${JSON.stringify(result)}`);\n\t\t\t\t\t\t\t\tthis._stats.setWebrtcInternalSendStats(result);\n\t\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t\t// end for webrtc internals\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._stats.setSendIceState(connectionstate);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Create Transport for recipient.\n\t\t\t\tthis._recvTransport = this._room.createTransport('recv', { media: 'RECV' });\n\n\t\t\t\tthis._recvTransport.on('close', (originator) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug(`_recvTransport event -- [close] originator: ${JSON.stringify(originator)}`);\n\t\t\t\t});\n\n\t\t\t\tthis._recvTransport.on('connectionstatechange', (connectionstate) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug(`_recvTransport event -- [connectionstatechange] connectionstate: ${connectionstate}`);\n\n\t\t\t\t\tif (connectionstate === 'disconnected')\n\t\t\t\t\t{\n\t\t\t\t\t\t// only for stat\n\t\t\t\t\t\tthis._iceRecvDisconnectedCnt++;\n\n\t\t\t\t\t\tlogger.debug(`_recvTransport event -- [connectionstatechange:disconnected] - will restart ice after ${Client.TIMEOUT_ICE_DISCONNECTED}s`);\n\t\t\t\t\t\tsetTimeout(() =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis._retryRestartIce(this._recvTransport);\n\t\t\t\t\t\t}, Client.TIMEOUT_ICE_DISCONNECTED);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (connectionstate === 'failed')\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.debug('_recvTransport event -- [connectionstatechange:failed] - will restart ice');\n\t\t\t\t\t\tthis._retryRestartIce(this._recvTransport);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (connectionstate === 'connected')\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.debug('_recvTransport event -- [connectionstatechange:connected]');\n\t\t\t\t\t\t// for webrtc internals\n\t\t\t\t\t\tgetStats(this._recvTransport._handler._pc, (result) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis._stats.setWebrtcInternalRecvStats(result);\n\t\t\t\t\t\t}, 1000);\n\t\t\t\t\t\t// end for webrtc internals\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._stats.setRecvIceState(connectionstate);\n\t\t\t\t});\n\n\t\t\t\t// this._recvTransport.enableStats(this._interval);\n\t\t\t\t// this._recvTransport.on('stats', (stats) => {\n\t\t\t\t//     this._stats.pushStats(stats);\n\t\t\t\t// });\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (this._spy)\n\t\t\t\t\treturn;\n\n\t\t\t\t// Set our media capabilities.\n\t\t\t\t// this._dispatch(stateActions.setMediaCapabilities(\n\t\t\t\t// \t{\n\t\t\t\t// \t\tcanSendMic    : this._room.canSend('audio'),\n\t\t\t\t// \t\tcanSendWebcam : this._room.canSend('video')\n\t\t\t\t// \t}));\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlogger.debug('_room.join() success.');\n\n\t\t\t\t// filter anchor and vice\n\t\t\t\tconst peers = this._room.peers;\n\n\t\t\t\tfor (const peer of peers)\n\t\t\t\t{\n\t\t\t\t\tthis._handlePeer(peer, { notify: false });\n\t\t\t\t}\n\n\t\t\t\tthis._stats.startHeartBeat();\n\n\t\t\t\t// 注：待收到 3tconnectId 时，才最终通知上层：成功加入房间\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// 如下代码不再执行 -- 完全由 _joinTimer 来控制\n\t\t\t\t/*\n\t\t\t\tlogger.warn(`_room.join() failed - ${error.toString()}`);\n\t\t\t\tthis.close();\n\n\t\t\t\tthis._stats.sendFailLog(this._timesOfLinkGW, this._linkGWTime, this._sendGWTime, this._sendEnterTime, this._role, error.result || 1);\n\t\t\t\tonFailure(new Error(`Could not join the room: ${error.toString()}`));\n\t\t\t\t*/\n\t\t\t});\n\t}\n\n\t/**\n\t * Leave the joined room.\n\t * @param {function} onSuccess\n\t * @param {function} onFailure\n\t */\n\tasync leave(onSuccess, onFailure)\n\t{\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API leave() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not a fucntion.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API leave() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not a fucntion.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API leave() error - protooTransport broken');\n\n\t\t\t/*\n\t\t\tonFailure('protooTransport is broken');\n\t\t\treturn;\n\t\t\t*/\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\t// 更新当前登录状态为 未登录\n\t\t\tthis._joined = false;\n\n\t\t\tawait this._room.leave();\n\n\t\t\tlogger.debug('API leave() success.');\n\t\t\t// return onSuccess();\n\t\t}\n\t\tcatch (e)\n\t\t{\n\t\t\tlogger.warn(`API leave() error - ${e.toString()}`);\n\t\t\t// onFailure(e);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tonSuccess();\n\n\t\t\tlogger.debug('API leave() finish.');\n\t\t}\n\t}\n\n    /**\n     * publish stream.\n     * @param stream wish puslished.\n     * @param {function} onSuccess success call back.\n     * @param {function} onFailure fualure call back.\n     */\n\tpublish(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream || !stream.streamObj)\n\t\t{\n\t\t\tlogger.error('API publish() error - stream is null');\n\t\t\tthrow new TypeError('stream param error');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API publish() error - parameter: onSuccess invalid');\n\t\t\tthrow new TypeError('onSuccess parameter must be a function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API publish() error - parameter: onFailure invalid');\n\t\t\tthrow new TypeError('onFailure parameter must be a function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API publish() error - protooTransport is broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('API publish() error - non-joined');\n\n\t\t\tonFailure('non-joined');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Don't produce if we are spy.\n\t\tif (this._spy)\n\t\t{\n\t\t\tlogger.error('API publish() error - user is _spy');\n\t\t\tonFailure('you are spy');\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._role === '3')\n\t\t{\n\t\t\tlogger.error('API publish() error - forbidden because of Audience role');\n\t\t\tonFailure('you are audience');\n\t\t\treturn;\n\t\t}\n\n\t\tstream.userID = this._uid;\n\t\tlet micProducer = this._mapMicProducers.get(stream._innerStreamID);\n\t\tif (micProducer)\n\t\t{\n\t\t\t// 2020.2.9 this.resumeMic();\n\t\t\tthis._resumeProducer(micProducer);\n\t\t}\n\n\t\tlet webcamProducer = this._mapWebcamProducers.get(stream._innerStreamID);\n\t\tif (webcamProducer)\n\t\t{\n\t\t\t// 2020.2.9 this.resumeWebcam();\n\t\t\tthis._resumeProducer(webcamProducer);\n\n\t\t\t//\n\t\t\t// 在 非publish 状态下，曾经调用过 replaceTrack，故此处应执行一下 updateTrack\n\t\t\tif (stream._needUpdateTrack)\n\t\t\t{\n\t\t\t\tthis._updateTrack(stream, stream.videoTracks);\n\t\t\t\t// 要及时将 stream._needUpdateTrack 重置为 false\n\t\t\t\tstream._needUpdateTrack = false;\n\t\t\t}\n\t\t}\n\n\t\tif (webcamProducer || micProducer)\n\t\t{\n\t\t\tlogger.debug(`API publish() success - streamId: ${stream.innerStreamID} - Emit [stream-published] to APP`);\n\t\t\tstream._published = true;\n\n\t\t\t// only for stat\n\t\t\tthis._publishs.set(stream.innerStreamID, stream.innerStreamID);\n\n\t\t\tthis.emit('stream-published', { stream });\n\n\t\t\tonSuccess();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!stream.streamObj.getAudioTracks()[0] && !stream.streamObj.getVideoTracks()[0])\n\t\t{\n\t\t\tlogger.debug('API publish() error - audioTrack or videoTrack non-exist.');\n\t\t\tonFailure('no audio and video kind track');\n\t\t\treturn;\n\t\t}\n\n\t\tlet audioPublished = false;\n\t\tlet videoPublished = false;\n\n\t\t// NOTE: Don't depend on this Promise to continue (so we don't do return).\n\t\tPromise.resolve()\n\t\t\t// Add our mic.\n\t\t\t.then(async () =>\n\t\t\t{\n\t\t\t\tif (!this._room.canSend('audio'))\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('API publish() error - audio cannot Send.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// no audio track.\n\t\t\t\tif (!stream.streamObj.getAudioTracks()[0])\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('API publish() error - audioTrack non-exist.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tawait this._setMicProducer(stream);\n\t\t\t\t\taudioPublished = true;\n\t\t\t\t\tthis._stats.audioOpen = true;\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(`API publish() error - ${e.toString()}`);\n\t\t\t\t\t// logger.error(e);\n\t\t\t\t}\n\t\t\t})\n\t\t\t// Add our webcam (unless the cookie says no).\n\t\t\t.then(async () =>\n\t\t\t{\n\t\t\t\tif (!this._room.canSend('video'))\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('API publish() error - video cannot Send.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// no video track.\n\t\t\t\tif (!stream.streamObj.getVideoTracks()[0])\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('API publish() error - videoTrack non-exist.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tawait this._setWebcamProducer(stream);\n\t\t\t\t\tvideoPublished = true;\n\t\t\t\t\tthis._stats.videoOpen = true;\n\t\t\t\t}\n\t\t\t\tcatch (e)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(`API publish() error - ${e.toString()}`);\n\t\t\t\t\t// logger.error(e);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (audioPublished || videoPublished)\n\t\t\t\t{\n\t\t\t\t\tstream._published = true;\n\t\t\t\t\tlogger.debug(`API publish() success - streamId: ${stream.innerStreamID}- Emit [stream-published] to APP`);\n\n\t\t\t\t\t// only for stat\n\t\t\t\t\tthis._publishs.set(stream.innerStreamID, stream.innerStreamID);\n\n\t\t\t\t\tthis.emit('stream-published', { stream });\n\n\t\t\t\t\tonSuccess();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tonFailure('no audio or video to be sent');\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(e =>\n\t\t\t{\n\t\t\t\tlogger.warn(`API publish() error - ${e.toString()}`);\n\t\t\t\tonFailure(e)\n\t\t\t});\n\t}\n\n    /**\n     * Unpublish the stream. \n     * @param {Any} stream wish unpulbish.\n     * @param {function} onSuccess\n     * @param {function} onFailure\n     */\n\tunpublish(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API unpublish() error - stream is null');\n\t\t\tthrow new TypeError('stream param error');\n\t\t}\n\n\t\t// check params.\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API unpublish() error - parameter: onSuccess invalid');\n\t\t\tthrow new TypeError('onSuccess parameter must be a function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API unpublish() error - parameter: onFailure invalid');\n\t\t\tthrow new TypeError('onFailure parameter must be a function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API unpublish() error - protooTransport is broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// NOTE: Nothing to doing if not published of the stream.\n\t\tlet micProducer = this._mapMicProducers.get(stream._innerStreamID);\n\t\tif (micProducer)\n\t\t{\n\t\t\t// 2020.2.9 this.pauseMic(stream);\n\t\t\tthis._pauseProducer(micProducer);\n\t\t\t// this._micProducer.close();\n\t\t}\n\n\t\tlet webcamProducer = this._mapWebcamProducers.get(stream._innerStreamID);\n\t\tif (webcamProducer)\n\t\t{\n\t\t\t// 2020.2.9 this.pauseWebcam(stream);\n\t\t\tthis._pauseProducer(webcamProducer);\n\t\t\t// this._webcamProducer.close();\n\t\t}\n\n\t\t// \n\t\tthis._stats.audioOpen = false;\n\t\tthis._stats.videoOpen = false;\n\n\t\tstream._published = false;\n\n\t\t// only for stat\n\t\tthis._publishs.delete(stream.innerStreamID);\n\n\t\tlogger.debug(`API unpublish() success - streamId: ${stream.innerStreamID} - Emit [stream-unpublished] to APP`);\n\t\tthis.emit('stream-unpublished', { stream });\n\n\t\tonSuccess();\n\t}\n\n    /**\n     * publish screen.\n\t * 该函数废弃 -- 对于屏幕流，也统一采用 publish\n     * @param {object} stream \n     * @param {function} onSuccess \n     * @param {function} onFailure \n     */\n\tpublishScreen(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream || !stream.streamObj)\n\t\t{\n\t\t\tlogger.error('API publishScreen() error - parameter: stream is invalid');\n\t\t\tthrow new TypeError('stream param error');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API publishScreen() error - parameter: onSuccess invalid');\n\t\t\tthrow new TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API publishScreen() error - parameter: onFailure invalid');\n\t\t\tthrow new TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API publishScreen() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('API publishScreen() error - non-joined');\n\n\t\t\tonFailure('non-joined');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Don't produce if we are spy.\n\t\tif (this._spy)\n\t\t{\n\t\t\tlogger.error('API publishScreen() error - user is _spy');\n\t\t\tonFailure('you are spy');\n\t\t\treturn;\n\t\t}\n\n\t\t// Prohibition for audience.\n\t\tif (this._role === '3')\n\t\t{\n\t\t\tlogger.error('API publishScreen() error - forbidden because of Audience role');\n\t\t\tonFailure('you are audience');\n\t\t\treturn;\n\t\t}\n\n\t\tstream.userID = this._uid;\n\t\tif (this._screenProducer !== null)\n\t\t{\n\t\t\tthis.resumeScreen();\n\t\t\tlogger.debug(`API publishScreen() success streamId: ${stream.innerStreamID} - Emit [stream-published] to APP`);\n\t\t\tthis.emit('screen-published', { stream });\n\n\t\t\treturn;\n\t\t}\n\n\t\tPromise.resolve()\n\t\t\t// add own screen.\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._room.canSend('video'))\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('API publishScreen() error - video cannot Send.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis._setScreenProducer(stream)\n\t\t\t\t\t.catch((e) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.error(`API publishScreen() error - ${e.toString()}.`);\n\t\t\t\t\t});\n\n\t\t\t\tlogger.debug(`API publishScreen() success - streamId: ${stream.innerStreamID} - Emit [stream-published] to APP`);\n\t\t\t\tthis.emit('screen-published', { stream });\n\n\t\t\t\tonSuccess();\n\t\t\t})\n\t}\n\n    /**\n     * unpublish screen stream.\n\t * 该函数废弃 -- 对于屏幕流，也统一采用 unpublish\n     * @param {Any} stream \n     * @param {function} onSuccess \n     * @param {function} onFailure \n     */\n\tunpublishScreen(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream || !stream.streamObj)\n\t\t{\n\t\t\tlogger.error('API unpublishScreen() error - parameter: stream is invalid');\n\t\t\tthrow new TypeError('stream param error');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API unpublishScreen() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API unpublishScreen() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API unpublishScreen() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._screenProducer)\n\t\t{\n\t\t\t// Not pause it just mandatory close.\n\t\t\tthis._screenProducer.close();\n\t\t}\n\n\t\tthis._screenProducer = null;\n\n\t\tlogger.debug(`API unpublishScreen() success - streamId: ${stream.innerStreamID} - Emit [stream-unpublished] to APP`);\n\t\tthis.emit('screen-unpublished', { stream });\n\n\t\treturn onSuccess();\n\t}\n\n\tsubscribeAudio(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API subscribeAudio() error - parameter: stream is invalid');\n\t\t\tthrow new TypeError('stream');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API subscribeAudio() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API subscribeAudio() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API subscribeAudio() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('API subscribeAudio() error - non-joined');\n\n\t\t\tonFailure('non-joined');\n\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(`API subscribeAudio() - streamId: ${stream.getId()} stream.userID: ${stream.userID}`);\n\n\t\tlet peer = this._peers.get(stream.userID);\n\t\tif (!peer)\n\t\t{\n\t\t\tlogger.error(`API subscribeAudio() error - non-peer: ${stream.userID}`);\n\t\t\treturn onFailure('Can not found this peer');\n\t\t}\n\n\t\tpeer.consumers.forEach(element =>\n\t\t{\n\t\t\tif (!!element.appData && element.appData.streamID === stream.streamID)\n\t\t\t{\n\t\t\t\tif (element.kind === 'audio')\n\t\t\t\t\tthis._consumerAct(stream, element, 'resume', 'audio', onSuccess);\n\t\t\t}\n\t\t})\n\t}\n\n\tunsubscribeAudio(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API unsubscribeAudio() error - parameter: stream is invalid');\n\t\t\tthrow new TypeError('stream');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API unsubscribeAudio() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API unsubscribeAudio() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API unsubscribeAudio() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(`API unsubscribeAudio() - streamId: ${stream.getId()} stream.userID: ${stream.userID}`);\n\n\t\tlet peer = this._peers.get(stream.userID);\n\t\tif (!peer)\n\t\t{\n\t\t\tlogger.error(`API unsubscribeAudio() error - non-peer: ${stream.userID}`);\n\t\t\treturn onFailure('Can not found this peer');\n\t\t}\n\n\t\tpeer.consumers.forEach(element =>\n\t\t{\n\t\t\tif (!!element.appData && element.appData.streamID === stream.streamID)\n\t\t\t{\n\t\t\t\tif (element.kind === 'audio')\n\t\t\t\t\tthis._consumerAct(stream, element, 'pause', 'audio', onSuccess);\n\t\t\t}\n\t\t})\n\t}\n\n\tsubscribeVideo(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API subscribeVideo() error - parameter: stream is invalid');\n\t\t\tthrow new TypeError('stream');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API subscribeVideo() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API subscribeVideo() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API subscribeVideo() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('API subscribeVideo() error - non-joined');\n\n\t\t\tonFailure('non-joined');\n\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(`API subscribeVideo() - streamId: ${stream.getId()} stream.userID: ${stream.userID}`);\n\n\t\tlet peer = this._peers.get(stream.userID);\n\t\tif (!peer)\n\t\t{\n\t\t\tlogger.error(`API subscribeVideo() error - non-peer: ${stream.userID}`);\n\t\t\treturn onFailure('Can not found this peer');\n\t\t}\n\n\t\tpeer.consumers.forEach(element =>\n\t\t{\n\t\t\tif (!!element.appData && element.appData.streamID === stream.streamID)\n\t\t\t{\n\t\t\t\tif (element.kind === 'video')\n\t\t\t\t\tthis._consumerAct(stream, element, 'resume', 'video', onSuccess);\n\t\t\t}\n\t\t})\n\t}\n\n\tunsubscribeVideo(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API unsubscribeVideo() error - parameter: stream is invalid');\n\t\t\tthrow new TypeError('stream');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API unsubscribeVideo() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API unsubscribeVideo() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API unsubscribeVideo() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(`API unsubscribeVideo() streamId: ${stream.getId()} stream.userID: ${stream.userID}`);\n\n\t\tlet peer = this._peers.get(stream.userID);\n\t\tif (!peer)\n\t\t{\n\t\t\tlogger.error(`API unsubscribeVideo() error - non-peer: ${stream.userID}`);\n\t\t\treturn onFailure('Can not found this peer');\n\t\t}\n\n\t\tpeer.consumers.forEach(element =>\n\t\t{\n\t\t\tif (!!element.appData && element.appData.streamID === stream.streamID)\n\t\t\t{\n\t\t\t\tif (element.kind === 'video')\n\t\t\t\t\tthis._consumerAct(stream, element, 'pause', 'video', onSuccess);\n\t\t\t}\n\t\t})\n\t}\n\n\t// \n\t_consumerAct(stream, consumer, type, kind, onSuccess)\n\t{\n\t\tif (!consumer)\n\t\t{\n\t\t\tthrow new TypeError('consumer');\n\t\t}\n\n\t\tconst evt = { stream };\n\n\t\tif (type === 'pause')\n\t\t{\n\t\t\tconsumer.pause();\n\t\t\tonSuccess(stream);\n\t\t\tlogger.debug(`API _consumerAct() success - streamId: ${stream.getId()} - Emit [stream-${kind}-unsubscribed] to APP`);\n\n\t\t\tthis.emit(`stream-${kind}-unsubscribed`, evt);\n\n\t\t\treturn;\n\t\t}\n\t\telse if (type === 'resume')\n\t\t{\n\t\t\tconsumer.resume();\n\t\t\tonSuccess(stream);\n\t\t\tlogger.debug(`API _consumerAct() success - streamId: ${stream.getId()} - Emit [stream-${kind}-subscribed] to APP`);\n\n\t\t\tthis.emit(`stream-${kind}-subscribed`, evt);\n\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger.debug('API _consumerAct() error - invalid type - should be [resume|pause]');\n\t\t}\n\n\t\tthrow new TypeError('type');\n\t}\n\n    /**\n     * Subscribe the stream of your purpose.\n     * @param stream\n     * @param onSuccess\n     * @param onFailure\n     */\n\tsubscribe(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API subscribe() error - parameter: stream is invalid');\n\t\t\tthrow new TypeError('stream');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API subscribe() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API subscribe() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API subscribe() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('API subscribe() error - non-joined');\n\n\t\t\tonFailure('non-joined');\n\n\t\t\treturn;\n\t\t}\n\n\t\tlet peer = this._peers.get(stream.userID);\n\t\tif (!peer)\n\t\t{\n\t\t\tlogger.error(`API subscribe() error - non-peer: ${stream.userID}`);\n\t\t\treturn onFailure('Can not found this peer');\n\t\t}\n\n\t\tlet consumers = [];\n\t\tpeer.consumers.forEach(element =>\n\t\t{\n\t\t\tif (element.appData.streamID === stream.streamID)\n\t\t\t{\n\t\t\t\tconsumers.push(element);\n\n\t\t\t\t// only for stat\n\t\t\t\tthis._subscribes.set(stream.streamID, {\n\t\t\t\t\tstreamID: stream.streamID,\n\t\t\t\t\tstatus: 'active'\n\t\t\t\t});\n\t\t\t}\n\t\t})\n\n\t\tconsumers.forEach((value) =>\n\t\t{\n\t\t\tvalue.resume();\n\t\t})\n\n\t\tstream.subscribed = true;\n\t\tlet evt = { stream };\n\n\t\tonSuccess(stream);\n\n\t\tlogger.debug(`API subscribe() success - streamId: ${stream.getId()} - Emit [stream-subscribed] to APP`);\n\n\t\tthis.emit('stream-subscribed', evt);\n\t}\n\n    /**\n     * Unsbubscribe the stream.\n     * @param {Any} stream\n     * @param {function} onSuccess\n     * @param {function} onFailure\n     */\n\tunsubscribe(stream, onSuccess, onFailure)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API unsubscribe() error - parameter: stream is invalid');\n\t\t\tthrow TypeError('stream param error');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API unsubscribe() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API unsubscribe() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API unsubscribe() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tlet peer = this._peers.get(stream.userID);\n\t\tif (!peer)\n\t\t{\n\t\t\tlogger.error(`API unsubscribe() error - non-peer: ${stream.userID}`);\n\t\t\treturn onFailure('Can not found this peer');\n\t\t}\n\n\t\tlet consumers = [];\n\t\tpeer.consumers.forEach(element =>\n\t\t{\n\t\t\tif (element.appData.streamID === stream.streamID)\n\t\t\t{\n\t\t\t\tconsumers.push(element);\n\n\t\t\t\t// only for stat\n\t\t\t\tthis._subscribes.delete(stream.streamID);\n\t\t\t}\n\t\t})\n\n\t\tconsumers.forEach((value) =>\n\t\t{\n\t\t\tvalue.pause();\n\t\t})\n\n\t\tstream.subscribed = false;\n\t\tlet evt = { stream };\n\n\t\tonSuccess(stream);\n\n\t\tlogger.debug(`API unsubscribe() success - streamId: ${stream.getId()} - Emit [stream-unsubscribed] to APP`);\n\n\t\tthis.emit('stream-unsubscribed', evt);\n\t}\n\n    /**\n     * Pause Mic of local stream.\n     * @param {Any} stream\n     */\n\tpauseMic(stream)\n\t{\n\t\tlogger.debug('API pauseMic()');\n\t\tlet producer;\n\t\tif (!stream)\n\t\t{\n\t\t\tproducer = this._mapMicProducers.values().next().value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tproducer = this._mapMicProducers.get(stream._innerStreamID);\n\t\t}\n\n\t\tif (!producer)\n\t\t{\n\t\t\tlogger.warn('API pauseMic() error - non mic producer.');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._pauseProducer(producer);\n\t}\n\n    /**\n     * Resume Mic of local stream.\n     * @param {Any} stream \n     */\n\tresumeMic(stream)\n\t{\n\t\tlogger.debug('API resumeMic()');\n\t\tlet producer;\n\t\tif (!stream)\n\t\t{\n\t\t\tproducer = this._mapMicProducers.values().next().value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tproducer = this._mapMicProducers.get(stream._innerStreamID);\n\t\t}\n\n\t\tif (!producer)\n\t\t{\n\t\t\tlogger.warn('API resumeMic() error - non mic producer.');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._resumeProducer(producer);\n\t}\n\n    /**\n     * Pause webcam of local stream.\n     * @param {Any} stream \n     */\n\tpauseWebcam(stream)\n\t{\n\t\tlogger.debug('API pauseWebcam()');\n\t\tlet producer;\n\n\t\t// only one stream. That's will comptible with previous viersion(nul multi-stream)\n\t\tif (!stream)\n\t\t{\n\t\t\tproducer = this._mapWebcamProducers.values().next().value;\n\t\t}\n\t\telse\n\t\t{//multistream\n\t\t\tproducer = this._mapWebcamProducers.get(stream._innerStreamID);\n\t\t}\n\n\t\tif (!producer)\n\t\t{\n\t\t\tlogger.warn('API pauseWebcam() error - non webcam producer.');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._pauseProducer(producer);\n\t}\n\n    /**\n     * Resume webcam of local stream.\n     * @param {Any} stream \n     */\n\tresumeWebcam(stream)\n\t{\n\t\tlogger.debug('API resumeWebcam()');\n\t\tlet producer;\n\t\tif (!stream)\n\t\t{\n\t\t\tproducer = this._mapWebcamProducers.values().next().value;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tproducer = this._mapWebcamProducers.get(stream._innerStreamID);\n\t\t}\n\n\t\tif (!producer)\n\t\t{\n\t\t\tlogger.warn('API resumeWebcam() error - non webcam producer.');\n\t\t\treturn;\n\t\t}\n\n\t\tthis._resumeProducer(producer);\n\t}\n\n    /**\n     * update track (only video).\n     * @param {Any} stream \n     * @param {Any} track \n     */\n\t_updateTrack(stream, track)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.warn('_updateTrack() error - parameter [stream] is INVALID.');\n\t\t\treturn;\n\t\t}\n\t\tlogger.debug(`_updateTrack() - streamId: ${stream.innerStreamID}`);\n\n\t\t// Only support update video kind track now.\n\t\tlet producer = this._mapWebcamProducers.get(stream._innerStreamID);\n\t\tif (!producer)\n\t\t{\n\t\t\tlogger.debug(`_updateTrack() error - client update track(kind video of webcam) can not found producer ${stream.innerStreamID}.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// Hard resetting track especial bandwidth.\n\t\tproducer.updateTrack(track, {\n\t\t\tidealBandwidth: stream.idealBandwidth,\n\t\t\tmaxBandwidth: stream.maxBandwidth,\n\t\t\tminBandwidth: stream.minBandwidth\n\t\t});\n\t}\n\n    /**\n     * Replace track.\n     * @param {Any} stream \n     * @param {Any} track this track will cover the privous it.\n     */\n\t_replaceTrack(stream, track)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.warn('_replaceTrack() error - parameter [stream] is INVALID.');\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(`_replaceTrack() - stream.streamID: ${stream.innerStreamID}`);\n\t\t// Only support update video kind track now.\n\t\tlet producer = this._mapWebcamProducers.get(stream._innerStreamID);\n\t\tif (!producer)\n\t\t{\n\t\t\tlogger.debug(`_replaceTrack() error - client replace track(kind video of webcam) can not found producer ${stream._innerStreamID}.`);\n\t\t\treturn;\n\t\t}\n\n\t\tPromise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tproducer.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (stream._published)\n\t\t\t\t{\n\t\t\t\t\tthis._updateTrack(stream, track);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstream._needUpdateTrack = true;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch(e =>\n\t\t\t{\n\t\t\t\tlogger.error(`_replaceTrack() error - replace track failed - ${e.toString()}`);\n\t\t\t\tthrow e;\n\t\t\t})\n\t}\n\n\t_resumeProducer(producer)\n\t{\n\t\tif (!producer)\n\t\t{\n\t\t\tlogger.error('_resumeProducer() error - parameter [producer] is INVALID.');\n\t\t\tthrow new TypeError('producer');\n\t\t}\n\n\t\tproducer.resume();\n\t}\n\n\t_pauseProducer(producer)\n\t{\n\t\tif (!producer)\n\t\t{\n\t\t\tlogger.error('_pauseProducer() error - parameter [producer] is INVALID.');\n\t\t\tthrow new TypeError('producer');\n\t\t}\n\n\t\tproducer.pause();\n\t}\n\n\tpauseScreen()\n\t{\n\t\tlogger.debug('API pauseScreen()');\n\n\t\tif (this._screenProducer !== null)\n\t\t{\n\t\t\tthis._screenProducer.pause();\n\t\t}\n\t}\n\n\tresumeScreen()\n\t{\n\t\tlogger.debug('API resumeScreen()');\n\n\t\tif (this._screenProducer !== null)\n\t\t{\n\t\t\tthis._screenProducer.resume();\n\t\t}\n\t}\n\n    /**\n     * Renew Channel Key,\n     * TODO.\n     * @param channelKey\n     * @param onSuccess\n     * @param onFailure\n     */\n\trenewChannelKey(channelKey, onSuccess, onFailure)\n\t{\n\t}\n\n    /**\n     * 开启双流模式\n     * TODO.\n     */\n\tenableDualStream()\n\t{\n\t}\n\n    /**\n     * TODO.\n     * Set video stream type.\n     * @param stream\n     * @param streamType\n     */\n\tsetRemoteVideoStreamType(stream, streamType)\n\t{\n\t}\n\n    /**\n     * TODO.\n     */\n\tsetLowStreamParameter()\n\t{\n\t}\n\n    /**\n     * TODO.\n     * close dual stream.\n     * @param onSuccess\n     * @param onFailure\n     */\n\tdisableDualStream(onSuccess, onFailure)\n\t{\n\t}\n\n    /**\n     * set proxy server, e.g.: nginx.\n     * TODO.\n     */\n\tsetProxyServer(domainName)\n\t{\n\t}\n\n    /**\n     * 设置 AES 加密密码\n     * TODO.\n     */\n\tsetEncryptionSecret()\n\t{\n\t}\n\n    /**\n     * 设置 AES 加密方案\n     * TODO.\n     */\n\tsetEncryptionMode()\n\t{\n\t}\n\n    /**\n     * read only property.\n     */\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\tasync closeStream(stream)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API closeStream() error - parameter [stream] is INVALID.');\n\n\t\t\tthrow new TypeError('stream param error');\n\t\t}\n\n\t\tlogger.error(`API closeStream() - streamId: ${stream.getId()}`);\n\n\t\t// \n\t\tlet micProducer = this._mapMicProducers.get(stream._innerStreamID);\n\t\tif (!!micProducer)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tawait micProducer.close();\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\tthis.logger.warn(`API closeStream() error - close micProducer error - ${e.toString()}`);\n\t\t\t}\n\t\t}\n\n\t\t// \n\t\tlet webcamProducer = this._mapWebcamProducers.get(stream._innerStreamID);\n\t\tif (!!webcamProducer)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tawait webcamProducer.close();\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\tthis.logger.warn(`API closeStream() error - close webcamProducer error - ${e.toString()}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t_innerClose()\n\t{\n\t\t// 更新当前为 未登录\n\t\tthis._joined = false;\n\n\t\t// \n\t\tthis.emit('connection-state-change', {\n\t\t\tprevState: this._connState,\n\t\t\tcurState: clientConnState.DISCONNECTED\n\t\t});\n\t\tthis._connState = clientConnState.DISCONNECTED;\n\n\t\t// \n\t\t// \n\t\tif (!!this._joinTimer)\n\t\t{\n\t\t\tclearTimeout(this._joinTimer);\n\t\t\tthis._joinTimer = null;\n\t\t}\n\n\t\t// \n\t\tthis._stopStatInterval();\n\t\t// \n\t\tthis._remoteVideos.clear();\n\t\tthis._publishs.clear();\n\t\tthis._subscribes.clear();\n\n\t\t// \n\t\tthis._mapMicProducers.forEach((value, key) =>\n\t\t{\n\t\t\tvalue.close();\n\t\t})\n\n\t\tthis._mapWebcamProducers.forEach((value, key) =>\n\t\t{\n\t\t\tvalue.close();\n\t\t})\n\n\t\tthis._mapMicProducers.clear();\n\t\tthis._mapWebcamProducers.clear();\n\n\t\tif (this._sendTransport != null)\n\t\t{\n\t\t\tthis._sendTransport.close();\n\t\t\tthis._sendTransport = null;\n\t\t}\n\n\t\tif (this._screenTransport)\n\t\t{\n\t\t\tthis._screenTransport.close();\n\t\t\tthis._screenTransport = null;\n\t\t}\n\n\t\tif (this._screenProducer)\n\t\t{\n\t\t\tthis._screenProducer.close();\n\t\t\tthis._screenProducer = null;\n\t\t}\n\n\t\tthis._mapVideoSendTransports.forEach((value, key) =>\n\t\t{\n\t\t\tvalue.close();\n\t\t})\n\n\t\tthis._mapVideoSendTransports.clear();\n\n\t\tif (this._recvTransport)\n\t\t{\n\t\t\tthis._recvTransport.close();\n\t\t\tthis._recvTransport = null;\n\t\t}\n\n\t\t// Leave the mediasoup Room.\n\t\tif (this._room)\n\t\t{\n\t\t\tthis._room.removeAllListeners();\n\t\t\tthis._room.leave();\n\t\t}\n\n\t\tthis._peers.clear();\n\t}\n\n    /**\n     * close client.\n     */\n\tclose()\n\t{\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._closed = true;\n\n\t\tlogger.debug('API close()');\n\n\t\t// \n\t\tthis._innerClose();\n\n\t\tthis._room = null;\n\t\t// \n\n\t\t// Close protoo Peer (wait a bit so mediasoup-client can send\n\t\t// the 'leaveRoom' notification).\n\t\tif (this._protoo)\n\t\t{\n\t\t\tthis._protoo.close();\n\t\t\tthis._protoo = null;\n\t\t}\n\n\t\tthis._stats.stopHeartBeat();\n\t\tthis.removeAllListeners();\n\t}\n\n\t_handlePeer(peer, { notify = true } = {})\n\t{\n\t\tconst displayName = peer.appData.displayName;\n\n\t\tlogger.debug(`API _handlePeer() userID: ${peer.name} - Emit [peer-join] to APP`);\n\n\t\t// The peer name equal with peer.id.\n\t\tif (peer.appData.role.toString() !== '3')\n\t\t{\n\t\t\tthis.emit('peer-join', {\n\t\t\t\tuserID: peer.name,\n\t\t\t\tpeer // for compatibility with previous version(3.0 and 3.1)\n\t\t\t});\n\t\t}\n\t\tthis._peers.set(peer.name, peer);\n\n\t\t/*\n        logger.debug('addPeer:', {\n\t\t\tname: peer.name,\n\t\t\tdisplayName: displayName,\n\t\t\tdevice: peer.appData.device,\n\t\t\tconsumers: []\n\t\t});\n\t\t*/\n\n\t\tfor (const consumer of peer.consumers)\n\t\t{\n\t\t\tthis._handleConsumer(consumer);\n\t\t}\n\n\t\tpeer.on('close', (originator) =>\n\t\t{\n\t\t\tlogger.debug(`peer event [close] - userID: ${peer.name} originator: ${originator}`);\n\n\t\t\tthis._peers.delete(peer.name);\n\t\t\tif (!this._closed)\n\t\t\t{\n\t\t\t\tlogger.debug(`API _handlePeer() event [close] - userID: ${peer.name} - Emit [peer-leave] to APP`);\n\t\t\t\tthis.emit('peer-leave', { userID: peer.name, streams: peer.streams || [], peer /**for compatibility previous version(3.0, 3.1) */ });\n\t\t\t}\n\t\t});\n\n\t\tpeer.on('newconsumer', (consumer) =>\n\t\t{\n\t\t\t/*\n            logger.debug(\n                `peer event -- [newconsumer] name:'%s', id:%s, consumer:%o]`,\n\t\t\t\tpeer.name, consumer.id, consumer);\n\t\t\t*/\n\t\t\tlogger.debug(`API _handlePeer() peer event [newconsumer] - peer.name: ${peer.name} consumer.id: ${consumer.id}`);\n\n\t\t\tthis._handleConsumer(consumer);\n\t\t});\n\t}\n\n\tasync _handleConsumer(consumer)\n\t{\n\t\tconst codec = consumer.rtpParameters.codecs[0];\n\n\t\tlogger.debug(\n\t\t\t{\n\t\t\t\tid: consumer.id,\n\t\t\t\tpeerName: consumer.peer.name,\n\t\t\t\tsource: consumer.appData.source,\n\t\t\t\tsupported: consumer.supported,\n\t\t\t\tlocallyPaused: consumer.locallyPaused,\n\t\t\t\tremotelyPaused: consumer.remotelyPaused,\n\t\t\t\ttrack: null,\n\t\t\t\tcodec: codec ? codec.name : null\n\t\t\t},\n\t\t\tconsumer.peer.name);\n\n\t\tconsumer.on('close', (originator) =>\n\t\t{\n\t\t\t// \n\t\t\tthis._stats.removeStreamById(`consumer_${consumer.id}`);\n\t\t\t//\n\t\t\t/*\n            logger.debug(\n                'consumer event -- [close] [id:%s, originator:%s, consumer:%o]',\n\t\t\t\tconsumer.id, originator, consumer);\n\t\t\t*/\n\t\t\tlogger.debug(`consumer event [close] - consumer.id: ${consumer.id} originator: ${originator}`);\n\n\t\t\t// clearInterval(this._intervalStats);\n\n\t\t\t// There comunicated peers are sited the same server.\n\t\t\t// 'CLOSE' signal.\n\t\t\t// if (consumer.peer.stream !== null) {\n\t\t\t//     if (consumer.kind === 'video' && consumer.peer.stream !== null) {\n\t\t\t//         let tracks = consumer.peer.stream.streamObj.getVideoTracks();\n\t\t\t//         tracks.forEach(element => {\n\t\t\t//             consumer.peer.stream.streamObj.removeTrack(element);\n\t\t\t//         });\n\t\t\t//     }\n\n\t\t\t//     if (consumer.kind === 'audio' && consumer.peer.stream !== null) {\n\t\t\t//         let tracks = consumer.peer.stream.streamObj.getAudioTracks();\n\t\t\t//         tracks.forEach(element => {\n\t\t\t//             consumer.peer.stream.streamObj.removeTrack(element);\n\t\t\t//         });\n\t\t\t//     }\n\t\t\t//     this.emit('stream-removed', { stream: consumer.peer.stream });\n\t\t\t//     consumer.peer.stream = null;\n\t\t\t// }\n\n\t\t\t// this.emit(`${consumer.kind}-removed`);\n\t\t\tconsumer.disableStats();\n\t\t\t\n\t\t\t// consumer.disableInternalStats()\n\t\t})\n\n\t\tconsumer.on('pause', (originator) =>\n\t\t{\n\t\t\t// \n\t\t\tthis._stats.actStreamSSRCPairs(`consumer_${consumer.id}`, false);\n\t\t\t/*\n            logger.debug(\n                'consumer event -- [pause] [id:%s, originator:%s, consumer:%o]',\n\t\t\t\tconsumer.id, originator, consumer);\n\t\t\t*/\n\t\t\tlogger.debug(`consumer event [pause] - consumer.id: ${consumer.id} originator: ${originator}`);\n\n\t\t\tlet smute = 'audio-mute';\n\t\t\tif (consumer.kind === 'audio')\n\t\t\t{\n\t\t\t\tsmute = 'audio-mute';\n\t\t\t}\n\n\t\t\tif (consumer.kind === 'video')\n\t\t\t{\n\t\t\t\tsmute = 'video-mute';\n\t\t\t}\n\n\t\t\t// There comunicated peers are sited the different servers.\n\t\t\t// 'PAUSE' signal.\n\t\t\t// let remotePaused = 0;\n\t\t\t// if (originator === 'remote') {\n\t\t\t//     let peer = this._peers.get(consumer.peer.name);\n\t\t\t//     if (peer != null) {\n\t\t\t//         peer.consumers.forEach(element => {\n\t\t\t//             if (element.kind === 'audio' && element.remotelyPaused) {\n\t\t\t//                 remotePaused += 1;\n\t\t\t//             }\n\n\t\t\t//             if (element.kind === 'video' && element.remotelyPaused) {\n\t\t\t//                 remotePaused += 1;\n\t\t\t//             }\n\t\t\t//         });\n\t\t\t//     }\n\n\t\t\t//     if (remotePaused >= 2) {\n\t\t\t//         if (consumer.peer.stream !== null) {\n\t\t\t//             let vtracks = consumer.peer.stream.streamObj.getVideoTracks();\n\t\t\t//             vtracks.forEach(e => {\n\t\t\t//                 consumer.peer.stream.streamObj.removeTrack(e);\n\t\t\t//             });\n\n\t\t\t//             let atracks = consumer.peer.stream.streamObj.getAudioTracks();\n\t\t\t//             atracks.forEach(e => {\n\t\t\t//                 consumer.peer.stream.streamObj.removeTrack(e);\n\t\t\t//             });\n\n\t\t\t//             this.emit('stream-removed', { stream: consumer.peer.stream });\n\t\t\t//             consumer.peer.stream = null;\n\t\t\t//         }\n\t\t\t//     }\n\t\t\t// }\n\n\t\t\t// if (originator === 'remote' && remotePaused <= 1)\n\t\t\tif (originator === 'remote')\n\t\t\t{\n\t\t\t\tif (consumer.peer && consumer.peer.streams && consumer.appData)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug(`API _handleConsumer() consumer event [pause] - streamId: ${consumer.appData.streamID} userID: ${consumer.peer.name} - Emit [${smute}] to APP`);\n\t\t\t\t\tthis.emit(smute, {\n\t\t\t\t\t\tstream: consumer.peer.streams.get(consumer.appData.streamID)\n\t\t\t\t\t});\n\n\t\t\t\t\t// only for stat\n\t\t\t\t\tthis._subscribes.set(consumer.appData.streamID, {\n\t\t\t\t\t\tstreamID: consumer.appData.streamID,\n\t\t\t\t\t\tstatus: 'inactive'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('API _handleConsumer() consumer event [pause] error - invalid consumer.peer or consumer.appData');\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tconsumer.on('resume', (originator) =>\n\t\t{\n\t\t\t// \n\t\t\tthis._stats.actStreamSSRCPairs(`consumer_${consumer.id}`, true);\n\t\t\t/*\n            logger.debug(\n                'consumer event -- [resume] [id:%s, originator:%s, consumer:%o]',\n\t\t\t\tconsumer.id, originator, consumer);\n\t\t\t\t*/\n\t\t\tlogger.debug(`consumer event [resume] - consumer.id: ${consumer.id} originator: ${originator}`);\n\n\t\t\tlet smute = 'audio-unmute';\n\t\t\tif (consumer.kind === 'audio')\n\t\t\t{\n\t\t\t\tsmute = 'audio-unmute';\n\t\t\t}\n\n\t\t\tif (consumer.kind === 'video')\n\t\t\t{\n\t\t\t\tsmute = 'video-unmute';\n\t\t\t}\n\n\t\t\tif (originator === 'remote')\n\t\t\t{\n\t\t\t\tif (consumer.peer && consumer.peer.streams && consumer.appData)\n\t\t\t\t{\n\t\t\t\t\tlet stream = consumer.peer.streams.get(consumer.appData.streamID);\n\t\t\t\t\tif (smute === 'video-unmute')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!this._remoteVideos.has(consumer.appData.streamID))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.emit('video-added', { stream });\n\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\tthis._remoteVideos.set(stream.getId(), {\n\t\t\t\t\t\t\t\tuserId: consumer.peer.name,\n\t\t\t\t\t\t\t\tstreamId: stream.getId()\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// \n\t\t\t\t\tlogger.debug(`API _handleConsumer() consumer event [resume] - streamId: ${consumer.appData.streamID} userID: ${consumer.peer.name} - Emit [${smute}] to APP`);\n\t\t\t\t\tthis.emit(smute, { stream });\n\n\t\t\t\t\t// only for stat\n\t\t\t\t\tthis._subscribes.set(consumer.appData.streamID, {\n\t\t\t\t\t\tstreamID: consumer.appData.streamID,\n\t\t\t\t\t\tstatus: 'active'\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('API _handleConsumer() consumer event [resume] - error - invalid consumer.peer or consumer.appData');\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tconsumer.on('effectiveprofilechange', (profile) =>\n\t\t{\n\t\t\t/*\n            logger.debug(\n                'consumer event -- [effectiveprofilechange] [id:%s, consumer:%o, profile:%s]',\n\t\t\t\tconsumer.id, consumer, profile);\n\t\t\t\t*/\n\t\t\tlogger.debug(`consumer event [effectiveprofilechange] - consumer.id: ${consumer.id} profile: ${profile}`);\n\t\t})\n\n\t\tconsumer.on('stats', (stats) =>\n\t\t{\n\t\t\tconsumer.getStats()\n\t\t\t\t.then((s) =>\n\t\t\t\t{\n\t\t\t\t\tlet r = {};\n\t\t\t\t\tif (!!consumer.track && consumer.track.kind === 'video')\n\t\t\t\t\t{\n\t\t\t\t\t\tr = this._extractResolution(s);\n\t\t\t\t\t}\n\n\t\t\t\t\t// \n\t\t\t\t\tif (!consumer.peer)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sid = consumer.peer.name;\n\t\t\t\t\tif (!!consumer.appData)\n\t\t\t\t\t{\n\t\t\t\t\t\tsid = consumer.appData.streamID;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._stats.setConsumeStats(stats, r, consumer.peer.name, consumer.id, sid);\n\t\t\t\t})\n\t\t\t\t.catch(e =>\n\t\t\t\t{\n\t\t\t\t\tlogger.error(`consumer event [stats] error - ${e.toString()}`);\n\t\t\t\t})\n\t\t})\n\n\t\tconsumer.on('internalStats', (stats) =>\n\t\t{\n\t\t\tif (!consumer.peer)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet result = this._internalStats('receiverStats', stats, consumer.peer.name, consumer.id);\n\t\t\tthis._stats.pushLoggerToServer(null, result);\n\t\t})\n\n\t\t// Receive the consumer (if we can).\n\t\tif (consumer.supported)\n\t\t{\n\t\t\t// TODO : 将 streams 变量显式定义到 mediasoupclient::Peer 中\n\t\t\tif (!consumer.peer.streams)\n\t\t\t\tconsumer.peer.streams = new Map();\n\n\t\t\t// Seek after existing stream.\n\t\t\tlet stream_ = consumer.peer.streams.get(consumer.appData.streamID);\n\t\t\tif (!stream_)\n\t\t\t{\n\t\t\t\tstream_ = new Stream({\n\t\t\t\t\tuserID: consumer.peer.name,\n\t\t\t\t\tsource: consumer.appData.source,\n\t\t\t\t\tstreamID: !consumer.appData.streamID ? consumer.peer.name : consumer.appData.streamID,\n\t\t\t\t\tvideoType: consumer.appData.videoType,\n\t\t\t\t\tstreamType: 'consumer'\n\t\t\t\t});\n\t\t\t\tstream_.streamObj = new MediaStream();\n\t\t\t\tconsumer.peer.streams.set(stream_.streamID, stream_);\n\t\t\t}\n\n\t\t\tconsumer.receive(this._recvTransport)\n\t\t\t\t.then((track) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug(`API _handleConsumer() consumer.receive - consumer.name: ${consumer.peer.name} track.kind: ${track.kind}`);\n\n\t\t\t\t\tif (track.kind === 'audio')\n\t\t\t\t\t{\n\t\t\t\t\t\tstream_.audioTracks = track;\n\n\t\t\t\t\t\t// TODO : 如下采用 timer 并不合理\n\t\t\t\t\t\tsetTimeout(() =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger.debug(`API _handleConsumer() consumer userID: ${consumer.peer.name} streamId: ${stream_.getId()} - Emit [audio-added] to APP`);\n\t\t\t\t\t\t\tthis.emit('audio-added', { stream: stream_ });\n\t\t\t\t\t\t}, 100);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (track.kind === 'video')\n\t\t\t\t\t{\n\t\t\t\t\t\tstream_.videoTracks = track;\n\n\t\t\t\t\t\t// TODO : 如下采用 timer 并不合理\n\t\t\t\t\t\tsetTimeout(() =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger.debug(`API _handleConsumer() consumer userID: ${consumer.peer.name} streamId: ${stream_.getId()} - Emit [video-added] to APP`);\n\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\tif (!consumer.remotelyPaused)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.emit('video-added', { stream: stream_ });\n\n\t\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\t\tthis._remoteVideos.set(stream_.getId(), {\n\t\t\t\t\t\t\t\t\tuserId: consumer.peer.name,\n\t\t\t\t\t\t\t\t\tstreamId: stream_.getId()\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t}, 100);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (stream_.trackNumber === 1)\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO : 如下采用 timer 并不合理\n\t\t\t\t\t\t// delay 500ms, becasuse need waiting peer-join event arrived.\n\t\t\t\t\t\tsetTimeout(() =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger.debug(`API _handleConsumer() consumer userID: ${consumer.peer.name} streamId: ${stream_.getId()} - Emit [stream-added] to APP`);\n\t\t\t\t\t\t\tthis.emit('stream-added', { stream: stream_, type: stream_.type });\n\t\t\t\t\t\t}, 500);\n\t\t\t\t\t}\n\n\t\t\t\t\tconsumer.transport.handler._pc.getStats(track).then(stat =>\n\t\t\t\t\t{\n\t\t\t\t\t\tstat.forEach(e =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (e.type === 'inbound-rtp')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlet { id, value } = this._stats.getStreamPropertyBySSRC(e.ssrc, 'userID');\n\t\t\t\t\t\t\t\tif (value === '')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tthis._stats.setStreamSSRCPairs(`consumer_${consumer.id}`, e.ssrc, stream_, false)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.catch((error) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.error(`API _handleConsumer() error - unexpected error while receiving a new Consumer: ${error.toString()}`);\n\t\t\t\t});\n\n\t\t\t// pause the track by default.\n\t\t\tif (!stream_.subscribed)\n\t\t\t\tconsumer.pause();\n\n\t\t\t// Concern transmission statistics.\n\t\t\t/* \n\t\t\t// 2020/2/4 禁用\n\t\t\tconsumer.enableInternalStats(this._interval);\n\t\t\t*/\n\t\t\tconsumer.enableStats(this._interval);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger.warn(`API _handleConsumer() error - consumer.peer.name: ${consumer.peer.name} consumer.supported: ${consumer.supported}`);\n\t\t}\n\t}\n\n\t_setMicProducer(stream)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API _setMicProducer() error - parameter [stream] is INVALID.');\n\t\t\treturn Promise.reject(new Error('INVALID parameter [stream]'));\n\t\t}\n\n\t\tlogger.debug(`API _setMicProducer() - stream.streamID: ${stream.streamID}`);\n\n\t\tif (!this._room.canSend('audio'))\n\t\t{\n\t\t\treturn Promise.reject(new Error('cannot send audio'));\n\t\t}\n\n\t\tif (this._mapMicProducers.get(stream._innerStreamID))\n\t\t{\n\t\t\treturn Promise.reject(new Error('mic Producer already exists'));\n\t\t}\n\n\t\tlet producer;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst track = stream.streamObj.getAudioTracks()[0];\n\n\t\t\t\t// send inner-stream identify.\n\t\t\t\tproducer = this._room.createProducer(\n\t\t\t\t\ttrack, {\n\t\t\t\t\t\taudioProfile : stream.getAudioProfile(),\n\t\t\t\t\t}, {\n\t\t\t\t\t\tsource   : `mic_${stream.streamID}`,\n\t\t\t\t\t\tstreamID : stream.innerStreamID,\n\t\t\t\t\t\tuserID   : stream.userID\n\t\t\t\t\t});\n\t\t\t\t// No need to keep original track.\n\t\t\t\t// track.stop();\n\n\t\t\t\t// Send it.\n\t\t\t\treturn producer.send(this._sendTransport);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tthis._mapMicProducers.set(stream._innerStreamID, producer);\n\t\t\t\tproducer.enableStats(this._interval);\n\n\t\t\t\t/*\n\t\t\t\t// 2020/2/4 禁用\n\t\t\t\tproducer.enableInternalStats(this._interval);\n\t\t\t\t*/\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: producer.id,\n\t\t\t\t\t\tsource: 'mic',\n\t\t\t\t\t\tlocallyPaused: producer.locallyPaused,\n\t\t\t\t\t\tremotelyPaused: producer.remotelyPaused,\n\t\t\t\t\t\ttrack: producer.track,\n\t\t\t\t\t\tcodec: producer.rtpParameters.codecs[0].name\n\t\t\t\t\t});\n\n\t\t\t\tproducer.on('close', (originator) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug(`_setMicProducer() micProducer event [close] - [originator:${originator}]`);\n\n\t\t\t\t\tif (originator === 'remote')\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.debug('producer close');\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._mapMicProducers.delete(stream._innerStreamID);\n\n\t\t\t\t\tproducer.disableStats();\n\t\t\t\t\t// producer.disableInternalStats();\n\t\t\t\t})\n\n\t\t\t\tproducer.on('pause', (originator) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug(`_setMicProducer() micProducer event [pause] - [originator:${originator}]`);\n\t\t\t\t})\n\n\t\t\t\tproducer.on('resume', (originator) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug(`_setMicProducer() micProducer event [resume] - [originator:${originator}]`);\n\t\t\t\t});\n\n\t\t\t\tproducer.on('handled', () =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('_setMicProducer() micProducer event [handled]');\n\t\t\t\t});\n\n\t\t\t\tproducer.on('unhandled', () =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('_setMicProducer() micProducer event [unhandled]');\n\t\t\t\t});\n\n\t\t\t\tproducer.on('stats', (stats) =>\n\t\t\t\t{\n\t\t\t\t\tthis._stats.setMicStats(stats, stream._innerStreamID);\n\t\t\t\t});\n\n\t\t\t\tproducer.on('internalStats', stats =>\n\t\t\t\t{\n\t\t\t\t\tlet result = this._internalStats('senderStats', stats);\n\t\t\t\t\tthis._stats.pushLoggerToServer(null, result);\n\t\t\t\t});\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlogger.debug('_setMicProducer() succeeded');\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tlogger.error(`_setMicProducer() failed - ${error.toString()}`);\n\n\t\t\t\tif (producer)\n\t\t\t\t{\n\t\t\t\t\tproducer.close();\n\t\t\t\t\tthis._mapMicProducers.delete(stream._innerStreamID);\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t_setWebcamProducer(stream)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API _setWebcamProducer() error - parameter [stream] is INVALID.');\n\t\t\treturn Promise.reject(new Error('INVALID parameter [stream]'));\n\t\t}\n\n\t\tlogger.debug(`API _setWebcamProducer() stream.streamID: ${stream.streamID}`);\n\n\t\tif (!this._room.canSend('video'))\n\t\t{\n\t\t\treturn Promise.reject(new Error('cannot send video'));\n\t\t}\n\n\t\tif (this._webcamProducer)\n\t\t{\n\t\t\treturn Promise.reject(new Error('webcam Producer already exists'));\n\t\t}\n\n\t\tlet producer;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(async () =>\n\t\t\t{\n\t\t\t\tconst track = stream.streamObj.getVideoTracks()[0];\n\n\t\t\t\t// send inner-stream identify.                \n\t\t\t\tproducer = this._room.createProducer(\n\t\t\t\t\ttrack, {\n\t\t\t\t\t\tsimulcast    : this._useSimulcast,\n\t\t\t\t\t\taudioProfile : stream.getAudioProfile(),\n\t\t\t\t\t\tcodecOptions : {\n\t\t\t\t\t\t\tvideoGoogleStartBitrate : stream.idealBandwidth,\n\t\t\t\t\t\t\tvideoGoogleMaxBitrate   : stream.maxBandwidth,\n\t\t\t\t\t\t\tvideoGoogleMinBitrate   : stream.minBandwidth\n\t\t\t\t\t\t}\n\t\t\t\t\t}, {\n\t\t\t\t\t\tsource    : `webcam_${stream.streamID}`,\n\t\t\t\t\t\tstreamID  : stream.innerStreamID,\n\t\t\t\t\t\tuserID    : stream.userID,\n\t\t\t\t\t\tvideoType : stream.videoType\n\t\t\t\t\t});\n\n\t\t\t\t// No need to keep original track.\n\t\t\t\t// track.stop();\n\n\t\t\t\t// Send it.\n\t\t\t\tlet transport;\n\t\t\t\tif (this._sendTransport.videoSent())\n\t\t\t\t{\n\t\t\t\t\ttransport = await this._newTransport('send', 'web_cam');\n\t\t\t\t\tthis._mapVideoSendTransports.set(stream._innerStreamID, transport);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttransport = this._sendTransport;\n\t\t\t\t}\n\n\t\t\t\treturn producer.send(transport);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tthis._mapWebcamProducers.set(stream._innerStreamID, producer);\n\t\t\t\tproducer.enableStats(this._interval);\n\n\t\t\t\t/*\n\t\t\t\t// 2020/2/4 禁用\n\t\t\t\tproducer.enableInternalStats(this._interval);\n\t\t\t\t*/\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: producer.id,\n\t\t\t\t\t\tsource: 'webcam',\n\t\t\t\t\t\tdeviceLabel: 'device.webcam',\n\t\t\t\t\t\ttype: 'front/rear',\n\t\t\t\t\t\tlocallyPaused: producer.locallyPaused,\n\t\t\t\t\t\tremotelyPaused: producer.remotelyPaused,\n\t\t\t\t\t\ttrack: producer.track,\n\t\t\t\t\t\tcodec: producer.rtpParameters.codecs[0].name\n\t\t\t\t\t});\n\n\t\t\t\tproducer.on('close', (originator) =>\n\t\t\t\t{\n\t\t\t\t\t// \n\t\t\t\t\tthis._stats.removeStreamById(`producer_${producer.id}`);\n\t\t\t\t\t// \n\t\t\t\t\tlogger.debug(`_setWebcamProducer() webcamProducer event [close] - [originator:${originator}]`);\n\n\t\t\t\t\tproducer.disableStats();\n\t\t\t\t\t// producer.disableInternalStats();\n\n\t\t\t\t\tthis._mapWebcamProducers.delete(stream._innerStreamID);\n\t\t\t\t\tlet transport = this._mapVideoSendTransports.get(stream._innerStreamID);\n\t\t\t\t\tif (typeof transport !== 'undefined')\n\t\t\t\t\t{\n\t\t\t\t\t\ttransport.close();\n\t\t\t\t\t\ttransport.removeAllListeners();\n\t\t\t\t\t\tthis._mapVideoSendTransports.delete(stream._innerStreamID);\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tproducer.on('pause', (originator) =>\n\t\t\t\t{\n\t\t\t\t\t// \n\t\t\t\t\tthis._stats.actStreamSSRCPairs(`producer_${producer.id}`, false);\n\t\t\t\t\t// \n\t\t\t\t\tlogger.debug(`_setWebcamProducer() webcamProducer event [pause] - [originator:${originator}]`);\n\t\t\t\t});\n\n\t\t\t\tproducer.on('resume', (originator) =>\n\t\t\t\t{\n\t\t\t\t\t// \n\t\t\t\t\tthis._stats.actStreamSSRCPairs(`producer_${producer.id}`, true);\n\t\t\t\t\t// \n\t\t\t\t\tlogger.debug(`_setWebcamProducer() webcamProducer event [resume] [originator:${originator}]`);\n\t\t\t\t});\n\n\t\t\t\tproducer.on('handled', () =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('_setWebcamProducer() webcamProducer event [handled]');\n\t\t\t\t});\n\n\t\t\t\tproducer.on('unhandled', () =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('_setWebcamProducer() webcamProducer event [unhandled]');\n\t\t\t\t});\n\n\t\t\t\tproducer.on('stats', (stats) =>\n\t\t\t\t{\n\t\t\t\t\t// logger.log(stats);\n\t\t\t\t\tthis._stats.setWebcamStats(stats, stream._innerStreamID);\n\t\t\t\t})\n\n\t\t\t\tproducer.on('internalStats', stats =>\n\t\t\t\t{\n\t\t\t\t\tlet result = this._internalStats('senderStats', stats);\n\t\t\t\t\tthis._stats.pushLoggerToServer(null, result);\n\t\t\t\t});\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlogger.debug('_setWebcamProducer() succeeded');\n\t\t\t\tproducer.transport.handler._pc.getStats(producer.track).then(stat =>\n\t\t\t\t{\n\t\t\t\t\tstat.forEach(e =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (e.type === 'outbound-rtp')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis._stats.setStreamSSRCPairs(`producer_${producer.id}`, e.ssrc, stream, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tlogger.error('_setWebcamProducer() failed:%o', error);\n\n\t\t\t\tif (producer)\n\t\t\t\t{\n\t\t\t\t\tproducer.close();\n\t\t\t\t\tthis._mapWebcamProducers.delete(stream._innerStreamID);\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n    /**\n     * set(create) screen producer.\n     * \n     * @param {Any} stream screen stream.\n     */\n\t_setScreenProducer(stream)\n\t{\n\t\tif (!stream)\n\t\t{\n\t\t\tlogger.error('API _setScreenProducer() error - parameter [stream] is INVALID.');\n\t\t\treturn Promise.reject(new Error('INVALID parameter [stream]'));\n\t\t}\n\n\t\tlogger.debug(`API _setScreenProducer() streamId: ${stream.innerStreamID}`);\n\n\t\tif (!this._room.canSend('video'))\n\t\t{\n\t\t\treturn Promise.reject(new Error('cannot send video'));\n\t\t}\n\n\t\tif (this._screenProducer)\n\t\t{\n\t\t\treturn Promise.reject(new Error('screen Producer already exists'));\n\t\t}\n\n\t\tlet producer;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(async () =>\n\t\t\t{\n\t\t\t\tconst track = stream.streamObj.getVideoTracks()[0];\n\n\t\t\t\tproducer = this._room.createProducer(\n\t\t\t\t\ttrack, {\n\t\t\t\t\t\tsimulcast : this._useSimulcast\n\t\t\t\t\t}, {\n\t\t\t\t\t\tsource   : 'screen',\n\t\t\t\t\t\tstreamID : stream.innerStreamID\n\t\t\t\t\t});\n\n\t\t\t\t// No need to keep original track.\n\t\t\t\t// track.stop();\n\n\t\t\t\t// Send it.\n\t\t\t\tthis._screenTransport = await this._newTransport('send', 'screen');\n\t\t\t\treturn producer.send(this._screenTransport);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tthis._screenProducer = producer;\n\t\t\t\tthis._screenProducer.enableStats(this._interval);\n\n\t\t\t\t/*\n\t\t\t\t// 2020/2/4 禁用\n\t\t\t\tthis._screenProducer.enableInternalStats(this._interval);\n\t\t\t\t*/\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t{\n\t\t\t\t\t\tid: producer.id,\n\t\t\t\t\t\tsource: 'screen',\n\t\t\t\t\t\tdeviceLabel: 'device.screen',\n\t\t\t\t\t\ttype: 'front',\n\t\t\t\t\t\tlocallyPaused: producer.locallyPaused,\n\t\t\t\t\t\tremotelyPaused: producer.remotelyPaused,\n\t\t\t\t\t\ttrack: producer.track,\n\t\t\t\t\t\tcodec: producer.rtpParameters.codecs[0].name\n\t\t\t\t\t});\n\n\t\t\t\tproducer.on('close', (originator) =>\n\t\t\t\t{\n\t\t\t\t\t// \n\t\t\t\t\tthis._stats.removeStreamById(`producer_${producer.id}`);\n\t\t\t\t\t// \n\t\t\t\t\tlogger.debug(`setScreenProducer() screenProducer event [close] - [originator:${originator}]`);\n\n\t\t\t\t\tthis._screenProducer = null;\n\t\t\t\t\tthis._screenTransport.close();\n\t\t\t\t\tthis._screenTransport.removeAllListeners();\n\t\t\t\t\tthis._screenTransport = null;\n\n\t\t\t\t\tproducer.disableStats();\n\t\t\t\t\t// producer.disableInternalStats();\n\t\t\t\t});\n\n\t\t\t\tproducer.on('pause', (originator) =>\n\t\t\t\t{\n\t\t\t\t\t// \n\t\t\t\t\tthis._stats.actStreamSSRCPairs(`producer_${producer.id}`, false);\n\t\t\t\t\t// \n\t\t\t\t\tlogger.debug(`_setScreenProducer() screenProducer event [pause] - [originator:${originator}]`);\n\t\t\t\t});\n\n\t\t\t\tproducer.on('resume', (originator) =>\n\t\t\t\t{\n\t\t\t\t\t// \n\t\t\t\t\tthis._stats.actStreamSSRCPairs(`producer_${producer.id}`, true);\n\t\t\t\t\t// \n\t\t\t\t\tlogger.debug(`_setScreenProducer() screenProducer event [resume] - [originator:${originator}]`);\n\t\t\t\t});\n\n\t\t\t\tproducer.on('handled', () =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('_setScreenProducer() screenProducer event [handled]');\n\t\t\t\t});\n\n\t\t\t\tproducer.on('unhandled', () =>\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('screen Producer event [unhandled]');\n\t\t\t\t});\n\n\t\t\t\tproducer.on('stats', (stats) =>\n\t\t\t\t{\n\t\t\t\t\t// logger.log(stats);\n\t\t\t\t\tthis._stats.setWebcamStats(stats, stream.innerStreamID);\n\t\t\t\t});\n\n\t\t\t\tproducer.on('internalStats', stats =>\n\t\t\t\t{\n\t\t\t\t\tlet result = this._internalStats('senderStats', stats);\n\t\t\t\t\tthis._stats.pushLoggerToServer(null, result);\n\t\t\t\t});\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlogger.debug('_setScreenProducer() succeeded');\n\t\t\t\tproducer.transport.handler._pc.getStats(producer.track).then(stat =>\n\t\t\t\t{\n\t\t\t\t\tstat.forEach(e =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (e.type === 'outbound-rtp')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis._stats.setStreamSSRCPairs(`producer_${producer.id}`, e.ssrc, stream, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tlogger.error('_setScreenProducer() failed:%o', error);\n\n\t\t\t\tif (producer)\n\t\t\t\t{\n\t\t\t\t\tproducer.close();\n\t\t\t\t\tthis._screenProducer = null;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t})\n\t}\n\n    /**\n     * Delay with some of milliseconds.\n     * \n     * @param {number} ms milliseconds\n     */\n\t_delay(ms)\n\t{\n\t\tvar ctr, rej, p = new Promise(function (resolve, reject)\n\t\t{\n\t\t\tctr = setTimeout(resolve, ms);\n\t\t\trej = reject;\n\t\t});\n\t\tp.cancel = function () { clearTimeout(ctr); rej(Error('Cancelled')) };\n\t\treturn p;\n\t}\n\n\t// 中止 ice restart 重试\n\t_stopIceRestartTimer()\n\t{\n\t\tif (!!this.iceRestartTimer)\n\t\t{\n\t\t\tclearInterval(this.iceRestartTimer);\n\t\t\tthis.iceRestartTimer = null;\n\t\t}\n\t}\n\n\t_retryRestartIce(transport)\n\t{\n\t\tif (!transport)\n\t\t{\n\t\t\tlogger.error('_retryRestartIce() error - parameter [transport] is INVALID');\n\t\t\treturn;\n\t\t}\n\n\t\t// No need doing anythin if protoo closed.\n\t\tif (!this._protoo || this._protoo.closed)\n\t\t{\n\t\t\tlogger.warn(`_retryRestartIce() error - _protoo not connected.`);\n\t\t\treturn;\n\t\t}\n\n\t\t// if state is 'connected'.\n\t\tif (transport.connectionState === 'connected')\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.debug(`_retryRestartIce() - transport.id: ${transport.id}`);\n\n\t\tlet retry_time = 0;\n\t\tthis.iceRestartTimer = setInterval(() =>\n\t\t{\n\t\t\t// if protoo was closed.\n\t\t\tif (!this._protoo || this._protoo.closed)\n\t\t\t{\n\t\t\t\tif (!!this.iceRestartTimer)\n\t\t\t\t{\n\t\t\t\t\tclearInterval(this.iceRestartTimer);\n\t\t\t\t}\n\t\t\t\tthis.iceRestartTimer = null;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// 如果当前尚未进入连接状态，则直接return\n\t\t\tif (!this._protoo.connected)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// \n\t\t\tif (!this._joined)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if too many retries.\n\t\t\tif (retry_time++ > Client.ICE_RETRY_NUM_TIME)\n\t\t\t{\n\t\t\t\tif (!!this.iceRestartTimer)\n\t\t\t\t{\n\t\t\t\t\tclearInterval(this.iceRestartTimer);\n\t\t\t\t}\n\t\t\t\tthis.iceRestartTimer = null;\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.debug(`iceRestartTimer - retrying ... transport.id: ${transport.id} retry_time: ${retry_time}`);\n\n\t\t\tthis._restartIce(transport)\n\t\t\t\t.then(() =>\n\t\t\t\t{\n\t\t\t\t\t// let transport_ = tp\n\t\t\t\t\tsetTimeout(() =>\n\t\t\t\t\t{\n\t\t\t\t\t\tif (transport.connectionState === 'connected')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger.debug(`iceRestartTimer - [connected] transport.id: ${transport.id} retry_time: ${retry_time}`);\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\tif (!!this.iceRestartTimer)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tclearInterval(this.iceRestartTimer);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.iceRestartTimer = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 1000);\n\n\t\t\t\t\treturn;\n\t\t\t\t})\n\t\t\t\t.catch((error) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(`_retryRestartIce() error - ${error.toString()}`);\n\t\t\t\t})\n\t\t}, 3000);\n\t}\n\n    /**\n     * restart ICE.\n     * @param {Any} tp transport \n     */\n\tasync _restartIce(tp)\n\t{\n\t\ttry\n\t\t{\n\t\t\t// only try the transport ice restarting.\n\t\t\tawait tp.restartIce(null, (e) =>\n\t\t\t{\n\t\t\t\tlogger.warn(`_restartIce() transport.id: ${tp.id} error - ${e.toString()}`);\n\t\t\t});\n\t\t\tlogger.debug(`_restartIce() transport.id: ${tp.id}`);\n\n\t\t\treturn tp;\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.error(`_restartIce() error - ${error.toString()}`);\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tgetNetState()\n\t{\n\t\tif (!!this._stats)\n\t\t{\n\t\t\treturn this._stats.netState;\n\t\t}\n\n\t\treturn {};\n\t}\n\n\t/**\n\t * get audio recv stats\n\t * @param {*} callback \n\t * \n\t */\n\tgetRemoteAudioStats(callback)\n\t{\n\t\tif (typeof callback !== 'function')\n\t\t{\n\t\t\tlogger.error('API getRemoteAudioStats() error - parameter: callback invalid');\n\t\t\tthrow new TypeError('callback is not function.');\n\t\t}\n\n\t\tcallback(this._stats.audioDownStat);\n\t}\n\n\t/**\n\t * get video recv stats\n\t * @param {*} callback \n\t * \n\t */\n\tgetRemoteVideoStats(callback)\n\t{\n\t\tif (typeof callback !== 'function')\n\t\t{\n\t\t\tlogger.error('API getRemoteVideoStats() error - parameter: callback invalid');\n\t\t\tthrow new TypeError('callback is not function.');\n\t\t}\n\n\t\tcallback(this._stats.videoDownStat);\n\t}\n\n\t/**\n\t * get audio send stats\n\t * @param {*} callback \n\t */\n\tgetLocalAudioStats(callback)\n\t{\n\t\tif (typeof callback !== 'function')\n\t\t{\n\t\t\tlogger.error('API getLocalAudioStats() error - parameter: callback invalid');\n\t\t\tthrow new TypeError('callback is not function.');\n\t\t}\n\n\t\tcallback(this._stats.audioUpStat);\n\t}\n\n\t/**\n\t * get video send stats\n\t * @param {*} callback \n\t */\n\tgetLocalVideoStats(callback)\n\t{\n\t\tif (typeof callback !== 'function')\n\t\t{\n\t\t\tlogger.error('API getLocalVideoStats() error - parameter: callback invalid');\n\t\t\tthrow new TypeError('callback is not function.');\n\t\t}\n\n\t\tcallback(this._stats.videoUpStat);\n\t}\n\n    /**\n     * set sei.\n     * @param {string|number} uid \n     * @param {string} type\n     * @param {Boolean} isScreen\n     * @param {Object} sei conference layout\n     * @param {string} devId innerStreamId\n     */\n\tsetSEI(uid, type, isScreen, sei, devId)\n\t{\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API setSEI() error - protooTransport broken');\n\t\t\tthrow Error('protooTransport broken');\n\t\t}\n\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('API setSEI() error - non-joined');\n\n\t\t\tthrow Error('non-joined');\n\t\t}\n\n\t\tif (this._role !== '1')\n\t\t{\n\t\t\tlogger.warn(`API setSEI() error - Must be master - this._role: ${this._role}`);\n\t\t\tthrow Error('setSEI() error. Role error.');\n\t\t}\n\n\t\tlet _type = '';\n\t\tif (type.toLocaleLowerCase() === 'add')\n\t\t{\n\t\t\t_type = 'add';\n\t\t}\n\t\telse if (type.toLocaleLowerCase() === 'del')\n\t\t{\n\t\t\t_type = 'del';\n\t\t}\n\n\t\tif (_type === '')\n\t\t{\n\t\t\tlogger.error(`setSEI() error - parameter [type] type: ${type} is INVALID`);\n\n\t\t\tthrow TypeError('type');\n\t\t}\n\n\t\tlet sType = {\n\t\t\t'type': _type,\n\t\t\t'peerId': '' + uid,\n\t\t\t'devId': devId || ''\n\t\t}\n\n\t\tif (isScreen)\n\t\t{\n\t\t\tsType.devId = uid + ':screen';\n\t\t\tsei.pos = sei.pos.map(e =>\n\t\t\t{\n\t\t\t\tif (e.id === devId)\n\t\t\t\t{\n\t\t\t\t\te.id = uid + ':screen';\n\t\t\t\t}\n\t\t\t\treturn e;\n\t\t\t});\n\t\t}\n\n\t\tlogger.debug(`API setSEI() - uid: ${uid} type: ${type} isScreen: ${isScreen} sei: ${JSON.stringify(sei)} devId: ${devId}`);\n\n\t\tPromise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlogger.debug(`API setSEI() - setMixer sType: ${JSON.stringify(sType)}`);\n\t\t\t\tthis._protoo.send('setMixer', sType);\n\t\t\t\treturn;\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tthis._protoo.send('setSEI', { sei: sei });\n\t\t\t\treturn;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tlogger.error(`API setSEI() error - ${error}`);\n\t\t\t});\n\t}\n\n\t/**\n\t * subscribe other room's audio/video\n\t * @param {*} subscribeRoomId \n\t * @param {function} onSuccess \n\t * @param {function} onFailure \n\t */\n\tsubscribeOtherRoom(subscribeRoomId, onSuccess, onFailure)\n\t{\n\t\tif (!subscribeRoomId)\n\t\t{\n\t\t\tlogger.error('API subscribeOtherRoom() error - parameter: subscribeRoomId invalid');\n\t\t\tthrow TypeError('subscribeRoomId param error');\n\t\t}\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API subscribeOtherRoom() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API subscribeOtherRoom() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API subscribeOtherRoom() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('API subscribeOtherRoom() error - non-joined');\n\n\t\t\tonFailure('non-joined');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._role !== '1')\n\t\t{\n\t\t\tlogger.warn(`API subscribeOtherRoom() error - Must be master - this._role: ${this._role}`);\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.warn(`API subscribeOtherRoom() - subscribeRoomId: ${subscribeRoomId}`);\n\n\t\tthis._protoo.send('subscribeOtherRoom', { subscribeRoomId })\n\t\t\t.then(onSuccess)\n\t\t\t.catch(onFailure);\n\t}\n\n\t/**\n\t * unsubscribe other room's audio/video\n\t * @param {*} unsubscribeRoomId \n\t * @param {function} onSuccess \n\t * @param {function} onFailure \n\t */\n\tunsubscribeOtherRoom(unsubscribeRoomId, onSuccess, onFailure)\n\t{\n\t\tif (!unsubscribeRoomId)\n\t\t{\n\t\t\tlogger.error('API unsubscribeOtherRoom() error - parameter: unsubscribeRoomId invalid');\n\t\t\tthrow TypeError('unsubscribeRoomId param error');\n\t\t}\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API unsubscribeOtherRoom() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API unsubscribeOtherRoom() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API unsubscribeOtherRoom() error - protooTransport broken');\n\n\t\t\tonFailure('protooTransport is broken');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('API unsubscribeOtherRoom() error - non-joined');\n\n\t\t\tonFailure('non-joined');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._role !== '1')\n\t\t{\n\t\t\tlogger.warn(`API unsubscribeOtherRoom() error - Must be master - this._role: ${this._role}`);\n\t\t\treturn;\n\t\t}\n\n\t\tlogger.warn(`API unsubscribeOtherRoom() - subscribeRoomId: ${unsubscribeRoomId}`);\n\n\t\tthis._protoo.send('unsubscribeOtherRoom', { unsubscribeRoomId })\n\t\t\t.then(onSuccess)\n\t\t\t.catch(onFailure);\n\t}\n\n    /**\n     * switch user role\n     * @param {Number} role\n     * @param {Function} onSuccess\n     * @param {Function} onFailure\n     */\n\tsetClientRole(role, onSuccess, onFailure)\n\t{\n\t\tif (!role)\n\t\t{\n\t\t\tlogger.warn('API setClientRole() error - parameter [role] is INVALID.');\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API setClientRole() error - parameter: onSuccess invalid');\n\t\t\tthrow TypeError('onSuccess is not function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API setClientRole() error - parameter: onFailure invalid');\n\t\t\tthrow TypeError('onFailure is not function.');\n\t\t}\n\n\t\tlet formatRole = +role;\n\t\tif (this._joined)\n\t\t{\n\t\t\tif (!this._protooTransportStat)\n\t\t\t{\n\t\t\t\tlogger.warn('API setClientRole() error - protooTransport broken');\n\n\t\t\t\tonFailure('protooTransport is broken');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (+this._role === formatRole)\n\t\t\t{\n\t\t\t\tonFailure && onFailure('Role has no changed.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (formatRole !== 2 && formatRole !== 3)\n\t\t\t{\n\t\t\t\tonFailure && onFailure('Illegal role: please make sure the role you want to set is 2 or 3.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (+this._role === 1)\n\t\t\t{\n\t\t\t\tonFailure && onFailure('Permision denied: Anchor is not allowed to change role.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.warn(`API setClientRole() - role: ${role}`);\n\n\t\t\t// send message\n\t\t\tthis._protoo.send('changeRole', { role })\n\t\t\t\t.then(() =>\n\t\t\t\t{\n\t\t\t\t\tthis._role = role;\n\t\t\t\t\tonSuccess && onSuccess();\n\t\t\t\t})\n\t\t\t\t.catch(onFailure)\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (formatRole > 3 || formatRole < 1)\n\t\t\t{\n\t\t\t\tlogger.warn('API setClientRole() error - parameter [role] is INVALID.');\n\t\t\t\tonFailure && onFailure('Illegal role: please make sure the role you want to set is 1 or 2 or 3.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlogger.warn(`API setClientRole() - role: ${role}`);\n\n\t\t\tonSuccess && onSuccess();\n\t\t\tthis._role = role;\n\t\t}\n\t}\n\n\tsetRtmpUrl(url)\n\t{\n\t\tif (typeof url !== 'string')\n\t\t{\n\t\t\tlogger.warn(`API setRtmpUrl() error - url: ${typeof url}`);\n\t\t\tthrow TypeError('Wrong arguments: url must be string.');\n\t\t}\n\n\t\t/* 暂不执行格式检查，由上层保证\n\t\tlet pattern = new RegExp('^(rtmp?:\\\\/\\\\/)?' + // protocol\n\t\t\t'((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.)+[a-z]{2,}|' + // domain name\n\t\t\t'((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))' + // OR ip (v4) address\n\t\t\t'(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*' + // port and path\n\t\t\t'(\\\\?[;:&a-z\\\\d%_.~+=-]*)?' + // query string\n\t\t\t'(\\\\#[-a-z\\\\d_]*)?$', 'i'); // fragment locator\n\t\tif (!pattern.test(url))\n\t\t{\n\t\t\tlogger.warn(`API setRtmpUrl() error - url is invalid`);\n\t\t\tthrow Error('url is invalid');\n\t\t}\n\t\t*/\n\n\t\tthis._valid_rtmp_url = url.trim();\n\n\t\tif (this._joined)\n\t\t{\n\t\t\tthis._protoo.send('updateRtmpUrl', { roomId: this._roomId, url });\n\t\t\tlogger.debug(`API setRtmpUrl() success - ${url}`);\n\t\t}\n\t}\n\n    /**\n     * update token\n     * @param {string} token\n     */\n\trenewToken(token)\n\t{\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('you should join room first.');\n\t\t\treturn;\n\t\t}\n\t\tif (typeof token === 'string')\n\t\t{\n\t\t\tthis._protoo.send('refreshToken', { token });\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow TypeError('token must be String. Please retry.');\n\t\t}\n\t}\n\n    /**\n     * kickout peer.\n     * @param {string} peerName \n     */\n\tkickOut(peerName)\n\t{\n\t\tif (!this._protooTransportStat)\n\t\t{\n\t\t\tlogger.warn('API kickOut() error - protooTransport broken');\n\n\t\t\tthrow TypeError('protooTransport is broken');\n\t\t}\n\n\t\tif (!this._joined)\n\t\t{\n\t\t\tlogger.warn('API kickOut() error - non-joined');\n\n\t\t\tthrow TypeError('non-joined');\n\t\t}\n\n\t\tif (!peerName || peerName.trim() === '')\n\t\t{\n\t\t\tlogger.warn('API kickOut() error - parameter [peerName] is INVALID.');\n\n\t\t\tthrow TypeError('peerName');\n\t\t}\n\n\t\tif (this._role !== '1')\n\t\t{\n\t\t\tlogger.warn(`API kickOut() error - Must be master - this._role: ${this._role}`);\n\t\t\tthrow Error('You not master so no permission of kickout.');\n\t\t}\n\n\t\tif (!this._peers.get(peerName))\n\t\t{\n\t\t\tlogger.warn(`API kickOut() error - peerName: ${peerName} not found.`);\n\t\t\tthrow Error(`no this peer: ${peerName}`);\n\t\t}\n\n\t\tlogger.warn(`API kickOut() - peerName: ${peerName}`);\n\n\t\tthis._protoo.send('kickout', { peerId: peerName });\n\t}\n\n\t/**\n\t * get status of ice(sendtransport, recvtransport)\\websocket\\login\n\t */\n\tgetTransportStatus()\n\t{\n\t\treturn {\n\t\t\ticeSendTransport: !(this._sendTransport) || !(this._sendTransport._handler) || !(this._sendTransport._handler._pc) ? 'fault' : this._sendTransport._handler._pc.iceConnectionState,\n\t\t\ticeRecvTransport: !(this._recvTransport) || !(this._recvTransport._handler) || !(this._recvTransport._handler._pc) ? 'fault' : this._recvTransport._handler._pc.iceConnectionState,\n\t\t\twebsocketTransport: !(this._protoo) || !(this._protoo._transport) ? 'fault' : this._protoo._transport.connected,\n\t\t\tloginStatus: this._joined ? 'online' : 'offline'\n\t\t};\n\t}\n\n    /**\n     * extract Resulution (width and height) from stats\n     * @param {Any} stats \n     */\n\t_extractResolution(stats)\n\t{\n\t\tlet resolution = {\n\t\t\tframeHeight: 0,\n\t\t\tframeWidth: 0\n\t\t};\n\n\t\tlet BreakException = {};\n\t\tstats.forEach(report =>\n\t\t{\n\t\t\tObject.keys(report).forEach(statName =>\n\t\t\t{\n\t\t\t\tif (statName.toLocaleLowerCase() === 'frameheight') //frameHeight\n\t\t\t\t\tresolution.frameHeight = report[statName];\n\t\t\t\tif (statName.toLocaleLowerCase() === 'framewidth') //frameWidth\n\t\t\t\t\tresolution.frameWidth = report[statName];\n\t\t\t}\n\t\t\t)\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (resolution.frameWidth !== 0)\n\t\t\t\t{\n\t\t\t\t\tthrow BreakException;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\tif (e !== BreakException)\n\t\t\t\t\tthrow e;\n\t\t\t}\n\t\t})\n\n\t\treturn resolution;\n\t}\n\n    /**\n     * Generate new sending transport.\n     * @param {string} direction send | recv.\n     * @param {string} type Media type of string.\n     */\n\tasync _newTransport(direction, type)\n\t{\n\t\tlet type_ = '';\n\n\t\tif (typeof direction === 'undefined' || direction === null)\n\t\t{\n\t\t\tthrow new TypeError('direction');\n\t\t}\n\t\telse if (direction !== 'send')\n\t\t{\n\t\t\tif (direction !== 'recv')\n\t\t\t{\n\t\t\t\tthrow new TypeError('direction have to be [send|recv]');\n\t\t\t}\n\t\t}\n\n\t\tif (typeof type === 'undefined' || type === null)\n\t\t{\n\t\t\ttype_ = 'SEND_MIC_WEBCAM';\n\t\t}\n\t\telse if (type === '')\n\t\t{\n\t\t\ttype_ = 'SEND_MIC_WEBCAM';\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttype_ = type;\n\t\t}\n\n\t\tlet sendTransport = this._room.createTransport('send', { media: type_ });\n\n\t\tsendTransport.on('close', (originator) =>\n\t\t{\n\t\t\tlogger.debug(`sendTransport event [close] - [originator: ${originator}]`);\n\t\t})\n\n\t\t// The actual code of events we are intresting, and all the stuff heppens in below lines of 'failed'.\n\t\t// Note: The major stats PC follow with default sending transport, thus try one time at here.\n\t\t// \n\t\tsendTransport.on('connectionstatechange', async (connectionstate) =>\n\t\t{\n\t\t\tif (connectionstate === 'disconnected')\n\t\t\t{\n\t\t\t\t// only for stat\n\t\t\t\tthis._iceSendDisconnectedCnt++;\n\n\t\t\t\tlogger.warn('sendTransport disconnected. will retryRestartIce...');\n\t\t\t\tsetTimeout(() =>\n\t\t\t\t{\n\t\t\t\t\tthis._retryRestartIce(sendTransport);\n\t\t\t\t}, this.TIMEOUT_ICE_DISCONNECTED);\n\t\t\t}\n\n\t\t\tif (connectionstate === 'failed')\n\t\t\t{\n\t\t\t\tlogger.warn('sendTransport failed. will retryRestartIce...');\n\t\t\t\tthis._retryRestartIce(sendTransport);\n\t\t\t}\n\n\t\t\tif (connectionstate === 'connected')\n\t\t\t{\n\t\t\t\t// for webrtc internals\n\t\t\t\tgetStats(sendTransport._handler._pc, (result) =>\n\t\t\t\t{\n\t\t\t\t\tthis._stats.setWebrtcInternalSendStats(result);\n\t\t\t\t}, 1000);\n\t\t\t\t// end for webrtc internals\t\n\t\t\t}\n\n\t\t\tlogger.debug(`sendTransport connectionstatechange: ${connectionstate}`);\n\t\t})\n\n\t\treturn sendTransport;\n\t}\n\n    /**\n     * Interanal statistic data.\n     * @param {string} direction for interanl statistic data.\n     * @param {Any} stats statistic data.\n     * @param {name} consumer name.\n     * @param {id} consumer id.\n     */\n\t_internalStats(direction, stats, name, id)\n\t{\n\t\t// Receiver stats[that's our concerned]\n\t\t// Report type=media-source\n\t\t// Report type=certificate ? option\n\t\t// Report type=codec\n\t\t// Report type=candidate-pair\n\t\t// Report type=local-candidate\n\t\t// Report type=remote-candidate\n\t\t// Report type=inbound-rtp\n\t\t// Report type=outbound-rtp\n\t\t// Report type=media-source\n\t\t// Report type=remote-inbound-rtp\n\t\t// Report type=track\n\t\t// Report type=stream\n\t\t// Report type=peer-connection\n\t\t// Report type=transport\n\n\t\t// direction: Receiver stats | Sender stats\n\t\tlet result = {\n\t\t\t'appId': this._appId,\n\t\t\t'userId': this._uid,\n\t\t\t'roomId': this._roomId,\n\t\t\t'stats': 'internalStats',\n\t\t\t'direction': direction,\n\t\t\t'meida-source': [],\n\t\t\t'certificate': [],\n\t\t\t'codec': [],\n\t\t\t'candidate-pair': [],\n\t\t\t'local-candidate': [],\n\t\t\t'remote-candidate': [],\n\t\t\t'inbound-rtp': [],\n\t\t\t'outbound-rtp': [],\n\t\t\t'remote-inbound-rtp': [],\n\t\t\t'track': [],\n\t\t\t'stream': [],\n\t\t\t'peer-connection': [],\n\t\t\t'transport': []\n\t\t}\n\n\t\tstats.forEach(res =>\n\t\t{\n\t\t\tif (res.type === 'certificate')\n\t\t\t{\n\t\t\t\t//ignore\n\t\t\t}\n\n\t\t\tif (res.type === 'codec')\n\t\t\t{\n\t\t\t\tresult['codec'].push(res);\n\t\t\t}\n\n\t\t\tif (res.type === 'candidate-pair')\n\t\t\t{\n\t\t\t\tresult['candidate-pair'].push(res);\n\t\t\t}\n\n\t\t\tif (res.type === 'local-candidate')\n\t\t\t{\n\t\t\t\tresult['local-candidate'].push(res);\n\t\t\t}\n\n\t\t\tif (res.type === 'inbound-rtp')\n\t\t\t{\n\t\t\t\tresult['inbound-rtp'].push(res);\n\t\t\t}\n\n\t\t\tif (res.type === 'track')\n\t\t\t{\n\t\t\t\tresult['track'].push(res);\n\t\t\t}\n\n\t\t\tif (res.type === 'stream')\n\t\t\t{\n\t\t\t\tresult['stream'].push(res);\n\t\t\t}\n\n\t\t\tif (res.type === 'peer-connection')\n\t\t\t{\n\t\t\t\tresult['peer-connection'].push(res);\n\t\t\t}\n\n\t\t\tif (res.type === 'transport')\n\t\t\t{\n\t\t\t\tresult['transport'].push(res);\n\t\t\t}\n\n\t\t\tif (res.type === 'meida-source')\n\t\t\t{\n\t\t\t\tresult['meida-source'].push(res);\n\t\t\t}\n\n\t\t\tif (res.type === 'transport')\n\t\t\t{\n\t\t\t\tresult['transport'].push(res);\n\t\t\t}\n\t\t})\n\n\t\tif (direction === 'receiverStats')\n\t\t{\n\t\t\tresult.consumerPeerId = name;\n\t\t\tresult.consumer = id;\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nmodule.exports = Client;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./lib/client.js?");

/***/ }),

/***/ "./lib/config.js":
/*!***********************!*\
  !*** ./lib/config.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * client config of default.\n * You can coustom it and pass to client object as parameter.\n */\nconst clientConfig = {\n    mode: 'live',\n    codec: 'vp8',\n\tproxyServer: 'YOUR NGINX PROXY SERVER IP',\n    turnServer: {\n        turnServerURL: 'turn:114.116.84.241', //YOUR TURNSERVER URL\n        username: 'lijunshan', //YOUR USERNAME\n        password: '123456', //YOUR PASSWORD\n        udpport: 'THE UDP PORT YOU WANT TO ADD',\n        tcpport: 'THE TCP PORT YOU WANT TO ADD',\n\t\ticeTransportPolicy: 'all' // relay, all\n    },\n    svcRootUrl: '119_3_245_117.3ttech.cn',\n    role: '2',\n    publish_rtmp_url: 'rtmp://push.3ttech.cn/sdk/?',\n    subcribe_rtmp_url: 'rtmp://pull.3ttech.cn/sdk/?'\n};\n\n/**\n * retry protoo-client\n * @ref: https://www.npmjs.com/package/retry#retryoperationoptions\n * @ref: https://protoojs.org/#websockettransport34\n */\nconst protoo_peer_RETRY_OPTIONS = {\n    retries: 3,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: 8 * 1000\n};\n\n/**\n * stream specication config.\n */\nconst spec = {\n    streamID: null,\n    audio: false,\n    video: false,\n    screen: true,\n    extensionId: 'minllpmhdgpndnkomcoccfekfegnlikg'\n}\n\n/**\n * the log level by defined.\n */\nconst logLevel = {\n    'LOG_NONE': 6, //不输出日志信息\n    'LOG_ERROR': 5, //输出 ERROR 级别的日志信息\n    'LOG_WARN': 4,   //输出 WARN 和 ERROR 级别的日志信息\n    'LOG_INFO': 3,   // 输出 INFO WARN 和 ERROR 级别的日志信息\n    'LOG_DEBUG': 2,   //输出所有 API 日志信息\n    'LOG_TRACE': 1\n};\n\n/**\n * The video profile information.\n * @type {{Profile_80p: string, Profile_120p: string, Profile_180p: string, Profile_240p: string, Profile_360p: string, Profile_480p: string, Profile_720p: string, Profile_1080: string}}\n */\nconst videoProfile = {\n    // profile of resolution  |resolution  | FPS  | bps * k\n    Profile_80p: '80p',       //110*80     | 15   | 50*1000 \n    Profile_120p: '120p',     //120*160    | 15   | 60*1000\n    Profile_160p: '160p',     //210*160    | 15   | 100*1000\n    Profile_200p: '200p',     //270*200    | 15   | 140*1000\n    Profile_240p: '240p',     //320*240    | 15   | 200*1000\n    Profile_320p: '320p',     //420*240    | 15   | 250*1000\n    Profile_360p: '360p',     //480*360    | 15   | 300*1000\n    Profile_480p: '480p',     //640*480    | 15   | 500*1000\n    Profile_540p: '540p',     //720*540    | 15   | 800*1000\n    Profile_720p: '720p',     //1024*720   | 15   | 1130*1000\n    Profile_1080p: '1080p',   //1920*1080  | 15   | 2080*1000\n    Profile_3840p: '3840p',   //3840*2160  | 15   | 8000*1000\n    Profile_7680p: '7680p'    //7680*4320  | 15   | 20000*1000\n};\n\n/** 4:3 resolution and bandwidth */\nconst videoResolution = new Map([\n    [80, { width: 110, height: 80, bps: { ideal: 60 * 1000, min: 50 * 1000, max: 100 * 1000 } }],\n    [120, { width: 160, height: 120, bps: { ideal: 65 * 1000, min: 60 * 1000, max: 100 * 1000 } }],\n    [160, { width: 210, height: 160, bps: { ideal: 140 * 1000, min: 100 * 1000, max: 200 * 1000 } }],\n    [200, { width: 270, height: 200, bps: { ideal: 140 * 1000, min: 100 * 1000, max: 200 * 1000 } }],\n    [240, { width: 320, height: 240, bps: { ideal: 300 * 1000, min: 200 * 1000, max: 400 * 1000 } }],\n    [320, { width: 420, height: 320, bps: { ideal: 350 * 1000, min: 250 * 1000, max: 500 * 1000 } }],\n    [360, { width: 480, height: 360, bps: { ideal: 400 * 1000, min: 300 * 1000, max: 600 * 1000 } }],\n    [480, { width: 640, height: 480, bps: { ideal: 500 * 1000, min: 400 * 1000, max: 800 * 1000 } }],\n    [540, { width: 720, height: 540, bps: { ideal: 1000 * 1000, min: 800 * 1000, max: 1200 * 1000 } }],\n    [720, { width: 1280, height: 720, bps: { ideal: 1130 * 1000, min: 1000 * 1000, max: 2000 * 1000 } }],\n    [1080, { width: 1920, height: 1080, bps: { ideal: 2000 * 1000, min: 1800 * 1000, max: 3000 * 1000 } }],\n    [3840, { width: 3840, height: 2160, bps: { ideal: 8000 * 1000, min: 7000 * 1000, max: 15000 * 1000 } }],\n    [7680, { width: 7680, height: 4320, bps: { ideal: 20000 * 1000, min: 15000 * 1000, max: 25000 * 1000 } }]\n])\n\n/** the screen resolution and bandwidth. */\nconst screenResolution = new Map([\n    [720, { width: 1280, height: 720, bps: { ideal: 1000 * 1000, min: 800 * 1000, max: 1500 * 1000 } }],\n    [1080, { width: 1920, height: 1080, bps: { ideal: 1800 * 1000, min: 1500 * 1000, max: 2000 * 1000 } }],\n    [2160, { width: 3840, height: 2160, bps: { ideal: 2500 * 1000, min: 2000 * 1000, max: 3000 * 1000 } }],\n    [4320, { width: 7680, height: 4320, bps: { ideal: 3000 * 1000, min: 2500 * 1000, max: 4000 * 1000 } }]\n])\n\n/**\n * The video resolution constraints.\n * A vast majority of the customer leaverage it thus it's defined by sensor producters.\n */\nconst videoAttributes = {\n    sif: [320, 240],\n    vga: [640, 480],\n    hd720p: [1280, 720]\n}\n\n/**\n * video parameter\n */\nconst videoSpec = {\n    /**\n     * The invalid constraint error in safari is because the browser expects that you pass a correct width, one of:\n     *   320\n     *   640\n     *   1280\n     *  the height is auto calculate in an aspect ratio of 4:3 for 320 or 640, and 16:9 for 1280, then if you pass a width of 320, you video stream is set in:\n     */\n    width: { min: '80', ideal: '640', max: '1920' },\n    height: { min: '60', ideal: '480', max: '1080' },\n    bitrate: {\n        min: 80,\n        max: 300,\n        ideal: 200\n    },\n    frameRate: { min: 2, ideal: 15, max: 30 },\n    aspectRatio: 4 / 3\n};\n\n/**\n * audio parameters.\n */\nconst audioSpec = {\n    sampleRate: {\n        min: 4000,\n        max: 48000,\n        ideal: 8000\n    },\n    channelCount: {\n        min: 1,\n        max: 2,\n        ideal: 1\n    }\n}\n\n//\n// {\n//\tstereo : 1, // 取值 1 / 0\n//\tmaxaveragebitrate : 24 * 1024, // 数值型\n//\tmaxplaybackrate   : 48000, // 数值型\n//\tcbr : 1, // 取值 1 / 0\n//\tuseinbandfec : 1, // 取值 1 / 0\n//\tusedtx : 1, // 取值 1 / 0\n//\tmaxptime : 20, // 最大打包时长\n// }\n// speech_low_quality | speech_standard | music_standard | standard_stereo | high_quality | high_quality_stereo\nconst audioProfileSpec = new Map([\n    ['speech_low_quality', {\n\t\tmaxplaybackrate : 16000,\n\t\tstereo : 0,\n\t\tmaxaveragebitrate : 24 * 1024\n\t}],\n    ['speech_standard', {\n\t\tmaxplaybackrate: 32000,\n\t\tstereo: 0,\n\t\tmaxaveragebitrate: 24 * 1024\n\t}],\n\t['music_standard', {\n\t\tmaxplaybackrate: 48000,\n\t\tstereo: 0,\n\t\tmaxaveragebitrate: 40 * 1024\n\t}],\n\t['standard_stereo', {\n\t\tmaxplaybackrate: 48000,\n\t\tstereo: 1,\n\t\tmaxaveragebitrate: 64 * 1024\n\t}],\n\t['high_quality', {\n\t\tmaxplaybackrate : 48000,\n\t\tstereo : 0,\n\t\tmaxaveragebitrate : 128 * 1024\n\t}],\n\t['high_quality_stereo', {\n\t\tmaxplaybackrate : 48000,\n\t\tstereo : 1,\n\t\tmaxaveragebitrate : 192 * 1024\n\t}]\n])\n\n\n/**\n * screen specification constraints.\n */\nconst screenSpec = {\n    's_frameRate': 15,\n    's_720p': {\n        maxWidth: 1280,\n        maxHeight: 720,\n        maxAspectRatio: 1.77\n    },\n    's_1080p': {\n        maxWidth: 1920,\n        maxHeight: 1080,\n        maxAspectRatio: 1.77\n    },\n    's_2k': {\n        maxWidth: 2048,\n        maxHeight: 1080,\n        maxAspectRatio: 1.77\n    },\n    's_4k': {\n        maxWidth: 3840,\n        maxHeight: 2160,\n        maxAspectRatio: 1.77\n    },\n    's_8k': {\n        maxWidth: 7680,\n        maxHeight: 4320,\n        maxAspectRatio: 1.77\n    }\n}\n\n/**\n * log server url.\n * @type {string}\n */\nconst logserver_url = 'https://log4websdk.3ttech.cn/webSdk/putInfo';\n\n/**\n * The authorization server address. server support JSONP callback.\n * @type {string}\n * 废弃\n */\nconst auth_url = 'https://apiusercenter.3ttech.cn/authority.php';\n\n/**\n * ip location address.\n * @type {string}\n */\nconst iplocationAddress = 'webdispatch.3ttech.cn';\n\nconst iplocationPort = 443;\n\n/**\n * control server address.\n * @type {string}\n */\nconst mediaServerAddress = ''; //'webdispatch.3ttech.cn';\n\n/**\n * private deployment flag ---- (true: will'd not access internet).\n * @type {Boolean}\n */\nconst privateNet = false;\n\n/**\n * log to server flag\n */\nconst log2Server = true;\n\n/**\n * \tstat2Server\n */\nconst stat2Server = true;\n\nmodule.exports = {\n    clientConfig: clientConfig,\n    logLevel: logLevel,\n\tauthUrl: auth_url,\n\taudioProfileSpec: audioProfileSpec,\n    videoProfile: videoProfile,\n    audioSpec: audioSpec,\n    videoSpec: videoSpec,\n    mediaServerAddress: mediaServerAddress,\n    logserver_url: logserver_url,\n\tiplocationAddress: iplocationAddress,\n\tiplocationPort: iplocationPort,\n    videoResolution: videoResolution,\n    screenResolution: screenResolution,\n    videoAttributes: videoAttributes,\n    protoo_peer_RETRY_OPTIONS: protoo_peer_RETRY_OPTIONS,\n\tstat2Server: stat2Server,\n\tprivateNet: privateNet,\n\tlog2Server: log2Server,\n    screenSpec: screenSpec\n};\n\n\n//# sourceURL=webpack:///./lib/config.js?");

/***/ }),

/***/ "./lib/getStats.js":
/*!*************************!*\
  !*** ./lib/getStats.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n// Last time updated: 2019-02-20 3:31:29 PM UTC\n\n// _______________\n// getStats v1.2.0\n\n// Open-Sourced: https://github.com/muaz-khan/getStats\n\n// --------------------------------------------------\n// Muaz Khan     - www.MuazKhan.com\n// MIT License   - www.WebRTC-Experiment.com/licence\n// --------------------------------------------------\n\nvar getStats = function (mediaStreamTrack, callback, interval)\n{\n\n\tvar browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';\n\n\t(function (that)\n\t{\n\t\tif (!that)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof window !== 'undefined')\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof global === 'undefined')\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tglobal.navigator = {\n\t\t\tuserAgent: browserFakeUserAgent,\n\t\t\tgetUserMedia: function () { }\n\t\t};\n\n\t\tif (!global.console)\n\t\t{\n\t\t\tglobal.console = {};\n\t\t}\n\n\t\tif (typeof global.console.log === 'undefined' || typeof global.console.error === 'undefined')\n\t\t{\n\t\t\tglobal.console.error = global.console.log = global.console.log || function ()\n\t\t\t{\n\t\t\t\tconsole.log(arguments);\n\t\t\t};\n\t\t}\n\n\t\tif (typeof document === 'undefined')\n\t\t{\n\t\t\t/*global document:true */\n\t\t\tthat.document = {\n\t\t\t\tdocumentElement: {\n\t\t\t\t\tappendChild: function ()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tdocument.createElement = document.captureStream = document.mozCaptureStream = function ()\n\t\t\t{\n\t\t\t\tvar obj = {\n\t\t\t\t\tgetContext: function ()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t},\n\t\t\t\t\tplay: function () { },\n\t\t\t\t\tpause: function () { },\n\t\t\t\t\tdrawImage: function () { },\n\t\t\t\t\ttoDataURL: function ()\n\t\t\t\t\t{\n\t\t\t\t\t\treturn '';\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treturn obj;\n\t\t\t};\n\n\t\t\tthat.HTMLVideoElement = function () { };\n\t\t}\n\n\t\tif (typeof location === 'undefined')\n\t\t{\n\t\t\t/*global location:true */\n\t\t\tthat.location = {\n\t\t\t\tprotocol: 'file:',\n\t\t\t\thref: '',\n\t\t\t\thash: ''\n\t\t\t};\n\t\t}\n\n\t\tif (typeof screen === 'undefined')\n\t\t{\n\t\t\t/*global screen:true */\n\t\t\tthat.screen = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t}\n\n\t\tif (typeof URL === 'undefined')\n\t\t{\n\t\t\t/*global screen:true */\n\t\t\tthat.URL = {\n\t\t\t\tcreateObjectURL: function ()\n\t\t\t\t{\n\t\t\t\t\treturn '';\n\t\t\t\t},\n\t\t\t\trevokeObjectURL: function ()\n\t\t\t\t{\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tif (typeof MediaStreamTrack === 'undefined')\n\t\t{\n\t\t\t/*global screen:true */\n\t\t\tthat.MediaStreamTrack = function () { };\n\t\t}\n\n\t\tif (typeof RTCPeerConnection === 'undefined')\n\t\t{\n\t\t\t/*global screen:true */\n\t\t\tthat.RTCPeerConnection = function () { };\n\t\t}\n\n\t\t/*global window:true */\n\t\tthat.window = global;\n\t})(typeof global !== 'undefined' ? global : null);\n\n\tvar RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;\n\n\tif (typeof MediaStreamTrack === 'undefined')\n\t{\n\t\tMediaStreamTrack = {}; // todo?\n\t}\n\n\tvar systemNetworkType = ((navigator.connection || {}).type || 'unknown').toString().toLowerCase();\n\n\tvar getStatsResult = {\n\t\tisSafari: false,\n\t\tencryption: 'sha-256',\n\t\taudio: {\n\t\t\tssrc: [],\n\t\t\tbytesSent: 0,\n\t\t\tbytesReceived: 0,\n\t\t\tlatency: 0,\n\t\t\tpacketsLost: 0\n\t\t},\n\t\tvideo: {\n\t\t\tssrc: [],\n\t\t\tbytesSent: 0,\n\t\t\tbytesReceived: 0,\n\t\t\tlatency: 0,\n\t\t\tpacketsLost: 0\n\t\t},\n\t\tbandwidth: {\n\t\t\tsystemBandwidth: 0,\n\t\t\tsentPerSecond: 0,\n\t\t\tencodedPerSecond: 0,\n\t\t\thelper: {\n\t\t\t\taudioBytesSent: 0,\n\t\t\t\tvideoBytesSent: 0\n\t\t\t},\n\t\t\tupSpeed: 0,\n\t\t\trtt: 0\n\t\t},\n\t\tresults: {},\n\t\tconnectionType: {\n\t\t\tsystemNetworkType: systemNetworkType,\n\t\t\tsystemIpAddress: '192.168.1.2',\n\t\t\tlocal: {\n\t\t\t\tcandidateType: [],\n\t\t\t\ttransport: [],\n\t\t\t\tipAddress: [],\n\t\t\t\tnetworkType: []\n\t\t\t},\n\t\t\tremote: {\n\t\t\t\tcandidateType: [],\n\t\t\t\ttransport: [],\n\t\t\t\tipAddress: [],\n\t\t\t\tnetworkType: []\n\t\t\t}\n\t\t},\n\t\tresolutions: {\n\t\t\tsend: {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t},\n\t\t\trecv: {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t}\n\t\t},\n\t\tinternal: {\n\t\t\taudio: {},\n\t\t\tvideo: {},\n\t\t\tcandidates: {}\n\t\t},\n\t\tnomore: function ()\n\t\t{\n\t\t\tnomore = true;\n\t\t}\n\t};\n\n\tvar getStatsParser = {\n\t\tcheckIfOfferer: function (result)\n\t\t{\n\t\t\tif (result.type === 'googLibjingleSession')\n\t\t\t{\n\t\t\t\tgetStatsResult.isOfferer = result.googInitiator;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n\t// \n\tgetStatsResult.isSafari = isSafari;\n\n\tvar peer = this;\n\n\tif (!(arguments[0] instanceof RTCPeerConnection))\n\t{\n\t\tthrow '1st argument is not instance of RTCPeerConnection.';\n\t}\n\n\tpeer = arguments[0];\n\n\tif (arguments[1] instanceof MediaStreamTrack)\n\t{\n\t\tmediaStreamTrack = arguments[1]; // redundant on non-safari\n\t\tcallback = arguments[2];\n\t\tinterval = arguments[3];\n\t}\n\n\t// \n\tif (+interval < 1000)\n\t{\n\t\tinterval = 1000;\n\t}\n\n\tvar nomore = false;\n\n\tfunction getStatsLooper()\n\t{\n\t\tgetStatsWrapper(function (results)\n\t\t{\n\t\t\tif (!results || !results.forEach)\n\t\t\t\treturn;\n\n\t\t\t// dump\n\t\t\t// console.log(`<WEBRTC-STAT> ${JSON.stringify(results)}`);\n\n\t\t\tif (isSafari)\n\t\t\t\treturn;\n\t\t\tresults.forEach(function (result)\n\t\t\t{\n\t\t\t\t// console.error('result', result);\n\t\t\t\tObject.keys(getStatsParser).forEach(function (key)\n\t\t\t\t{\n\t\t\t\t\tif (typeof getStatsParser[key] === 'function')\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgetStatsParser[key](result);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconsole.error(e.message, e.stack, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (peer.iceConnectionState.search(/failed|closed|disconnected/gi) !== -1)\n\t\t\t\t{\n\t\t\t\t\tnomore = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\tnomore = true;\n\t\t\t}\n\n\t\t\tif (nomore === true)\n\t\t\t{\n\t\t\t\tif (getStatsResult.datachannel)\n\t\t\t\t{\n\t\t\t\t\tgetStatsResult.datachannel.state = 'close';\n\t\t\t\t}\n\t\t\t\tgetStatsResult.ended = true;\n\t\t\t}\n\n\t\t\t// allow users to access native results\n\t\t\tgetStatsResult.results = results;\n\n\t\t\t// \n\t\t\tgetStatsResult.audio.ssrc.forEach((ssrc) =>\n\t\t\t{\n\t\t\t\t// TODO : \n\t\t\t});\n\n\t\t\t// \n\t\t\tgetStatsResult.video.ssrc.forEach((ssrc) =>\n\t\t\t{\n\t\t\t\t// TODO : \n\t\t\t});\n\n\t\t\t// \n\t\t\tif (getStatsResult.audio && getStatsResult.video)\n\t\t\t{\n\t\t\t\tgetStatsResult.bandwidth.upSpeed = (getStatsResult.audio.bytesSent - getStatsResult.bandwidth.helper.audioBytesSent) + (getStatsResult.video.bytesSent - getStatsResult.bandwidth.helper.videoBytesSent);\n\t\t\t\tgetStatsResult.bandwidth.upSpeed = (getStatsResult.bandwidth.upSpeed * 1000) / interval;\n\t\t\t\tgetStatsResult.bandwidth.helper.audioBytesSent = getStatsResult.audio.bytesSent;\n\t\t\t\tgetStatsResult.bandwidth.helper.videoBytesSent = getStatsResult.video.bytesSent;\n\t\t\t}\n\n\t\t\t// console.log(`<WEBRTC-STAT-RES> ${JSON.stringify(getStatsResult)}`)\n\n\t\t\tcallback(getStatsResult);\n\n\t\t\t// second argument checks to see, if target-user is still connected.\n\t\t\tif (!nomore)\n\t\t\t{\n\t\t\t\ttypeof interval != undefined && interval && setTimeout(getStatsLooper, interval || 1000);\n\t\t\t}\n\t\t});\n\t}\n\n\t// a wrapper around getStats which hides the differences (where possible)\n\t// following code-snippet is taken from somewhere on the github\n\tfunction getStatsWrapper(cb)\n\t{\n\t\t// if !peer or peer.signalingState == 'closed' then return;\n\n\t\tif (typeof window.InstallTrigger !== 'undefined' || isSafari)\n\t\t{ // maybe \"isEdge?\"\n\t\t\tpeer.getStats(window.mediaStreamTrack || null).then(function (res)\n\t\t\t{\n\t\t\t\tvar items = [];\n\t\t\t\tres.forEach(function (r)\n\t\t\t\t{\n\t\t\t\t\titems.push(r);\n\t\t\t\t});\n\t\t\t\tcb(items);\n\t\t\t}).catch(cb);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpeer.getStats(function (res)\n\t\t\t{\n\t\t\t\tvar items = [];\n\t\t\t\tres.result().forEach(function (res)\n\t\t\t\t{\n\t\t\t\t\tvar item = {};\n\t\t\t\t\tres.names().forEach(function (name)\n\t\t\t\t\t{\n\t\t\t\t\t\titem[name] = res.stat(name);\n\t\t\t\t\t});\n\t\t\t\t\titem.id = res.id;\n\t\t\t\t\titem.type = res.type;\n\t\t\t\t\titem.timestamp = res.timestamp;\n\t\t\t\t\titems.push(item);\n\t\t\t\t});\n\t\t\t\tcb(items);\n\t\t\t});\n\t\t}\n\t};\n\n\tgetStatsParser.datachannel = function (result)\n\t{\n\t\tif (result.type !== 'datachannel') return;\n\n\t\tgetStatsResult.datachannel = {\n\t\t\tstate: result.state // open or connecting\n\t\t}\n\t};\n\n\tgetStatsParser.googCertificate = function (result)\n\t{\n\t\tif (result.type == 'googCertificate')\n\t\t{\n\t\t\tgetStatsResult.encryption = result.googFingerprintAlgorithm;\n\t\t}\n\n\t\t// Safari-11 or higher\n\t\tif (result.type == 'certificate')\n\t\t{\n\t\t\t// todo: is it possible to have different encryption methods for senders and receivers?\n\t\t\t// if yes, then we need to set:\n\t\t\t//    getStatsResult.encryption.local = value;\n\t\t\t//    getStatsResult.encryption.remote = value;\n\t\t\tgetStatsResult.encryption = result.fingerprintAlgorithm;\n\t\t}\n\t};\n\n\t// \n\tgetStatsParser.checkAudioTracks = function (result)\n\t{\n\t\tif (result.type !== 'ssrc')\n\t\t\treturn;\n\t\tif (result.mediaType !== 'audio')\n\t\t\treturn;\n\n\t\tvar ssrc = result.ssrc;\n\n\t\tvar sendrecvType = result.id.split('_').pop();\n\t\tif (result.isRemote === true)\n\t\t{\n\t\t\tsendrecvType = 'recv';\n\t\t}\n\t\tif (result.isRemote === false)\n\t\t{\n\t\t\tsendrecvType = 'send';\n\t\t}\n\n\t\tif (!sendrecvType) return;\n\n\t\t// 将 ssrc 记录下来\n\t\tif (getStatsResult.audio.ssrc.indexOf(ssrc) === -1)\n\t\t{\n\t\t\tgetStatsResult.audio.ssrc.push(ssrc);\n\t\t}\n\n\t\t// \n\t\tif (!getStatsResult.audio[ssrc])\n\t\t{\n\t\t\tgetStatsResult.audio[ssrc] = {};\n\t\t\tgetStatsResult.audio[ssrc][sendrecvType] = {};\n\t\t\tgetStatsResult.audio[ssrc][sendrecvType].codecs = [];\n\t\t\tgetStatsResult.audio[ssrc][sendrecvType].tracks = [];\n\t\t}\n\n\t\tif (getStatsResult.audio[ssrc][sendrecvType].codecs.indexOf(result.googCodecName || 'opus') === -1)\n\t\t{\n\t\t\tgetStatsResult.audio[ssrc][sendrecvType].codecs.push(result.googCodecName || 'opus');\n\t\t}\n\n\t\t// \n\t\tif (!getStatsResult.internal.audio[ssrc])\n\t\t{\n\t\t\tgetStatsResult.internal.audio[ssrc] = {};\n\t\t}\n\n\t\t//\n\t\tif (!getStatsResult.internal.audio[ssrc][sendrecvType])\n\t\t{\n\t\t\tgetStatsResult.internal.audio[ssrc][sendrecvType] = {};\n\t\t}\n\n\t\t// \n\t\tif (!!result.bytesSent)\n\t\t{\n\t\t\tif (!getStatsResult.internal.audio[ssrc][sendrecvType].prevBytesSent)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.audio[ssrc][sendrecvType].prevBytesSent = 0;//result.bytesSent;\n\t\t\t}\n\n\t\t\tvar bytes = result.bytesSent - getStatsResult.internal.audio[ssrc][sendrecvType].prevBytesSent;\n\t\t\tgetStatsResult.internal.audio[ssrc][sendrecvType].prevBytesSent = result.bytesSent;\n\n\t\t\tvar kilobytes = (bytes * 8 / 1024); // to kbps\n\t\t\tgetStatsResult.audio[ssrc][sendrecvType].availableBandwidth = parseInt(kilobytes, 10);\n\t\t\tgetStatsResult.audio[ssrc].bytesSent = parseInt(kilobytes, 10);\n\t\t}\n\n\t\tif (!!result.bytesReceived)\n\t\t{\n\t\t\tif (!getStatsResult.internal.audio[ssrc][sendrecvType].prevBytesReceived)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.audio[ssrc][sendrecvType].prevBytesReceived = 0;//result.bytesReceived;\n\t\t\t}\n\n\t\t\tvar bytes = result.bytesReceived - getStatsResult.internal.audio[ssrc][sendrecvType].prevBytesReceived;\n\t\t\tgetStatsResult.internal.audio[ssrc][sendrecvType].prevBytesReceived = result.bytesReceived;\n\n\t\t\tvar kilobytes = (bytes * 8 / 1024); // to kbps\n\n\t\t\t// getStatsResult.audio[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\tgetStatsResult.audio[ssrc].bytesReceived = parseInt(kilobytes, 10);\n\t\t}\n\n\t\tif (result.googTrackId && getStatsResult.audio[ssrc][sendrecvType].tracks.indexOf(result.googTrackId) === -1)\n\t\t{\n\t\t\tgetStatsResult.audio[ssrc][sendrecvType].tracks.push(result.googTrackId);\n\t\t}\n\n\t\t// calculate latency\n\t\tif (!!result.googCurrentDelayMs)\n\t\t{\n\t\t\tgetStatsResult.internal.audio[ssrc].googCurrentDelayMs = result.googCurrentDelayMs;\n\n\t\t\tgetStatsResult.audio[ssrc].latency = parseInt(result.googCurrentDelayMs, 10);\n\n\t\t\tif (getStatsResult.audio[ssrc].latency < 0)\n\t\t\t{\n\t\t\t\tgetStatsResult.audio[ssrc].latency = 0;\n\t\t\t}\n\t\t}\n\n\t\t// \n\t\tif (!!result.packetsReceived)\n\t\t{\n\t\t\tif (!getStatsResult.internal.audio[ssrc].prevPacketsReceived)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.audio[ssrc].prevPacketsReceived = 0;\n\t\t\t}\n\n\t\t\tvar pkts = result.packetsReceived - getStatsResult.internal.audio[ssrc].prevPacketsReceived;\n\t\t\tgetStatsResult.internal.audio[ssrc].prevPacketsReceived = result.packetsReceived;\n\n\t\t\tgetStatsResult.audio[ssrc].packetsReceived = parseInt(pkts, 10);\n\n\t\t\tif (getStatsResult.audio[ssrc].packetsReceived < 0)\n\t\t\t{\n\t\t\t\tgetStatsResult.audio[ssrc].packetsReceived = 0;\n\t\t\t}\n\t\t}\n\n\t\t// \n\t\tif (!!result.packetsSent)\n\t\t{\n\t\t\tif (!getStatsResult.internal.audio[ssrc].prevPacketsSent)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.audio[ssrc].prevPacketsSent = 0;\n\t\t\t}\n\n\t\t\tvar pkts = result.packetsSent - getStatsResult.internal.audio[ssrc].prevPacketsSent;\n\t\t\tgetStatsResult.internal.audio[ssrc].prevPacketsSent = result.packetsSent;\n\n\t\t\tgetStatsResult.audio[ssrc].packetsSent = parseInt(pkts, 10);\n\n\t\t\tif (getStatsResult.audio[ssrc].packetsSent < 0)\n\t\t\t{\n\t\t\t\tgetStatsResult.audio[ssrc].packetsSent = 0;\n\t\t\t}\n\t\t}\n\n\t\t// calculate packetsLost\n\t\tif (!!result.packetsLost)\n\t\t{\n\t\t\tif (!getStatsResult.internal.audio[ssrc].prevPacketsLost)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.audio[ssrc].prevPacketsLost = 0;//result.packetsLost;\n\t\t\t}\n\n\t\t\tvar lost = result.packetsLost - getStatsResult.internal.audio[ssrc].prevPacketsLost;\n\t\t\tgetStatsResult.internal.audio[ssrc].prevPacketsLost = result.packetsLost;\n\n\t\t\tgetStatsResult.audio[ssrc].packetsLost = parseInt(lost, 10);\n\n\t\t\tif (getStatsResult.audio[ssrc].packetsLost < 0)\n\t\t\t{\n\t\t\t\tgetStatsResult.audio[ssrc].packetsLost = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\tgetStatsParser.checkVideoTracks = function (result)\n\t{\n\t\tif (result.type !== 'ssrc') return;\n\t\tif (result.mediaType !== 'video') return;\n\n\t\tvar ssrc = result.ssrc;\n\n\t\tvar sendrecvType = result.id.split('_').pop();\n\t\tif (result.isRemote === true)\n\t\t{\n\t\t\tsendrecvType = 'recv';\n\t\t}\n\t\tif (result.isRemote === false)\n\t\t{\n\t\t\tsendrecvType = 'send';\n\t\t}\n\n\t\tif (!sendrecvType) return;\n\n\t\t// 将 ssrc 记录下来\n\t\tif (getStatsResult.video.ssrc.indexOf(ssrc) === -1)\n\t\t{\n\t\t\tgetStatsResult.video.ssrc.push(ssrc);\n\t\t}\n\n\t\t// \n\t\tif (!getStatsResult.video[ssrc])\n\t\t{\n\t\t\tgetStatsResult.video[ssrc] = {};\n\t\t\tgetStatsResult.video[ssrc][sendrecvType] = {};\n\t\t\tgetStatsResult.video[ssrc][sendrecvType].codecs = [];\n\t\t\tgetStatsResult.video[ssrc][sendrecvType].tracks = [];\n\t\t}\n\n\t\tif (getStatsResult.video[ssrc][sendrecvType].codecs.indexOf(result.googCodecName || 'VP8') === -1)\n\t\t{\n\t\t\tgetStatsResult.video[ssrc][sendrecvType].codecs.push(result.googCodecName || 'VP8');\n\t\t}\n\n\t\t// \n\t\tif (!getStatsResult.internal.video[ssrc])\n\t\t{\n\t\t\tgetStatsResult.internal.video[ssrc] = {};\n\t\t\tgetStatsResult.internal.video[ssrc][sendrecvType] = {};\n\t\t}\n\n\t\t//\n\t\tif (!getStatsResult.internal.video[ssrc][sendrecvType])\n\t\t{\n\t\t\tgetStatsResult.internal.video[ssrc][sendrecvType] = {};\n\t\t}\n\n\t\tif (!!result.bytesSent)\n\t\t{\n\t\t\tif (!getStatsResult.internal.video[ssrc][sendrecvType].prevBytesSent)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.video[ssrc][sendrecvType].prevBytesSent = 0;//result.bytesSent;\n\t\t\t}\n\n\t\t\tvar bytes = result.bytesSent - getStatsResult.internal.video[ssrc][sendrecvType].prevBytesSent;\n\t\t\tgetStatsResult.internal.video[ssrc][sendrecvType].prevBytesSent = result.bytesSent;\n\n\t\t\tvar kilobytes = (bytes * 8 / 1024); // to kbps\n\n\t\t\tgetStatsResult.video[ssrc][sendrecvType].availableBandwidth = parseInt(kilobytes, 10);\n\t\t\tgetStatsResult.video[ssrc].bytesSent = parseInt(kilobytes, 10);\n\t\t}\n\n\t\tif (!!result.bytesReceived)\n\t\t{\n\t\t\tif (!getStatsResult.internal.video[ssrc][sendrecvType].prevBytesReceived)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.video[ssrc][sendrecvType].prevBytesReceived = 0;//result.bytesReceived;\n\t\t\t}\n\n\t\t\tvar bytes = result.bytesReceived - getStatsResult.internal.video[ssrc][sendrecvType].prevBytesReceived;\n\t\t\tgetStatsResult.internal.video[ssrc][sendrecvType].prevBytesReceived = result.bytesReceived;\n\n\t\t\tvar kilobytes = (bytes * 8 / 1024); // to kbps\n\t\t\t// getStatsResult.video[ssrc][sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\tgetStatsResult.video[ssrc].bytesReceived = parseInt(kilobytes, 10);\n\t\t}\n\n\t\t/*\n        if (result.googFrameHeightReceived && result.googFrameWidthReceived) {\n            getStatsResult.video[ssrc][sendrecvType].resolutions.width = result.googFrameWidthReceived;\n            getStatsResult.video[ssrc][sendrecvType].resolutions.height = result.googFrameHeightReceived;\n        }\n\n        if (result.googFrameHeightSent && result.googFrameWidthSent) {\n            getStatsResult.video[ssrc][sendrecvType].resolutions.width = result.googFrameWidthSent;\n            getStatsResult.video[ssrc][sendrecvType].resolutions.height = result.googFrameHeightSent;\n\t\t}\n\t\t*/\n\n\t\tif (result.googTrackId && getStatsResult.video[ssrc][sendrecvType].tracks.indexOf(result.googTrackId) === -1)\n\t\t{\n\t\t\tgetStatsResult.video[ssrc][sendrecvType].tracks.push(result.googTrackId);\n\t\t}\n\n\t\t// calculate latency\n\t\tif (!!result.googCurrentDelayMs)\n\t\t{\n\t\t\tgetStatsResult.internal.video[ssrc].googCurrentDelayMs = result.googCurrentDelayMs;\n\n\t\t\tgetStatsResult.video[ssrc].latency = parseInt(result.googCurrentDelayMs, 10);\n\n\t\t\tif (getStatsResult.video[ssrc].latency < 0)\n\t\t\t{\n\t\t\t\tgetStatsResult.video[ssrc].latency = 0;\n\t\t\t}\n\t\t}\n\n\t\t// \n\t\tif (!!result.packetsReceived)\n\t\t{\n\t\t\tif (!getStatsResult.internal.video[ssrc].prevPacketsReceived)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.video[ssrc].prevPacketsReceived = 0;\n\t\t\t}\n\n\t\t\tvar pkts = result.packetsReceived - getStatsResult.internal.video[ssrc].prevPacketsReceived;\n\t\t\tgetStatsResult.internal.video[ssrc].prevPacketsReceived = result.packetsReceived;\n\n\t\t\tgetStatsResult.video[ssrc].packetsReceived = parseInt(pkts, 10);\n\n\t\t\tif (getStatsResult.video[ssrc].packetsReceived < 0)\n\t\t\t{\n\t\t\t\tgetStatsResult.video[ssrc].packetsReceived = 0;\n\t\t\t}\n\t\t}\n\n\t\t// \n\t\tif (!!result.packetsSent)\n\t\t{\n\t\t\tif (!getStatsResult.internal.video[ssrc].prevPacketsSent)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.video[ssrc].prevPacketsSent = 0;\n\t\t\t}\n\n\t\t\tvar pkts = result.packetsSent - getStatsResult.internal.video[ssrc].prevPacketsSent;\n\t\t\tgetStatsResult.internal.video[ssrc].prevPacketsSent = result.packetsSent;\n\n\t\t\tgetStatsResult.video[ssrc].packetsSent = parseInt(pkts, 10);\n\n\t\t\tif (getStatsResult.video[ssrc].packetsSent < 0)\n\t\t\t{\n\t\t\t\tgetStatsResult.video[ssrc].packetsSent = 0;\n\t\t\t}\n\t\t}\n\n\t\t// calculate packetsLost\n\t\tif (!!result.packetsLost)\n\t\t{\n\t\t\tif (!getStatsResult.internal.video[ssrc].prevPacketsLost)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal.video[ssrc].prevPacketsLost = 0;//result.packetsLost;\n\t\t\t}\n\n\t\t\tvar lost = result.packetsLost - getStatsResult.internal.video[ssrc].prevPacketsLost;\n\t\t\tgetStatsResult.internal.video[ssrc].prevPacketsLost = result.packetsLost;\n\n\t\t\tgetStatsResult.video[ssrc].packetsLost = parseInt(lost, 10);\n\n\t\t\tif (getStatsResult.video[ssrc].packetsLost < 0)\n\t\t\t{\n\t\t\t\tgetStatsResult.video[ssrc].packetsLost = 0;\n\t\t\t}\n\t\t}\n\t};\n\n\tgetStatsParser.bweforvideo = function (result)\n\t{\n\t\tif (result.type !== 'VideoBwe')\n\t\t\treturn;\n\n\t\tgetStatsResult.bandwidth.availableSendBandwidth = result.googAvailableSendBandwidth;\n\n\t\tgetStatsResult.bandwidth.googActualEncBitrate = result.googActualEncBitrate;\n\t\tgetStatsResult.bandwidth.googAvailableSendBandwidth = result.googAvailableSendBandwidth;\n\t\tgetStatsResult.bandwidth.googAvailableReceiveBandwidth = result.googAvailableReceiveBandwidth;\n\t\tgetStatsResult.bandwidth.googRetransmitBitrate = result.googRetransmitBitrate;\n\t\tgetStatsResult.bandwidth.googTargetEncBitrate = result.googTargetEncBitrate;\n\t\tgetStatsResult.bandwidth.googBucketDelay = result.googBucketDelay;\n\t\tgetStatsResult.bandwidth.googTransmitBitrate = result.googTransmitBitrate;\n\t};\n\n\tgetStatsParser.candidatePair = function (result)\n\t{\n\t\tif (result.type !== 'googCandidatePair' && result.type !== 'candidate-pair' && result.type !== 'local-candidate' && result.type !== 'remote-candidate') return;\n\n\t\t// result.googActiveConnection means either STUN or TURN is used.\n\n\t\tif (result.googActiveConnection == 'true')\n\t\t{\n\t\t\t// id === 'Conn-audio-1-0'\n\t\t\t// localCandidateId, remoteCandidateId\n\n\t\t\tgetStatsResult.bandwidth.rtt = result.googRtt;\n\n\t\t\t// bytesSent, bytesReceived\n\n\t\t\tObject.keys(getStatsResult.internal.candidates).forEach(function (cid)\n\t\t\t{\n\t\t\t\tvar candidate = getStatsResult.internal.candidates[cid];\n\t\t\t\tif (candidate.ipAddress.indexOf(result.googLocalAddress) !== -1)\n\t\t\t\t{\n\t\t\t\t\tgetStatsResult.connectionType.local.candidateType = candidate.candidateType;\n\t\t\t\t\tgetStatsResult.connectionType.local.ipAddress = candidate.ipAddress;\n\t\t\t\t\tgetStatsResult.connectionType.local.networkType = candidate.networkType;\n\t\t\t\t\tgetStatsResult.connectionType.local.transport = candidate.transport;\n\t\t\t\t}\n\t\t\t\tif (candidate.ipAddress.indexOf(result.googRemoteAddress) !== -1)\n\t\t\t\t{\n\t\t\t\t\tgetStatsResult.connectionType.remote.candidateType = candidate.candidateType;\n\t\t\t\t\tgetStatsResult.connectionType.remote.ipAddress = candidate.ipAddress;\n\t\t\t\t\tgetStatsResult.connectionType.remote.networkType = candidate.networkType;\n\t\t\t\t\tgetStatsResult.connectionType.remote.transport = candidate.transport;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tgetStatsResult.connectionType.transport = result.googTransportType;\n\n\t\t\tvar localCandidate = getStatsResult.internal.candidates[result.localCandidateId];\n\t\t\tif (localCandidate)\n\t\t\t{\n\t\t\t\tif (localCandidate.ipAddress)\n\t\t\t\t{\n\t\t\t\t\tgetStatsResult.connectionType.systemIpAddress = localCandidate.ipAddress;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar remoteCandidate = getStatsResult.internal.candidates[result.remoteCandidateId];\n\t\t\tif (remoteCandidate)\n\t\t\t{\n\t\t\t\tif (remoteCandidate.ipAddress)\n\t\t\t\t{\n\t\t\t\t\tgetStatsResult.connectionType.systemIpAddress = remoteCandidate.ipAddress;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (result.type === 'candidate-pair')\n\t\t{\n\t\t\tif (result.selected === true && result.nominated === true && result.state === 'succeeded')\n\t\t\t{\n\t\t\t\t// remoteCandidateId, localCandidateId, componentId\n\t\t\t\tvar localCandidate = getStatsResult.internal.candidates[result.remoteCandidateId];\n\t\t\t\tvar remoteCandidate = getStatsResult.internal.candidates[result.remoteCandidateId];\n\n\t\t\t\t// Firefox used above two pairs for connection\n\t\t\t}\n\t\t}\n\n\t\tif (result.type === 'local-candidate')\n\t\t{\n\t\t\tgetStatsResult.connectionType.local.candidateType = result.candidateType;\n\t\t\tgetStatsResult.connectionType.local.ipAddress = result.ipAddress;\n\t\t\tgetStatsResult.connectionType.local.networkType = result.networkType;\n\t\t\tgetStatsResult.connectionType.local.transport = result.mozLocalTransport || result.transport;\n\t\t}\n\n\t\tif (result.type === 'remote-candidate')\n\t\t{\n\t\t\tgetStatsResult.connectionType.remote.candidateType = result.candidateType;\n\t\t\tgetStatsResult.connectionType.remote.ipAddress = result.ipAddress;\n\t\t\tgetStatsResult.connectionType.remote.networkType = result.networkType;\n\t\t\tgetStatsResult.connectionType.remote.transport = result.mozRemoteTransport || result.transport;\n\t\t}\n\n\t\t/*\n\t\t// TODO : \n\t\tif (isSafari)\n\t\t{\n\t\t\t// result.remoteCandidateId\n\t\t\t// todo: below line will always force \"send\" on Safari; find a solution\n\t\t\tvar sendrecvType = result.localCandidateId ? 'send' : 'recv';\n\n\t\t\tif (!sendrecvType) return;\n\n\t\t\tif (!!result.bytesSent)\n\t\t\t{\n\t\t\t\tvar kilobytes = 0;\n\t\t\t\tif (!getStatsResult.internal.video[sendrecvType].prevBytesSent)\n\t\t\t\t{\n\t\t\t\t\tgetStatsResult.internal.video[sendrecvType].prevBytesSent = 0;//result.bytesSent;\n\t\t\t\t}\n\n\t\t\t\tvar bytes = result.bytesSent - getStatsResult.internal.video[sendrecvType].prevBytesSent;\n\t\t\t\tgetStatsResult.internal.video[sendrecvType].prevBytesSent = result.bytesSent;\n\n\t\t\t\tkilobytes = (bytes * 8 / 1024); // to kbps\n\n\t\t\t\t// TODO : getStatsResult.video[ssrc]\n\t\t\t\tgetStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\t\tgetStatsResult.video.bytesSent = kilobytes.toFixed(1);\n\t\t\t}\n\n\t\t\tif (!!result.bytesReceived)\n\t\t\t{\n\t\t\t\tvar kilobytes = 0;\n\t\t\t\tif (!getStatsResult.internal.video[sendrecvType].prevBytesReceived)\n\t\t\t\t{\n\t\t\t\t\tgetStatsResult.internal.video[sendrecvType].prevBytesReceived = 0;//result.bytesReceived;\n\t\t\t\t}\n\n\t\t\t\tvar bytes = result.bytesReceived - getStatsResult.internal.video[sendrecvType].prevBytesReceived;\n\t\t\t\tgetStatsResult.internal.video[sendrecvType].prevBytesReceived = result.bytesReceived;\n\n\t\t\t\tkilobytes = (bytes * 8 / 1024); // to kbps\n\n\t\t\t\t// TODO : getStatsResult.video[ssrc]\n\t\t\t\t// getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\t\tgetStatsResult.video.bytesReceived = kilobytes.toFixed(1);\n\t\t\t}\n\n\t\t\tif (!!result.availableOutgoingBitrate)\n\t\t\t{\n\t\t\t\tvar kilobytes = 0;\n\t\t\t\tif (!getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate)\n\t\t\t\t{\n\t\t\t\t\tgetStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate = 0;//result.availableOutgoingBitrate;\n\t\t\t\t}\n\n\t\t\t\tvar bytes = result.availableOutgoingBitrate - getStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate;\n\t\t\t\tgetStatsResult.internal.video[sendrecvType].prevAvailableOutgoingBitrate = result.availableOutgoingBitrate;\n\n\t\t\t\tkilobytes = (bytes * 8 / 1024); // to kbps\n\n\t\t\t\t// TODO : getStatsResult.video[ssrc]\n\t\t\t\t// getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\t\tgetStatsResult.video.availableOutgoingBitrate = kilobytes.toFixed(1);\n\t\t\t}\n\n\t\t\tif (!!result.availableIncomingBitrate)\n\t\t\t{\n\t\t\t\tvar kilobytes = 0;\n\t\t\t\tif (!getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate)\n\t\t\t\t{\n\t\t\t\t\tgetStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate = 0;//result.availableIncomingBitrate;\n\t\t\t\t}\n\n\t\t\t\tvar bytes = result.availableIncomingBitrate - getStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate;\n\t\t\t\tgetStatsResult.internal.video[sendrecvType].prevAvailableIncomingBitrate = result.availableIncomingBitrate;\n\n\t\t\t\tkilobytes = (bytes * 8 / 1024); // to kbps\n\n\t\t\t\t// TODO : getStatsResult.video[ssrc]\n\t\t\t\t// getStatsResult.video[sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\t\tgetStatsResult.video.availableIncomingBitrate = kilobytes.toFixed(1);\n\t\t\t}\n\t\t}\n\t\t*/\n\t};\n\n\tvar LOCAL_candidateType = {};\n\tvar LOCAL_transport = {};\n\tvar LOCAL_ipAddress = {};\n\tvar LOCAL_networkType = {};\n\n\tgetStatsParser.localcandidate = function (result)\n\t{\n\t\tif (result.type !== 'localcandidate' && result.type !== 'local-candidate')\n\t\t\treturn;\n\t\tif (!result.id)\n\t\t\treturn;\n\n\t\tif (!LOCAL_candidateType[result.id])\n\t\t{\n\t\t\tLOCAL_candidateType[result.id] = [];\n\t\t}\n\n\t\tif (!LOCAL_transport[result.id])\n\t\t{\n\t\t\tLOCAL_transport[result.id] = [];\n\t\t}\n\n\t\tif (!LOCAL_ipAddress[result.id])\n\t\t{\n\t\t\tLOCAL_ipAddress[result.id] = [];\n\t\t}\n\n\t\tif (!LOCAL_networkType[result.id])\n\t\t{\n\t\t\tLOCAL_networkType[result.id] = [];\n\t\t}\n\n\t\tif (result.candidateType && LOCAL_candidateType[result.id].indexOf(result.candidateType) === -1)\n\t\t{\n\t\t\tLOCAL_candidateType[result.id].push(result.candidateType);\n\t\t}\n\n\t\tif (result.transport && LOCAL_transport[result.id].indexOf(result.transport) === -1)\n\t\t{\n\t\t\tLOCAL_transport[result.id].push(result.transport);\n\t\t}\n\n\t\tif (result.ipAddress && LOCAL_ipAddress[result.id].indexOf(result.ipAddress + ':' + result.portNumber) === -1)\n\t\t{\n\t\t\tLOCAL_ipAddress[result.id].push(result.ipAddress + ':' + result.portNumber);\n\t\t}\n\n\t\tif (result.networkType && LOCAL_networkType[result.id].indexOf(result.networkType) === -1)\n\t\t{\n\t\t\tLOCAL_networkType[result.id].push(result.networkType);\n\t\t}\n\n\t\tgetStatsResult.internal.candidates[result.id] = {\n\t\t\tcandidateType: LOCAL_candidateType[result.id],\n\t\t\tipAddress: LOCAL_ipAddress[result.id],\n\t\t\tportNumber: result.portNumber,\n\t\t\tnetworkType: LOCAL_networkType[result.id],\n\t\t\tpriority: result.priority,\n\t\t\ttransport: LOCAL_transport[result.id],\n\t\t\ttimestamp: result.timestamp,\n\t\t\tid: result.id,\n\t\t\ttype: result.type\n\t\t};\n\n\t\tgetStatsResult.connectionType.local.candidateType = LOCAL_candidateType[result.id];\n\t\tgetStatsResult.connectionType.local.ipAddress = LOCAL_ipAddress[result.id];\n\t\tgetStatsResult.connectionType.local.networkType = LOCAL_networkType[result.id];\n\t\tgetStatsResult.connectionType.local.transport = LOCAL_transport[result.id];\n\t};\n\n\tvar REMOTE_candidateType = {};\n\tvar REMOTE_transport = {};\n\tvar REMOTE_ipAddress = {};\n\tvar REMOTE_networkType = {};\n\n\tgetStatsParser.remotecandidate = function (result)\n\t{\n\t\tif (result.type !== 'remotecandidate' && result.type !== 'remote-candidate')\n\t\t\treturn;\n\t\tif (!result.id)\n\t\t\treturn;\n\n\t\tif (!REMOTE_candidateType[result.id])\n\t\t{\n\t\t\tREMOTE_candidateType[result.id] = [];\n\t\t}\n\n\t\tif (!REMOTE_transport[result.id])\n\t\t{\n\t\t\tREMOTE_transport[result.id] = [];\n\t\t}\n\n\t\tif (!REMOTE_ipAddress[result.id])\n\t\t{\n\t\t\tREMOTE_ipAddress[result.id] = [];\n\t\t}\n\n\t\tif (!REMOTE_networkType[result.id])\n\t\t{\n\t\t\tREMOTE_networkType[result.id] = [];\n\t\t}\n\n\t\tif (result.candidateType && REMOTE_candidateType[result.id].indexOf(result.candidateType) === -1)\n\t\t{\n\t\t\tREMOTE_candidateType[result.id].push(result.candidateType);\n\t\t}\n\n\t\tif (result.transport && REMOTE_transport[result.id].indexOf(result.transport) === -1)\n\t\t{\n\t\t\tREMOTE_transport[result.id].push(result.transport);\n\t\t}\n\n\t\tif (result.ipAddress && REMOTE_ipAddress[result.id].indexOf(result.ipAddress + ':' + result.portNumber) === -1)\n\t\t{\n\t\t\tREMOTE_ipAddress[result.id].push(result.ipAddress + ':' + result.portNumber);\n\t\t}\n\n\t\tif (result.networkType && REMOTE_networkType[result.id].indexOf(result.networkType) === -1)\n\t\t{\n\t\t\tREMOTE_networkType[result.id].push(result.networkType);\n\t\t}\n\n\t\tgetStatsResult.internal.candidates[result.id] = {\n\t\t\tcandidateType: REMOTE_candidateType[result.id],\n\t\t\tipAddress: REMOTE_ipAddress[result.id],\n\t\t\tportNumber: result.portNumber,\n\t\t\tnetworkType: REMOTE_networkType[result.id],\n\t\t\tpriority: result.priority,\n\t\t\ttransport: REMOTE_transport[result.id],\n\t\t\ttimestamp: result.timestamp,\n\t\t\tid: result.id,\n\t\t\ttype: result.type\n\t\t};\n\n\t\tgetStatsResult.connectionType.remote.candidateType = REMOTE_candidateType[result.id];\n\t\tgetStatsResult.connectionType.remote.ipAddress = REMOTE_ipAddress[result.id];\n\t\tgetStatsResult.connectionType.remote.networkType = REMOTE_networkType[result.id];\n\t\tgetStatsResult.connectionType.remote.transport = REMOTE_transport[result.id];\n\t};\n\n\tgetStatsParser.dataSentReceived = function (result)\n\t{\n\t\tif (!result.googCodecName || (result.mediaType !== 'video' && result.mediaType !== 'audio'))\n\t\t\treturn;\n\n\t\tif (!!result.bytesSent)\n\t\t{\n\t\t\tgetStatsResult[result.mediaType].bytesSent = parseInt(result.bytesSent);\n\t\t}\n\n\t\tif (!!result.bytesReceived)\n\t\t{\n\t\t\tgetStatsResult[result.mediaType].bytesReceived = parseInt(result.bytesReceived);\n\t\t}\n\t};\n\n\tgetStatsParser.inboundrtp = function (result)\n\t{\n\t\tif (!isSafari)\n\t\t\treturn;\n\t\tif (result.type !== 'inbound-rtp')\n\t\t\treturn;\n\n\t\tvar mediaType = result.mediaType || 'audio';\n\t\tvar sendrecvType = result.isRemote ? 'recv' : 'send';\n\n\t\tif (!sendrecvType)\n\t\t\treturn;\n\n\t\tvar ssrc = result.ssrc;\n\n\t\tif (!getStatsResult.internal[mediaType][ssrc])\n\t\t{\n\t\t\tgetStatsResult.internal[mediaType][ssrc] = {};\n\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType] = {};\n\t\t}\n\n\t\tif (!!result.bytesSent)\n\t\t{\n\t\t\tvar kilobytes = 0;\n\t\t\tif (!getStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesSent)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesSent = 0;//result.bytesSent;\n\t\t\t}\n\n\t\t\tvar bytes = result.bytesSent - getStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesSent;\n\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesSent = result.bytesSent;\n\n\t\t\tkilobytes = (bytes * 8 / 1024); // to kbps\n\n\t\t\tgetStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\tgetStatsResult[mediaType].bytesSent = kilobytes.toFixed(1);\n\t\t}\n\n\t\tif (!!result.bytesReceived)\n\t\t{\n\t\t\tvar kilobytes = 0;\n\t\t\tif (!getStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesReceived)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesReceived = 0;//result.bytesReceived;\n\t\t\t}\n\n\t\t\tvar bytes = result.bytesReceived - getStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesReceived;\n\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesReceived = result.bytesReceived;\n\n\t\t\tkilobytes = (bytes * 8 / 1024); // to kbps\n\t\t\t// getStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\tgetStatsResult[mediaType].bytesReceived = kilobytes.toFixed(1);\n\t\t}\n\t};\n\n\tgetStatsParser.outboundrtp = function (result)\n\t{\n\t\tif (!isSafari)\n\t\t\treturn;\n\t\tif (result.type !== 'outbound-rtp')\n\t\t\treturn;\n\n\t\tvar mediaType = result.mediaType || 'audio';\n\t\tvar sendrecvType = result.isRemote ? 'recv' : 'send';\n\n\t\tif (!sendrecvType)\n\t\t\treturn;\n\n\t\tvar ssrc = result.ssrc;\n\n\t\tif (!getStatsResult.internal[mediaType][ssrc])\n\t\t{\n\t\t\tgetStatsResult.internal[mediaType][ssrc] = {};\n\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType] = {};\n\t\t}\n\n\t\tif (!!result.bytesSent)\n\t\t{\n\t\t\tvar kilobytes = 0;\n\t\t\tif (!getStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesSent)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesSent = 0;//result.bytesSent;\n\t\t\t}\n\n\t\t\tvar bytes = result.bytesSent - getStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesSent;\n\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesSent = result.bytesSent;\n\n\t\t\tkilobytes = (bytes * 8 / 1024); // to kbps\n\n\t\t\tgetStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\tgetStatsResult[mediaType].bytesSent = kilobytes.toFixed(1);\n\t\t}\n\n\t\tif (!!result.bytesReceived)\n\t\t{\n\t\t\tvar kilobytes = 0;\n\t\t\tif (!getStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesReceived)\n\t\t\t{\n\t\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesReceived = 0;//result.bytesReceived;\n\t\t\t}\n\n\t\t\tvar bytes = result.bytesReceived - getStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesReceived;\n\t\t\tgetStatsResult.internal[mediaType][ssrc][sendrecvType].prevBytesReceived = result.bytesReceived;\n\n\t\t\tkilobytes = (bytes * 8 / 1024); // to kbps\n\t\t\t// getStatsResult[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);\n\t\t\tgetStatsResult[mediaType].bytesReceived = kilobytes.toFixed(1);\n\t\t}\n\t};\n\n\tgetStatsParser.track = function (result)\n\t{\n\t\tif (!isSafari)\n\t\t\treturn;\n\t\tif (result.type !== 'track')\n\t\t\treturn;\n\n\t\tvar sendrecvType = result.remoteSource === true ? 'send' : 'recv';\n\n\t\tif (result.frameWidth && result.frameHeight)\n\t\t{\n\t\t\tgetStatsResult.resolutions[sendrecvType].width = result.frameWidth;\n\t\t\tgetStatsResult.resolutions[sendrecvType].height = result.frameHeight;\n\t\t}\n\n\t\t// framesSent, framesReceived\n\t};\n\n\tvar SSRC = {\n\t\taudio: {\n\t\t\tsend: [],\n\t\t\trecv: []\n\t\t},\n\t\tvideo: {\n\t\t\tsend: [],\n\t\t\trecv: []\n\t\t}\n\t};\n\n\tgetStatsParser.ssrc = function (result)\n\t{\n\t\tif (!result.googCodecName || (result.mediaType !== 'video' && result.mediaType !== 'audio'))\n\t\t\treturn;\n\t\tif (result.type !== 'ssrc')\n\t\t\treturn;\n\t\tvar sendrecvType = result.id.split('_').pop();\n\n\t\tif (SSRC[result.mediaType][sendrecvType].indexOf(result.ssrc) === -1)\n\t\t{\n\t\t\tSSRC[result.mediaType][sendrecvType].push(result.ssrc)\n\t\t}\n\n\t\t// getStatsResult[result.mediaType][sendrecvType].streams = SSRC[result.mediaType][sendrecvType].length;\n\t};\n\n\tgetStatsLooper();\n\n};\n\nif (true /* && !!module.exports*/)\n{\n\tmodule.exports = getStats;\n}\n\nif (true)\n{\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function ()\n\t{\n\t\treturn getStats;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./lib/getStats.js?");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("window.TTTRtcWeb = __webpack_require__(/*! ./TTTRtcWeb */ \"./lib/TTTRtcWeb.js\");\n\n//# sourceURL=webpack:///./lib/index.js?");

/***/ }),

/***/ "./lib/logger.js":
/*!***********************!*\
  !*** ./lib/logger.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/* eslint-disable no-console */\nconst debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\nconst clogLevel = __webpack_require__(/*! ./config */ \"./lib/config.js\").logLevel;\nconst config = __webpack_require__(/*! ./config */ \"./lib/config.js\");\n\nconst APP_NAME = 'tttwebsdk';\nlet LOG_LEVEL = clogLevel.LOG_TRACE;\n\nclass Logger\n{\n\tconstructor(prefix)\n\t{\n\t\tthis._userAgent = navigator.userAgent;\n\t\tthis._isMobile = /mobile/i.test(this._userAgent);\n\n\t\t// \n\t\tif (prefix)\n\t\t{\n\t\t\tthis._prefix = `${APP_NAME} ${prefix}`;\n\t\t\tthis._debug = debug(`${APP_NAME}:${prefix}`);\n\t\t\tthis._warn = debug(`${APP_NAME}:WARN:${prefix}`);\n\t\t\tthis._error = debug(`${APP_NAME}:ERROR:${prefix}`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._prefix = `${APP_NAME}`;\n\t\t\tthis._debug = debug(APP_NAME);\n\t\t\tthis._warn = debug(`${APP_NAME}:WARN`);\n\t\t\tthis._error = debug(`${APP_NAME}:ERROR`);\n\t\t}\n\n\t\t/* eslint-disable no-console */\n\t\t// this._debug.log = console.info.bind(console);\n\t\t// this._warn.log = console.warn.bind(console);\n\t\t// this._error.log = console.error.bind(console);\n\t\tthis._debug = this._log_debug.bind(this);\n\t\tthis._warn = this._log_warn.bind(this);\n\t\tthis._error = this._log_error.bind(this);\n\t\t/* eslint-enable no-console */\n\n\t\tthis._setLoggerLevel = this.setLoggerLevel;\n\t}\n\n\tget debug()\n\t{\n\t\treturn this._debug;\n\t}\n\n\tget warn()\n\t{\n\t\treturn this._warn;\n\t}\n\n\tget error()\n\t{\n\t\treturn this._error;\n\t}\n\n\tstatic get logLevel()\n\t{\n\t\treturn LOG_LEVEL;\n\t}\n\n\tsetLoggerLevel(level)\n\t{\n\t\tLogger.logLevel = level;\n\t}\n\n\tstatic set logLevel(value)\n\t{\n\t\tswitch (value)\n\t\t{\n\t\t\tcase 'LOG_NONE':\n\t\t\t\tLOG_LEVEL = clogLevel.LOG_NONE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOG_ERROR':\n\t\t\t\tLOG_LEVEL = clogLevel.LOG_ERROR;\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOG_WARN':\n\t\t\t\tLOG_LEVEL = clogLevel.LOG_WARN;\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOG_INFO':\n\t\t\t\tLOG_LEVEL = clogLevel.LOG_INFO;\n\n\t\t\t\tbreak;\n\t\t\tcase 'LOG_DEBUG':\n\t\t\t\tLOG_LEVEL = clogLevel.LOG_DEBUG;\n\t\t\t\tbreak;\n\n\t\t\tcase 'LOG_TRACE':\n\t\t\t\tLOG_LEVEL = clogLevel.LOG_TRACE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow TypeError('parameter error. must be: LOG_NONE, LOG_ERROR, LOG_WARN, LOG_INFO, LOG_DEBUG, LOG_TRACE');\n\t\t}\n\t}\n\n\t_log_debug(...args)\n\t{\n\t\tif (Logger.logLevel <= clogLevel.LOG_INFO)\n\t\t{\n\t\t\tlet msg = `[${this._prefix}]`;\n\n\t\t\t[].slice.apply(args).forEach(element =>\n\t\t\t{\n\t\t\t\tif (typeof element === 'object')\n\t\t\t\t\tmsg += ' ' + JSON.stringify(element);\n\t\t\t\telse\n\t\t\t\t\tmsg += ' ' + element;\n\t\t\t});\n\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.log(msg);\n\t\t}\n\t\tthis._log(...args);\n\t}\n\n\t_log_error(...args)\n\t{\n\t\tif (Logger.logLevel <= clogLevel.LOG_ERROR)\n\t\t{\n\t\t\t// let msg = `${new Date()} -- [${this._prefix}]`;\n\t\t\tlet msg = `[${this._prefix}]`;\n\n\t\t\t[].slice.apply(args).forEach(element =>\n\t\t\t{\n\t\t\t\tif (typeof element === 'object')\n\t\t\t\t\tmsg += ' ' + JSON.stringify(element);\n\t\t\t\telse\n\t\t\t\t\tmsg += ' ' + element;\n\t\t\t});\n\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error(msg);\n\t\t}\n\n\t\tthis._log(...args);\n\t}\n\n\t_log_warn(...args)\n\t{\n\t\tif (Logger.logLevel <= clogLevel.LOG_WARN)\n\t\t{\n\t\t\t// let msg = `${new Date()} -- [${this._prefix}]`;\n\t\t\tlet msg = `[${this._prefix}]`;\n\n\t\t\t[].slice.apply(args).forEach(element =>\n\t\t\t{\n\t\t\t\tif (typeof element === 'object')\n\t\t\t\t\tmsg += ' ' + JSON.stringify(element);\n\t\t\t\telse\n\t\t\t\t\tmsg += ' ' + element;\n\t\t\t});\n\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.warn(msg);\n\t\t}\n\n\t\tthis._log(...args)\n\t}\n\n\t_log(...args)\n\t{\n\t\tif (!config.log2Server)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// eslint-disable-next-line no-undef\n\t\tlet dev = this._isMobile ? 'web_mobile' : 'web';\n\t\tlet msg = `appid=${global.g_appid}, roomid=${global.g_roomid}, userid=${global.g_userid} server=${global.g_server} dev=${dev} ua=${this._userAgent} time=${new Date()}`;\n\n\t\t[].slice.apply(args).forEach(element =>\n\t\t{\n\t\t\tif (typeof element === 'object')\n\t\t\t\tmsg += ' ' + JSON.stringify(element);\n\t\t\telse\n\t\t\t\tmsg += ' ' + element;\n\t\t});\n\n\t\tfetch('https://log.wushuangtech.com:15100',\n\t\t\t{\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tmode: \"cors\",\n\t\t\t\tcache: \"no-cache\",\n\t\t\t\theaders: {\n\t\t\t\t\t\"Content-Type\": \"text/plain; charset=utf-8\",\n\t\t\t\t\t// \"Content-Type\": \"application/json; charset=utf-8\",\n\t\t\t\t},\n\t\t\t\tredirect: \"follow\",\n\t\t\t\treferrer: \"no-referrer\",\n\t\t\t\tbody: `event=${this._prefix} ${msg}`,\n\t\t\t})\n\t\t\t// eslint-disable-next-line no-console\n\t\t\t.catch(error => console.warn('Error:', error))\n\t\t\t.then(response =>\n\t\t\t{\n\t\t\t\treturn JSON.stringify(response);\n\t\t\t});\n\t}\n}\n\nmodule.exports = Logger;\nmodule.exports = function (prefix)\n{\n\treturn new Logger(prefix);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./lib/logger.js?");

/***/ }),

/***/ "./lib/mslib/CommandQueue.js":
/*!***********************************!*\
  !*** ./lib/mslib/CommandQueue.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CommandQueue; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./lib/mslib/errors.js\");\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('CommandQueue');\n\nclass CommandQueue extends events__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter\"]\n{\n\tconstructor()\n\t{\n\t\tsuper();\n\t\tthis.setMaxListeners(Infinity);\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// Busy running a command.\n\t\t// @type {Boolean}\n\t\tthis._busy = false;\n\n\t\t// Queue for pending commands. Each command is an Object with method,\n\t\t// resolve, reject, and other members (depending the case).\n\t\t// @type {Array<Object>}\n\t\tthis._queue = [];\n\t}\n\n\tclose()\n\t{\n\t\tthis._closed = true;\n\t}\n\n\tpush(method, data)\n\t{\n\t\tconst command = Object.assign({ method }, data);\n\n\t\tlogger.debug('push() [method:%s]', method);\n\n\t\treturn new Promise((resolve, reject) =>\n\t\t{\n\t\t\tconst queue = this._queue;\n\n\t\t\tcommand.resolve = resolve;\n\t\t\tcommand.reject = reject;\n\n\t\t\t// Append command to the queue.\n\t\t\tqueue.push(command);\n\t\t\tthis._handlePendingCommands();\n\t\t});\n\t}\n\n\t_handlePendingCommands()\n\t{\n\t\tif (this._busy)\n\t\t\treturn;\n\n\t\tconst queue = this._queue;\n\n\t\t// Take the first command.\n\t\tconst command = queue[0];\n\n\t\tif (!command)\n\t\t\treturn;\n\n\t\tthis._busy = true;\n\n\t\t// Execute it.\n\t\tthis._handleCommand(command)\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tthis._busy = false;\n\n\t\t\t\t// Remove the first command (the completed one) from the queue.\n\t\t\t\tqueue.shift();\n\n\t\t\t\t// And continue.\n\t\t\t\tthis._handlePendingCommands();\n\t\t\t});\n\t}\n\n\t_handleCommand(command)\n\t{\n\t\tlogger.debug('_handleCommand() [method:%s]', command.method);\n\n\t\tif (this._closed)\n\t\t{\n\t\t\tcommand.reject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"]('closed'));\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tconst promiseHolder = { promise: null };\n\n\t\tthis.emit('exec', command, promiseHolder);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn promiseHolder.promise;\n\t\t\t})\n\t\t\t.then((result) =>\n\t\t\t{\n\t\t\t\tlogger.debug('_handleCommand() | command succeeded [method:%s]', command.method);\n\n\t\t\t\tif (this._closed)\n\t\t\t\t{\n\t\t\t\t\tcommand.reject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"]('closed'));\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Resolve the command with the given result (if any).\n\t\t\t\tcommand.resolve(result);\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tlogger.error(\n\t\t\t\t\t'_handleCommand() | command failed [method:%s]: %o', command.method, error);\n\n\t\t\t\t// Reject the command with the error.\n\t\t\t\tcommand.reject(error);\n\t\t\t});\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/CommandQueue.js?");

/***/ }),

/***/ "./lib/mslib/Consumer.js":
/*!*******************************!*\
  !*** ./lib/mslib/Consumer.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Consumer; });\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./lib/mslib/errors.js\");\n\n\n\n\nconst PROFILES = new Set(['default', 'low', 'medium', 'high']);\nconst DEFAULT_STATS_INTERVAL = 1000;\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('Consumer');\n\nclass Consumer extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n{\n\t/**\n\t * @private\n\t *\n\t * @emits {originator: String, [appData]: Any} pause\n\t * @emits {originator: String, [appData]: Any} resume\n\t * @emits {profile: String} effectiveprofilechange\n\t * @emits {stats: Object} stats\n\t * @emits handled\n\t * @emits unhandled\n\t * @emits {originator: String} close\n\t *\n\t * @emits @close\n\t */\n\tconstructor(id, kind, rtpParameters, peer, appData)\n\t{\n\t\tsuper(logger);\n\n\t\t// Id.\n\t\t// @type {Number}\n\t\tthis._id = id;\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// Media kind.\n\t\t// @type {String}\n\t\tthis._kind = kind;\n\n\t\t// RTP parameters.\n\t\t// @type {RTCRtpParameters}\n\t\tthis._rtpParameters = rtpParameters;\n\n\t\t// Associated Peer.\n\t\t// @type {Peer}\n\t\tthis._peer = peer;\n\n\t\t// App custom data.\n\t\t// @type {Any}\n\t\tthis._appData = appData;\n\n\t\t// Whether we can receive this Consumer (based on our RTP capabilities).\n\t\t// @type {Boolean}\n\t\tthis._supported = false;\n\n\t\t// Associated Transport.\n\t\t// @type {Transport}\n\t\tthis._transport = null;\n\n\t\t// Remote track.\n\t\t// @type {MediaStreamTrack}\n\t\tthis._track = null;\n\n\t\t// Locally paused flag.\n\t\t// @type {Boolean}\n\t\tthis._locallyPaused = false;\n\n\t\t// Remotely paused flag.\n\t\t// @type {Boolean}\n\t\tthis._remotelyPaused = false;\n\n\t\t// Periodic stats flag.\n\t\t// @type {Boolean}\n\t\tthis._statsEnabled = false;\n\n\t\t// Periodic stats gathering interval (milliseconds).\n\t\t// @type {Number}\n\t\tthis._statsInterval = DEFAULT_STATS_INTERVAL;\n\n\t\t// Preferred profile.\n\t\t// @type {String}\n\t\tthis._preferredProfile = 'default';\n\n\t\t// Effective profile.\n\t\t// @type {String}\n\t\tthis._effectiveProfile = null;\n\t}\n\n\t/**\n\t * Consumer id.\n\t *\n\t * @return {Number}\n\t */\n\tget id()\n\t{\n\t\treturn this._id;\n\t}\n\n\t/**\n\t * Whether the Consumer is closed.\n\t *\n\t * @return {Boolean}\n\t */\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\t/**\n\t * Media kind.\n\t *\n\t * @return {String}\n\t */\n\tget kind()\n\t{\n\t\treturn this._kind;\n\t}\n\n\t/**\n\t * RTP parameters.\n\t *\n\t * @return {RTCRtpParameters}\n\t */\n\tget rtpParameters()\n\t{\n\t\treturn this._rtpParameters;\n\t}\n\n\t/**\n\t * Associated Peer.\n\t *\n\t * @return {Peer}\n\t */\n\tget peer()\n\t{\n\t\treturn this._peer;\n\t}\n\n\t/**\n\t * App custom data.\n\t *\n\t * @return {Any}\n\t */\n\tget appData()\n\t{\n\t\treturn this._appData;\n\t}\n\n\t/**\n\t * Whether we can receive this Consumer (based on our RTP capabilities).\n\t *\n\t * @return {Boolean}\n\t */\n\tget supported()\n\t{\n\t\treturn this._supported;\n\t}\n\n\t/**\n\t * Associated Transport.\n\t *\n\t * @return {Transport}\n\t */\n\tget transport()\n\t{\n\t\treturn this._transport;\n\t}\n\n\t/**\n\t * The associated track (if any yet).\n\t *\n\t * @return {MediaStreamTrack|null}\n\t */\n\tget track()\n\t{\n\t\treturn this._track;\n\t}\n\n\t/**\n\t * Whether the Consumer is locally paused.\n\t *\n\t * @return {Boolean}\n\t */\n\tget locallyPaused()\n\t{\n\t\treturn this._locallyPaused;\n\t}\n\n\t/**\n\t * Whether the Consumer is remotely paused.\n\t *\n\t * @return {Boolean}\n\t */\n\tget remotelyPaused()\n\t{\n\t\treturn this._remotelyPaused;\n\t}\n\n\t/**\n\t * Whether the Consumer is paused.\n\t *\n\t * @return {Boolean}\n\t */\n\tget paused()\n\t{\n\t\treturn this._locallyPaused || this._remotelyPaused;\n\t}\n\n\t/**\n\t * The preferred profile.\n\t *\n\t * @type {String}\n\t */\n\tget preferredProfile()\n\t{\n\t\treturn this._preferredProfile;\n\t}\n\n\t/**\n\t * The effective profile.\n\t *\n\t * @type {String}\n\t */\n\tget effectiveProfile()\n\t{\n\t\treturn this._effectiveProfile;\n\t}\n\n\t/**\n\t * Closes the Consumer.\n\t * This is called when the local Room is closed.\n\t *\n\t * @private\n\t */\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._closed = true;\n\n\t\tif (this._statsEnabled)\n\t\t{\n\t\t\tthis._statsEnabled = false;\n\n\t\t\tif (this.transport)\n\t\t\t\tthis.transport.disableConsumerStats(this);\n\t\t}\n\n\t\tthis.emit('@close');\n\t\tthis.safeEmit('close', 'local');\n\n\t\tthis._destroy();\n\t}\n\n\t/**\n\t * My remote Consumer was closed.\n\t * Invoked via remote notification.\n\t *\n\t * @private\n\t */\n\tremoteClose()\n\t{\n\t\tlogger.debug('remoteClose()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._closed = true;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.removeConsumer(this);\n\n\t\tthis._destroy();\n\n\t\tthis.emit('@close');\n\t\tthis.safeEmit('close', 'remote');\n\t}\n\n\t_destroy()\n\t{\n\t\tthis._transport = null;\n\n\t\ttry { this._track.stop(); }\n\t\tcatch (error) { }\n\n\t\tthis._track = null;\n\t}\n\n\t/**\n\t * Receives RTP.\n\t *\n\t * @param {transport} Transport instance.\n\t *\n\t * @return {Promise} Resolves with a remote MediaStreamTrack.\n\t */\n\treceive(transport)\n\t{\n\t\tlogger.debug('receive() [transport:%o]', transport);\n\n\t\tif (this._closed)\n\t\t\treturn Promise.reject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"]('Consumer closed'));\n\t\telse if (!this._supported)\n\t\t\treturn Promise.reject(new Error('unsupported codecs'));\n\t\telse if (this._transport)\n\t\t\treturn Promise.reject(new Error('already handled by a Transport'));\n\t\telse if (typeof transport !== 'object')\n\t\t\treturn Promise.reject(new TypeError('invalid Transport'));\n\n\t\tthis._transport = transport;\n\n\t\treturn transport.addConsumer(this)\n\t\t\t.then((track) =>\n\t\t\t{\n\t\t\t\tthis._track = track;\n\n\t\t\t\t// If we were paused, disable the track.\n\t\t\t\tif (this.paused)\n\t\t\t\t\ttrack.enabled = false;\n\n\t\t\t\ttransport.once('@close', () =>\n\t\t\t\t{\n\t\t\t\t\tif (this._closed || this._transport !== transport)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tthis._transport = null;\n\n\t\t\t\t\ttry { this._track.stop(); }\n\t\t\t\t\tcatch (error) { }\n\n\t\t\t\t\tthis._track = null;\n\n\t\t\t\t\tthis.safeEmit('unhandled');\n\t\t\t\t});\n\n\t\t\t\tthis.safeEmit('handled');\n\n\t\t\t\tif (this._statsEnabled)\n\t\t\t\t\ttransport.enableConsumerStats(this, this._statsInterval);\n\n\t\t\t\treturn track;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tthis._transport = null;\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Pauses receiving media.\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t *\n\t * @return {Boolean} true if paused.\n\t */\n\tpause(appData)\n\t{\n\t\tlogger.debug('pause()');\n\n\t\tif (this._closed)\n\t\t{\n\t\t\t// logger.warn('pause() | Consumer closed');\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (this._locallyPaused)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tthis._locallyPaused = true;\n\n\t\tif (this._track)\n\t\t\tthis._track.enabled = false;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.pauseConsumer(this, appData);\n\n\t\tthis.safeEmit('pause', 'local', appData);\n\n\t\t// Return true if really paused.\n\t\treturn this.paused;\n\t}\n\n\t/**\n\t * My remote Consumer was paused.\n\t * Invoked via remote notification.\n\t *\n\t * @private\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tremotePause(appData)\n\t{\n\t\tlogger.debug('remotePause()');\n\n\t\tif (this._closed || this._remotelyPaused)\n\t\t\treturn;\n\n\t\tthis._remotelyPaused = true;\n\n\t\tif (this._track)\n\t\t\tthis._track.enabled = false;\n\n\t\tthis.safeEmit('pause', 'remote', appData);\n\t}\n\n\t/**\n\t * Resumes receiving media.\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t *\n\t * @return {Boolean} true if not paused.\n\t */\n\tresume(appData)\n\t{\n\t\tlogger.debug('resume()');\n\n\t\tif (this._closed)\n\t\t{\n\t\t\t// logger.warn('resume() | Consumer closed');\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (!this._locallyPaused)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tthis._locallyPaused = false;\n\n\t\tif (this._track && !this._remotelyPaused)\n\t\t\tthis._track.enabled = true;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.resumeConsumer(this, appData);\n\n\t\tthis.safeEmit('resume', 'local', appData);\n\n\t\t// Return true if not paused.\n\t\treturn !this.paused;\n\t}\n\n\t/**\n\t * My remote Consumer was resumed.\n\t * Invoked via remote notification.\n\t *\n\t * @private\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tremoteResume(appData)\n\t{\n\t\tlogger.debug('remoteResume()');\n\n\t\tif (this._closed || !this._remotelyPaused)\n\t\t\treturn;\n\n\t\tthis._remotelyPaused = false;\n\n\t\tif (this._track && !this._locallyPaused)\n\t\t\tthis._track.enabled = true;\n\n\t\tthis.safeEmit('resume', 'remote', appData);\n\t}\n\n\t/**\n\t * Set preferred receiving profile.\n\t *\n\t * @param {String} profile\n\t */\n\tsetPreferredProfile(profile)\n\t{\n\t\tlogger.debug('setPreferredProfile() [profile:%s]', profile);\n\n\t\tif (this._closed)\n\t\t{\n\t\t\tlogger.warn('setPreferredProfile() | Consumer closed');\n\n\t\t\treturn;\n\t\t}\n\t\telse if (profile === this._preferredProfile)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if (!PROFILES.has(profile))\n\t\t{\n\t\t\tlogger.error('setPreferredProfile() | invalid profile \"%s\"', profile);\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis._preferredProfile = profile;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.setConsumerPreferredProfile(this, this._preferredProfile);\n\t}\n\n\t/**\n\t * Preferred receiving profile was set on my remote Consumer.\n\t *\n\t * @param {String} profile\n\t */\n\tremoteSetPreferredProfile(profile)\n\t{\n\t\tlogger.debug('remoteSetPreferredProfile() [profile:%s]', profile);\n\n\t\tif (this._closed || profile === this._preferredProfile)\n\t\t\treturn;\n\n\t\tthis._preferredProfile = profile;\n\t}\n\n\t/**\n\t * Effective receiving profile changed on my remote Consumer.\n\t *\n\t * @param {String} profile\n\t */\n\tremoteEffectiveProfileChanged(profile)\n\t{\n\t\tlogger.debug('remoteEffectiveProfileChanged() [profile:%s]', profile);\n\n\t\tif (this._closed || profile === this._effectiveProfile)\n\t\t\treturn;\n\n\t\tthis._effectiveProfile = profile;\n\n\t\tthis.safeEmit('effectiveprofilechange', this._effectiveProfile);\n\t}\n\n\t/**\n\t * Enables periodic stats retrieval.\n\t */\n\tenableStats(interval = DEFAULT_STATS_INTERVAL)\n\t{\n\t\tlogger.debug('enableStats() [interval:%s]', interval);\n\n\t\tif (this._closed)\n\t\t{\n\t\t\t// logger.warn('enableStats() | Consumer closed');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._statsEnabled)\n\t\t\treturn;\n\n\t\tif (typeof interval !== 'number' || interval < 1000)\n\t\t\tthis._statsInterval = DEFAULT_STATS_INTERVAL;\n\t\telse\n\t\t\tthis._statsInterval = interval;\n\n\t\tthis._statsEnabled = true;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.enableConsumerStats(this, this._statsInterval);\n\t}\n\n\t/**\n\t * Disables periodic stats retrieval.\n\t */\n\tdisableStats()\n\t{\n\t\t// logger.debug('disableStats()');\n\n\t\tif (this._closed)\n\t\t{\n\t\t\t// logger.error('disableStats() | Consumer closed');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._statsEnabled)\n\t\t\treturn;\n\n\t\tthis._statsEnabled = false;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.disableConsumerStats(this);\n\t}\n\n\t/**\n\t * Mark this Consumer as suitable for reception or not.\n\t *\n\t * @private\n\t *\n\t * @param {Boolean} flag\n\t */\n\tsetSupported(flag)\n\t{\n\t\tthis._supported = flag;\n\t}\n\n\t/**\n\t * Receive remote stats.\n\t *\n\t * @private\n\t *\n\t * @param {Object} stats\n\t */\n\tremoteStats(stats)\n\t{\n\t\tthis.safeEmit('stats', stats);\n\t}\n\n    /**\n     * Get consumer stats.\n     *\n     * @private\n     *\n     * @param {Object} selector\n     */\n\tgetStats(selector)\n\t{\n\t\treturn this.transport.getStats(selector);\n\t}\n\n\t/**\n\t * Enable internal statistics.\n\t * @param {number} interval \n\t */\n\tenableInternalStats(interval)\n\t{\n\t\tlet in_interval = interval > 0 && interval !== undefined ? interval : DEFAULT_STATS_INTERVAL;\n\t\t// logger.debug('enableInternalStats() [interval:%s]', in_interval);\n\n\t\tif (this._closed)\n\t\t{\n\t\t\t// logger.error('enableInternalStats() | Producer closed');\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._internalStatsEnabled) return;\n\t\tif (typeof in_interval !== 'number' || in_interval < 1000)\n\t\t\tthis._interanlStatsInterval = DEFAULT_STATS_INTERVAL;\n\t\telse\n\t\t\tthis._interanlStatsInterval = in_interval;\n\n\t\tthis._internalStatsEnabled = true;\n\t\tif (this._transport)\n\t\t{\n\t\t\tthis._internalTimer = setInterval(() => this.getStats().then(s =>\n\t\t\t{\n\t\t\t\tthis.emit('internalStats', s);\n\t\t\t}), in_interval);\n\t\t}\n\t}\n\n\t/**\n\t * Disable internal statistics.\n\t */\n\tdisableInternalStats()\n\t{\n\t\tif (this._internalStatsEnabled)\n\t\t{\n\t\t\tclearInterval(this._internalTimer);\n\t\t}\n\n\t\tthis._internalTimer = null;\n\t\tthis._internalStatsEnabled = false;\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/Consumer.js?");

/***/ }),

/***/ "./lib/mslib/Device.js":
/*!*****************************!*\
  !*** ./lib/mslib/Device.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Device; });\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bowser */ \"./node_modules/bowser/src/bowser.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bowser__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _handlers_Chrome70__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./handlers/Chrome70 */ \"./lib/mslib/handlers/Chrome70.js\");\n/* harmony import */ var _handlers_Chrome69__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./handlers/Chrome69 */ \"./lib/mslib/handlers/Chrome69.js\");\n/* harmony import */ var _handlers_Chrome67__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./handlers/Chrome67 */ \"./lib/mslib/handlers/Chrome67.js\");\n/* harmony import */ var _handlers_Chrome55__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./handlers/Chrome55 */ \"./lib/mslib/handlers/Chrome55.js\");\n/* harmony import */ var _handlers_Safari13__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./handlers/Safari13 */ \"./lib/mslib/handlers/Safari13.js\");\n/* harmony import */ var _handlers_Safari12__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./handlers/Safari12 */ \"./lib/mslib/handlers/Safari12.js\");\n/* harmony import */ var _handlers_Safari11__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./handlers/Safari11 */ \"./lib/mslib/handlers/Safari11.js\");\n/* harmony import */ var _handlers_Firefox65__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./handlers/Firefox65 */ \"./lib/mslib/handlers/Firefox65.js\");\n/* harmony import */ var _handlers_Firefox59__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./handlers/Firefox59 */ \"./lib/mslib/handlers/Firefox59.js\");\n/* harmony import */ var _handlers_Firefox50__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./handlers/Firefox50 */ \"./lib/mslib/handlers/Firefox50.js\");\n/* harmony import */ var _handlers_Edge11__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./handlers/Edge11 */ \"./lib/mslib/handlers/Edge11.js\");\n/* harmony import */ var _handlers_ReactNative__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./handlers/ReactNative */ \"./lib/mslib/handlers/ReactNative.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Device');\n\n/**\n * Class with static members representing the underlying device or browser.\n */\nclass Device\n{\n\t/**\n\t * Provides a custom RTC handler class and avoid auto-detection. Useful\n\t * for making mediasoup-client work with custom devices.\n\t *\n\t * NOTE: This function must be called upon library load.\n\t *\n\t * @param {Class} handler - A handler class.\n\t * @param {Object} [metadata] - Handler metadata.\n\t * @param {String} [metadata.flag] - Handler flag.\n\t * @param {String} [metadata.name] - Handler name.\n\t * @param {String} [metadata.version] - Handler version.\n\t * @param {Object} [metadata.bowser] - Handler bowser Object.\n\t */\n\tstatic setHandler(handler, metadata = {})\n\t{\n\t\tDevice._detected = true;\n\n\t\tDevice._handlerClass = handler;\n\n\t\t// Optional fields.\n\t\tDevice._flag = metadata.flag;\n\t\tDevice._name = metadata.name;\n\t\tDevice._version = metadata.version;\n\t\tDevice._bowser = metadata.bowser || {};\n\t}\n\n\t/**\n\t * Get the device flag.\n\t *\n\t * @return {String}\n\t */\n\tstatic getFlag()\n\t{\n\t\tif (!Device._detected)\n\t\t\tDevice._detect();\n\n\t\treturn Device._flag;\n\t}\n\n\t/**\n\t * Get the device name.\n\t *\n\t * @return {String}\n\t */\n\tstatic getName()\n\t{\n\t\tif (!Device._detected)\n\t\t\tDevice._detect();\n\n\t\treturn Device._name;\n\t}\n\n\t/**\n\t * Get the device version.\n\t *\n\t * @return {String}\n\t */\n\tstatic getVersion()\n\t{\n\t\tif (!Device._detected)\n\t\t\tDevice._detect();\n\n\t\treturn Device._version;\n\t}\n\n\t/**\n\t * Get the bowser module Object.\n\t *\n\t * @return {Object}\n\t */\n\tstatic getBowser()\n\t{\n\t\tif (!Device._detected)\n\t\t\tDevice._detect();\n\n\t\treturn Device._bowser;\n\t}\n\n\t/**\n\t * Whether this device is supported.\n\t *\n\t * @return {Boolean}\n\t */\n\tstatic isSupported()\n\t{\n\t\tif (!Device._detected)\n\t\t\tDevice._detect();\n\n\t\treturn Boolean(Device._handlerClass);\n\t}\n\n\t/**\n\t * Returns a suitable WebRTC handler class.\n\t *\n\t * @type {Class}\n\t */\n\tstatic get Handler()\n\t{\n\t\tif (!Device._detected)\n\t\t\tDevice._detect();\n\n\t\treturn Device._handlerClass;\n\t}\n\n\t/**\n\t * Detects the current device/browser.\n\t *\n\t * @private\n\t */\n\tstatic _detect()\n\t{\n\t\tDevice._detected = true;\n\n\t\t// If this is React-Native manually fill data.\n\t\tif (global.navigator && global.navigator.product === 'ReactNative')\n\t\t{\n\t\t\tDevice._flag = 'react-native';\n\t\t\tDevice._name = 'ReactNative';\n\t\t\tDevice._version = undefined; // NOTE: No idea how to know it.\n\t\t\tDevice._bowser = {};\n\t\t\tDevice._handlerClass = _handlers_ReactNative__WEBPACK_IMPORTED_MODULE_13__[\"default\"];\n\t\t}\n\t\t// If this is a browser use bowser module detection.\n\t\telse if (global.navigator && typeof global.navigator.userAgent === 'string')\n\t\t{\n\t\t\tconst ua = global.navigator.userAgent;\n\t\t\tconst browser = bowser__WEBPACK_IMPORTED_MODULE_0___default.a.detect(ua);\n\n\t\t\tDevice._flag = undefined;\n\t\t\tDevice._name = browser.name || undefined;\n\t\t\tDevice._version = browser.version || undefined;\n\t\t\tDevice._bowser = browser;\n\t\t\tDevice._handlerClass = null;\n\n\t\t\t// Chrome, Chromium (desktop and mobile).\n\t\t\tif (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ chrome: '70', chromium: '70' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'chrome';\n\t\t\t\tDevice._handlerClass = _handlers_Chrome70__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n\t\t\t}\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ chrome: '69', chromium: '69' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'chrome';\n\t\t\t\tDevice._handlerClass = _handlers_Chrome69__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n\t\t\t}\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ chrome: '67', chromium: '67' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'chrome';\n\t\t\t\tDevice._handlerClass = _handlers_Chrome67__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n\t\t\t}\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ chrome: '55', chromium: '55' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'chrome';\n\t\t\t\tDevice._handlerClass = _handlers_Chrome55__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n\t\t\t}\n\t\t\t// Special case for old Chrome >= 49 if webrtc-adapter is present.\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ chrome: '49', chromium: '49' }, true, ua) && global.adapter)\n\t\t\t{\n\t\t\t\tDevice._flag = 'chrome';\n\t\t\t\tDevice._handlerClass = _handlers_Chrome55__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n\t\t\t}\n\t\t\t// Firefox (desktop and mobile).\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ firefox: '65' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'firefox';\n\t\t\t\tDevice._handlerClass = _handlers_Firefox65__WEBPACK_IMPORTED_MODULE_9__[\"default\"];\n\t\t\t}\n\t\t\t// Firefox (desktop and mobile).\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ firefox: '59' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'firefox';\n\t\t\t\tDevice._handlerClass = _handlers_Firefox59__WEBPACK_IMPORTED_MODULE_10__[\"default\"];\n\t\t\t}\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ firefox: '50' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'firefox';\n\t\t\t\tDevice._handlerClass = _handlers_Firefox50__WEBPACK_IMPORTED_MODULE_11__[\"default\"];\n\t\t\t}\n\t\t\t// Safari (desktop and mobile).\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ safari: '13' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'safari';\n\t\t\t\tDevice._handlerClass = _handlers_Safari13__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n\t\t\t}\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ safari: '12.1' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'safari';\n\t\t\t\tDevice._handlerClass = _handlers_Safari12__WEBPACK_IMPORTED_MODULE_7__[\"default\"];\n\t\t\t}\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ safari: '11' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'safari';\n\t\t\t\tDevice._handlerClass = _handlers_Safari11__WEBPACK_IMPORTED_MODULE_8__[\"default\"];\n\t\t\t}\n\t\t\t// Edge (desktop).\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ msedge: '11' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'msedge';\n\t\t\t\tDevice._handlerClass = _handlers_Edge11__WEBPACK_IMPORTED_MODULE_12__[\"default\"];\n\t\t\t}\n\t\t\t// Opera (desktop and mobile).\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ opera: '57' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'opera';\n\t\t\t\tDevice._handlerClass = _handlers_Chrome70__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n\t\t\t}\n\t\t\telse if (bowser__WEBPACK_IMPORTED_MODULE_0___default.a.check({ opera: '44' }, true, ua))\n\t\t\t{\n\t\t\t\tDevice._flag = 'opera';\n\t\t\t\tDevice._handlerClass = _handlers_Chrome55__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n\t\t\t}\n\t\t\t// Best effort for Chromium based browsers.\n\t\t\telse if (browser.chromium || browser.blink || browser.webkit)\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'best effort Chrome based browser detection [name:\"%s\"]', browser.name);\n\n\t\t\t\tDevice._flag = 'chrome';\n\n\t\t\t\tconst match = ua.match(/(?:(?:Chrome|Chromium))[ /](\\w+)/i);\n\n\t\t\t\tif (match)\n\t\t\t\t{\n\t\t\t\t\tconst version = Number(match[1]);\n\n\t\t\t\t\tif (version >= 70)\n\t\t\t\t\t\tDevice._handlerClass = _handlers_Chrome70__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n\t\t\t\t\telse if (version >= 69)\n\t\t\t\t\t\tDevice._handlerClass = _handlers_Chrome69__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n\t\t\t\t\telse if (version >= 67)\n\t\t\t\t\t\tDevice._handlerClass = _handlers_Chrome67__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n\t\t\t\t\telse\n\t\t\t\t\t\tDevice._handlerClass = _handlers_Chrome55__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tDevice._handlerClass = _handlers_Chrome70__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Device.isSupported())\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'browser supported [flag:%s, name:\"%s\", version:%s, handler:%s]',\n\t\t\t\t\tDevice._flag, Device._name, Device._version, Device._handlerClass.tag);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogger.warn(\n\t\t\t\t\t'browser not supported [name:%s, version:%s]',\n\t\t\t\t\tDevice._name, Device._version);\n\t\t\t}\n\t\t}\n\t\t// Otherwise fail.\n\t\telse\n\t\t{\n\t\t\tlogger.warn('device not supported');\n\t\t}\n\t}\n}\n\n// Initialized flag.\n// @type {Boolean}\nDevice._detected = false;\n\n// Device flag.\n// @type {String}\nDevice._flag = undefined;\n\n// Device name.\n// @type {String}\nDevice._name = undefined;\n\n// Device version.\n// @type {String}\nDevice._version = undefined;\n\n// bowser module Object.\n// @type {Object}\nDevice._bowser = undefined;\n\n// WebRTC hander for this device.\n// @type {Class}\nDevice._handlerClass = null;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./lib/mslib/Device.js?");

/***/ }),

/***/ "./lib/mslib/EnhancedEventEmitter.js":
/*!*******************************************!*\
  !*** ./lib/mslib/EnhancedEventEmitter.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return EnhancedEventEmitter; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Logger */ \"./lib/mslib/Logger.js\");\n\n\n\nclass EnhancedEventEmitter extends events__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter\"]\n{\n\tconstructor(logger)\n\t{\n\t\tsuper();\n\t\tthis.setMaxListeners(Infinity);\n\n\t\tthis._logger = logger || new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('EnhancedEventEmitter');\n\t}\n\n\tsafeEmit(event, ...args)\n\t{\n\t\ttry\n\t\t{\n\t\t\tthis.emit(event, ...args);\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tthis._logger.error(\n\t\t\t\t'safeEmit() | event listener threw an error [event:%s]:%o',\n\t\t\t\tevent, error);\n\t\t}\n\t}\n\n\tsafeEmitAsPromise(event, ...args)\n\t{\n\t\treturn new Promise((resolve, reject) =>\n\t\t{\n\t\t\tconst callback = (result) =>\n\t\t\t{\n\t\t\t\tresolve(result);\n\t\t\t};\n\n\t\t\tconst errback = (error) =>\n\t\t\t{\n\t\t\t\tthis._logger.error(\n\t\t\t\t\t'safeEmitAsPromise() | errback called [event:%s]:%o',\n\t\t\t\t\tevent, error);\n\n\t\t\t\treject(error);\n\t\t\t};\n\n\t\t\tthis.safeEmit(event, ...args, callback, errback);\n\t\t});\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/EnhancedEventEmitter.js?");

/***/ }),

/***/ "./lib/mslib/Logger.js":
/*!*****************************!*\
  !*** ./lib/mslib/Logger.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Logger; });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst APP_NAME = 'mediasoup-client';\n\nclass Logger\n{\n\tconstructor(prefix)\n\t{\n\t\tif (prefix)\n\t\t{\n\t\t\tthis._debug = debug__WEBPACK_IMPORTED_MODULE_0___default()(`${APP_NAME}:${prefix}`);\n\t\t\tthis._warn = debug__WEBPACK_IMPORTED_MODULE_0___default()(`${APP_NAME}:WARN:${prefix}`);\n\t\t\tthis._error = debug__WEBPACK_IMPORTED_MODULE_0___default()(`${APP_NAME}:ERROR:${prefix}`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._debug = debug__WEBPACK_IMPORTED_MODULE_0___default()(APP_NAME);\n\t\t\tthis._warn = debug__WEBPACK_IMPORTED_MODULE_0___default()(`${APP_NAME}:WARN`);\n\t\t\tthis._error = debug__WEBPACK_IMPORTED_MODULE_0___default()(`${APP_NAME}:ERROR`);\n\t\t}\n\n\t\t/* eslint-disable no-console */\n\t\tthis._debug.log = console.info.bind(console);\n\t\tthis._warn.log = console.warn.bind(console);\n\t\tthis._error.log = console.error.bind(console);\n\t\t/* eslint-enable no-console */\n\t}\n\n\tget debug()\n\t{\n\t\treturn this._debug;\n\t}\n\n\tget warn()\n\t{\n\t\treturn this._warn;\n\t}\n\n\tget error()\n\t{\n\t\treturn this._error;\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/Logger.js?");

/***/ }),

/***/ "./lib/mslib/Peer.js":
/*!***************************!*\
  !*** ./lib/mslib/Peer.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Peer; });\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('Peer');\n\nclass Peer extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n{\n\t/**\n\t * @private\n\t *\n\t * @emits {consumer: Consumer} newconsumer\n\t * @emits {originator: String, [appData]: Any} close\n\t *\n\t * @emits @close\n\t */\n\tconstructor(name, appData)\n\t{\n\t\tsuper(logger);\n\n\t\t// Name.\n\t\t// @type {String}\n\t\tthis._name = name;\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// App custom data.\n\t\t// @type {Any}\n\t\tthis._appData = appData;\n\n\t\t// Map of Consumers indexed by id.\n\t\t// @type {map<Number, Consumer>}\n\t\tthis._consumers = new Map();\n\t}\n\n\t/**\n\t * Peer name.\n\t *\n\t * @return {String}\n\t */\n\tget name()\n\t{\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * Whether the Peer is closed.\n\t *\n\t * @return {Boolean}\n\t */\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\t/**\n\t * App custom data.\n\t *\n\t * @return {Any}\n\t */\n\tget appData()\n\t{\n\t\treturn this._appData;\n\t}\n\n\t/**\n\t * The list of Consumers.\n\t *\n\t * @return {Array<Consumer>}\n\t */\n\tget consumers()\n\t{\n\t\treturn Array.from(this._consumers.values());\n\t}\n\n\t/**\n\t * Closes the Peer.\n\t * This is called when the local Room is closed.\n\t *\n\t * @private\n\t */\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._closed = true;\n\n\t\tthis.emit('@close');\n\t\tthis.safeEmit('close', 'local');\n\n\t\t// Close all the Consumers.\n\t\tfor (const consumer of this._consumers.values())\n\t\t{\n\t\t\tconsumer.close();\n\t\t}\n\t}\n\n\t/**\n\t * The remote Peer or Room was closed.\n\t * Invoked via remote notification.\n\t *\n\t * @private\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tremoteClose(appData)\n\t{\n\t\tlogger.debug('remoteClose()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._closed = true;\n\n\t\tthis.emit('@close');\n\t\tthis.safeEmit('close', 'remote', appData);\n\n\t\t// Close all the Consumers.\n\t\tfor (const consumer of this._consumers.values())\n\t\t{\n\t\t\tconsumer.remoteClose();\n\t\t}\n\t}\n\n\t/**\n\t * Get the Consumer with the given id.\n\t *\n\t * @param {Number} id\n\t *\n\t * @return {Consumer}\n\t */\n\tgetConsumerById(id)\n\t{\n\t\treturn this._consumers.get(id);\n\t}\n\n\t/**\n\t * Add an associated Consumer.\n\t *\n\t * @private\n\t *\n\t * @param {Consumer} consumer\n\t */\n\taddConsumer(consumer)\n\t{\n\t\tif (this._consumers.has(consumer.id))\n\t\t\tthrow new Error(`Consumer already exists [id:${consumer.id}]`);\n\n\t\t// Store it.\n\t\tthis._consumers.set(consumer.id, consumer);\n\n\t\t// Handle it.\n\t\tconsumer.on('@close', () =>\n\t\t{\n\t\t\tthis._consumers.delete(consumer.id);\n\t\t});\n\n\t\t// Emit event.\n\t\tthis.safeEmit('newconsumer', consumer);\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/Peer.js?");

/***/ }),

/***/ "./lib/mslib/Producer.js":
/*!*******************************!*\
  !*** ./lib/mslib/Producer.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Producer; });\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./lib/mslib/errors.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./lib/mslib/utils.js\");\n\n\n\n\n\nconst DEFAULT_STATS_INTERVAL = 1000;\nconst SIMULCAST_DEFAULT =\n{\n\tlow    : 100000,\n\tmedium : 300000,\n\thigh   : 1500000\n};\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('Producer');\n\nclass Producer extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n{\n\t/**\n\t * @private\n\t *\n\t * @emits {originator: String, [appData]: Any} pause\n\t * @emits {originator: String, [appData]: Any} resume\n\t * @emits {stats: Object} stats\n\t * @emits handled\n\t * @emits unhandled\n\t * @emits trackended\n\t * @emits {originator: String, [appData]: Any} close\n\t *\n\t * @emits {originator: String, [appData]: Any} @close\n\t */\n\tconstructor(track, options, appData)\n\t{\n\t\tsuper(logger);\n\n\t\t// Id.\n\t\t// @type {Number}\n\t\tthis._id = _utils__WEBPACK_IMPORTED_MODULE_3__[\"randomNumber\"]();\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// Original track.\n\t\t// @type {MediaStreamTrack}\n\t\tthis._originalTrack = track;\n\n\t\t// Track cloned from the original one (if supported).\n\t\t// @type {MediaStreamTrack}\n\t\ttry\n\t\t{\n\t\t\tthis._track = track.clone();\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tthis._track = track;\n\t\t}\n\n\t\t// App custom data.\n\t\t// @type {Any}\n\t\tthis._appData = appData;\n\n\t\t// Simulcast.\n\t\t// @type {Object|false}\n\t\tthis._simulcast = false;\n\n\t\tif (typeof options.simulcast === 'object')\n\t\t\tthis._simulcast = Object.assign({}, SIMULCAST_DEFAULT, options.simulcast);\n\t\telse if (options.simulcast === true)\n\t\t\tthis._simulcast = Object.assign({}, SIMULCAST_DEFAULT);\n\n\t\tthis._audioProfile = null;\n\t\tif (typeof(options.audioProfile) == 'object')\n\t\t\tthis._audioProfile = options.audioProfile;\n\n        // @type {codecOptions}\n        // {\n        //   videoGoogleStartBitrate: Number,\n        //   videoGoogleMaxBitrate: Number,\n        //   videoGoogleMinBitrate: Number\n        // }\n        this._videoBitrateOptions = null;\n        if (typeof(options.codecOptions) === 'object')\n        \tthis._videoBitrateOptions = options.codecOptions;\n\n\t\t// Associated Transport.\n\t\t// @type {Transport}\n\t\tthis._transport = null;\n\n\t\t// RTP parameters.\n\t\t// @type {RTCRtpParameters}\n\t\tthis._rtpParameters = null;\n\n\t\t// Locally paused flag.\n\t\t// @type {Boolean}\n\t\tthis._locallyPaused = !this._track.enabled;\n\n\t\t// Remotely paused flag.\n\t\t// @type {Boolean}\n\t\tthis._remotelyPaused = false;\n\n\t\t// Periodic stats flag.\n\t\t// @type {Boolean}\n\t\tthis._statsEnabled = false;\n\n\t\t// Periodic stats gathering interval (milliseconds).\n\t\t// @type {Number}\n\t\tthis._statsInterval = DEFAULT_STATS_INTERVAL;\n\n\t\t// Handle the effective track.\n\t\tthis._handleTrack();\n\t}\n\n\t/**\n\t * Producer id.\n\t *\n\t * @return {Number}\n\t */\n\tget id()\n\t{\n\t\treturn this._id;\n\t}\n\n\t/**\n\t * Whether the Producer is closed.\n\t *\n\t * @return {Boolean}\n\t */\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\t/**\n\t * Media kind.\n\t *\n\t * @return {String}\n\t */\n\tget kind()\n\t{\n\t\treturn this._track.kind;\n\t}\n\n\t/**\n\t * The associated track.\n\t *\n\t * @return {MediaStreamTrack}\n\t */\n\tget track()\n\t{\n\t\treturn this._track;\n\t}\n\n\t/**\n\t * The associated original track.\n\t *\n\t * @return {MediaStreamTrack}\n\t */\n\tget originalTrack()\n\t{\n\t\treturn this._originalTrack;\n\t}\n\n\t/**\n\t * Simulcast settings.\n\t *\n\t * @return {Object|false}\n\t */\n\tget simulcast()\n\t{\n\t\treturn this._simulcast;\n\t}\n\n\t/**\n\t * App custom data.\n\t *\n\t * @return {Any}\n\t */\n\tget appData()\n\t{\n\t\treturn this._appData;\n\t}\n\n\t/**\n\t * Associated Transport.\n\t *\n\t * @return {Transport}\n\t */\n\tget transport()\n\t{\n\t\treturn this._transport;\n\t}\n\n\t/**\n\t * RTP parameters.\n\t *\n\t * @return {RTCRtpParameters}\n\t */\n\tget rtpParameters()\n\t{\n\t\treturn this._rtpParameters;\n\t}\n\n\t/**\n\t * Whether the Producer is locally paused.\n\t *\n\t * @return {Boolean}\n\t */\n\tget locallyPaused()\n\t{\n\t\treturn this._locallyPaused;\n\t}\n\n\t/**\n\t * Whether the Producer is remotely paused.\n\t *\n\t * @return {Boolean}\n\t */\n\tget remotelyPaused()\n\t{\n\t\treturn this._remotelyPaused;\n\t}\n\n\t/**\n\t * Whether the Producer is paused.\n\t *\n\t * @return {Boolean}\n\t */\n\tget paused()\n\t{\n\t\treturn this._locallyPaused || this._remotelyPaused;\n\t}\n\n\t/**\n\t * Closes the Producer.\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tclose(appData)\n\t{\n\t\tlogger.debug('close()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._closed = true;\n\n\t\tif (this._statsEnabled)\n\t\t{\n\t\t\tthis._statsEnabled = false;\n\n\t\t\tif (this.transport)\n\t\t\t{\n\t\t\t\tthis.transport.disableProducerStats(this);\n\t\t\t}\n\t\t}\n\n\t\tif (this._transport)\n\t\t\tthis._transport.removeProducer(this, 'local', appData);\n\n\t\tthis._destroy();\n\n\t\tthis.emit('@close', 'local', appData);\n\t\tthis.safeEmit('close', 'local', appData);\n\t}\n\n\t/**\n\t * My remote Producer was closed.\n\t * Invoked via remote notification.\n\t *\n\t * @private\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tremoteClose(appData)\n\t{\n\t\tlogger.debug('remoteClose()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._closed = true;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.removeProducer(this, 'remote', appData);\n\n\t\tthis._destroy();\n\n\t\tthis.emit('@close', 'remote', appData);\n\t\tthis.safeEmit('close', 'remote', appData);\n\t}\n\n\t_destroy()\n\t{\n\t\tthis._transport = false;\n\t\tthis._rtpParameters = null;\n\n\t\ttry { this._track.stop(); }\n\t\tcatch (error) {}\n\t}\n\n\t/**\n\t * Sends RTP.\n\t *\n\t * @param {transport} Transport instance.\n\t *\n\t * @return {Promise}\n\t */\n\tsend(transport)\n\t{\n\t\tlogger.debug('send() [transport:%o]', transport);\n\n\t\tif (this._closed)\n\t\t\treturn Promise.reject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"]('Producer closed'));\n\t\telse if (this._transport)\n\t\t\treturn Promise.reject(new Error('already handled by a Transport'));\n\t\telse if (typeof transport !== 'object')\n\t\t\treturn Promise.reject(new TypeError('invalid Transport'));\n\n\t\tif(this._originalTrack.kind === 'audio')\n\t\t{\n            transport._audioSent = true;\n\t\t}\n\t\telse if (this._originalTrack.kind === 'video')\n\t\t{\n            transport._videoSent = true;\n        }\n\n\t\tthis._transport = transport;\n\n\t\treturn transport.addProducer(this)\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\ttransport.once('@close', () =>\n\t\t\t\t{\n\t\t\t\t\tif (this._closed || this._transport !== transport)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\tthis._transport.removeProducer(this, 'local');\n\n\t\t\t\t\tthis._transport = null;\n\t\t\t\t\tthis._rtpParameters = null;\n\n\t\t\t\t\tthis.safeEmit('unhandled');\n\t\t\t\t});\n\n\t\t\t\tthis.safeEmit('handled');\n\n\t\t\t\tif (this._statsEnabled)\n\t\t\t\t\ttransport.enableProducerStats(this, this._statsInterval);\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tthis._transport = null;\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Pauses sending media.\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t *\n\t * @return {Boolean} true if paused.\n\t */\n\tpause(appData)\n\t{\n\t\tlogger.debug('pause()');\n\n\t\tif (this._closed)\n\t\t{\n\t\t\t// logger.error('pause() | Producer closed');\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (this._locallyPaused)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tthis._locallyPaused = true;\n\t\tthis._track.enabled = false;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.pauseProducer(this, appData);\n\n\t\tthis.safeEmit('pause', 'local', appData);\n\n\t\t// Return true if really paused.\n\t\treturn this.paused;\n\t}\n\n\t/**\n\t * My remote Producer was paused.\n\t * Invoked via remote notification.\n\t *\n\t * @private\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tremotePause(appData)\n\t{\n\t\tlogger.debug('remotePause()');\n\n\t\tif (this._closed || this._remotelyPaused)\n\t\t\treturn;\n\n\t\tthis._remotelyPaused = true;\n\t\tthis._track.enabled = false;\n\n\t\tthis.safeEmit('pause', 'remote', appData);\n\t}\n\n\t/**\n\t * Resumes sending media.\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t *\n\t * @return {Boolean} true if not paused.\n\t */\n\tresume(appData)\n\t{\n\t\tlogger.debug('resume()');\n\n\t\tif (this._closed)\n\t\t{\n\t\t\t// logger.error('resume() | Producer closed');\n\n\t\t\treturn false;\n\t\t}\n\t\telse if (!this._locallyPaused)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tthis._locallyPaused = false;\n\n\t\tif (!this._remotelyPaused)\n\t\t\tthis._track.enabled = true;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.resumeProducer(this, appData);\n\n\t\tthis.safeEmit('resume', 'local', appData);\n\n\t\t// Return true if not paused.\n\t\treturn !this.paused;\n\t}\n\n\t/**\n\t * My remote Producer was resumed.\n\t * Invoked via remote notification.\n\t *\n\t * @private\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tremoteResume(appData)\n\t{\n\t\tlogger.debug('remoteResume()');\n\n\t\tif (this._closed || !this._remotelyPaused)\n\t\t\treturn;\n\n\t\tthis._remotelyPaused = false;\n\n\t\tif (!this._locallyPaused)\n\t\t\tthis._track.enabled = true;\n\n\t\tthis.safeEmit('resume', 'remote', appData);\n\t}\n\n\t/**\n\t * Replaces the current track with a new one.\n\t *\n\t * @param {MediaStreamTrack} track - New track.\n\t *\n\t * @return {Promise} Resolves with the new track itself.\n\t */\n\treplaceTrack(track)\n\t{\n\t\tlogger.debug('replaceTrack() [track:%o]', track);\n\n\t\tif (this._closed)\n\t\t\treturn Promise.reject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"]('Producer closed'));\n\t\telse if (!track)\n\t\t\treturn Promise.reject(new TypeError('no track given'));\n\t\telse if (track.readyState === 'ended')\n\t\t\treturn Promise.reject(new Error('track.readyState is \"ended\"'));\n\n\t\tlet clonedTrack;\n\n\t\ttry\n\t\t{\n\t\t\tclonedTrack = track.clone();\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tclonedTrack = track;\n\t\t}\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// If this Producer is handled by a Transport, we need to tell it about\n\t\t\t\t// the new track.\n\t\t\t\tif (this._transport)\n\t\t\t\t\treturn this._transport.replaceProducerTrack(this, clonedTrack);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Stop the previous track.\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tthis._track.onended = null; this._track.stop();\n\t\t\t\t}\n\t\t\t\tcatch (error)\n\t\t\t\t{\n\t\t\t\t}\n\n\t\t\t\t// If this Producer was locally paused/resumed and the state of the new\n\t\t\t\t// track does not match, fix it.\n\t\t\t\tif (!this.paused)\n\t\t\t\t\tclonedTrack.enabled = true;\n\t\t\t\telse\n\t\t\t\t\tclonedTrack.enabled = false;\n\n\t\t\t\t// Set the new tracks.\n\t\t\t\tthis._originalTrack = track;\n\t\t\t\tthis._track = clonedTrack;\n\n\t\t\t\t// Handle the effective track.\n\t\t\t\tthis._handleTrack();\n\n\t\t\t\t// Return the new track.\n\t\t\t\treturn this._track;\n\t\t\t});\n\t}\n\n    updateTrack(track, codecOptions)\n\t{\n        this.setCodecOption(codecOptions)\n        this._transport.updateTrack(this, track);\n    }\n\n    setCodecOption(codecOptions)\n\t{\n        this._videoBitrateOptions = {\n            videoGoogleStartBitrate: codecOptions.idealBandwidth,\n            videoGoogleMaxBitrate: codecOptions.maxBandwidth,\n            videoGoogleMinBitrate: codecOptions.minBandwidth\n        }\n\t}\n\t\n\t// \n\tget videoBitrateOptions()\n\t{\n\t\treturn this._videoBitrateOptions;\n\t}\n\n\t// \n\tget audioProfile()\n\t{\n\t\treturn this._audioProfile;\n\t}\n\n\t/**\n\t * Set/update RTP parameters.\n\t *\n\t * @private\n\t *\n\t * @param {RTCRtpParameters} rtpParameters\n\t */\n\tsetRtpParameters(rtpParameters)\n\t{\n\t\tthis._rtpParameters = rtpParameters;\n\t}\n\n\t/**\n\t * Enables periodic stats retrieval.\n\t */\n\tenableStats(interval = DEFAULT_STATS_INTERVAL)\n\t{\n\t\tlogger.debug('enableStats() [interval:%s]', interval);\n\n\t\tif (this._closed)\n\t\t{\n\t\t\t// logger.error('enableStats() | Producer closed');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._statsEnabled)\n\t\t\treturn;\n\n\t\tif (typeof interval !== 'number' || interval < 1000)\n\t\t\tthis._statsInterval = DEFAULT_STATS_INTERVAL;\n\t\telse\n\t\t\tthis._statsInterval = interval;\n\n\t\tthis._statsEnabled = true;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.enableProducerStats(this, this._statsInterval);\n\t}\n\n\t/**\n\t * Disables periodic stats retrieval.\n\t */\n\tdisableStats()\n\t{\n\t\t// logger.debug('disableStats()');\n\n\t\tif (this._closed)\n\t\t{\n\t\t\t// logger.error('disableStats() | Producer closed');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._statsEnabled)\n\t\t\treturn;\n\n\t\tthis._statsEnabled = false;\n\n\t\tif (this._transport)\n\t\t\tthis._transport.disableProducerStats(this);\n\t}\n\n\t/**\n\t * Receive remote stats.\n\t *\n\t * @private\n\t *\n\t * @param {Object} stats\n\t */\n\n    enableInternalStats()\n\t{\n        var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATS_INTERVAL;\n        logger.debug('enableInternalStats() [interval:%s]', interval);\n\n        if (this._closed) {\n            // logger.error('enableInternalStats() | Producer closed');\n            return;\n        }\n\n        if (this._internalStatsEnabled) return;\n        if (typeof interval !== 'number' || interval < 1000) this._interanlStatsInterval = DEFAULT_STATS_INTERVAL;else this._statsInterval = interval;\n        this._internalStatsEnabled = true;\n        if (this._transport) {\n            this._internalTimer = setInterval( () => this.getStats().then(s => {\n                this.emit('internalStats', s);\n            }), interval);\n        }\n    }\n\n    disableInternalStats()\n\t{\n        if(this._internalStatsEnabled) {\n            clearInterval(this._internalTimer);\n        }\n\n        this._internalTimer = null;\n        this._internalStatsEnabled = false;\n    }\n\tremoteStats(stats)\n\t{\n\t\tthis.safeEmit('stats', stats);\n\t}\n\n    /**\n     * Get producer stats.\n     *\n     * @private\n     *\n     * @param {Object} stats\n     */\n\n    getStats()\n\t{\n\t\treturn this.transport.getStats(this.track);\n\t}\n\t/**\n\t * @private\n\t */\n\t_handleTrack()\n\t{\n\t\t// If the cloned track is closed (for example if the desktop sharing is closed\n\t\t// via chrome UI) notify the app and let it decide wheter to close the Producer\n\t\t// or not.\n\t\tthis._track.onended = () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.warn('track \"ended\" event');\n\n\t\t\tthis.safeEmit('trackended');\n\t\t};\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/Producer.js?");

/***/ }),

/***/ "./lib/mslib/Room.js":
/*!***************************!*\
  !*** ./lib/mslib/Room.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Room; });\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./lib/mslib/errors.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _Device__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Device */ \"./lib/mslib/Device.js\");\n/* harmony import */ var _Transport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Transport */ \"./lib/mslib/Transport.js\");\n/* harmony import */ var _Producer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Producer */ \"./lib/mslib/Producer.js\");\n/* harmony import */ var _Peer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Peer */ \"./lib/mslib/Peer.js\");\n/* harmony import */ var _Consumer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Consumer */ \"./lib/mslib/Consumer.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('Room');\n\nconst RoomState =\n{\n\tnew     : 'new',\n\tjoining : 'joining',\n\tjoined  : 'joined',\n\tclosed  : 'closed'\n};\n\n/**\n * An instance of Room represents a remote multi conference and a local\n * peer that joins it.\n */\nclass Room extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n{\n\t/**\n\t * Room class.\n\t *\n\t * @param {Object} [options]\n\t * @param {Object} [options.roomSettings] Remote room settings, including its RTP\n\t * capabilities, mandatory codecs, etc. If given, no 'queryRoom' request is sent\n\t * to the server to discover them.\n\t * @param {Number} [options.requestTimeout=10000] - Timeout for sent requests\n\t * (in milliseconds). Defaults to 10000 (10 seconds).\n\t * @param {Object} [options.transportOptions] - Options for Transport created in mediasoup.\n\t * @param {Array<RTCIceServer>} [options.turnServers] - Array of TURN servers.\n\t * @param {RTCIceTransportPolicy} [options.iceTransportPolicy] - ICE transport policy.\n\t * @param {Boolean} [options.spy] - Whether this is a spy peer.\n\t *\n\t * @throws {Error} if device is not supported.\n\t *\n\t * @emits {request: Object, callback: Function, errback: Function} request\n\t * @emits {notification: Object} notify\n\t * @emits {peer: Peer} newpeer\n\t * @emits {originator: String, [appData]: Any} close\n\t */\n\tconstructor(options)\n\t{\n\t\tsuper(logger);\n\n\t\tlogger.debug('constructor() [options:%o]', options);\n\n\t\tif (!_Device__WEBPACK_IMPORTED_MODULE_4__[\"default\"].isSupported())\n\t\t\tthrow new Error('current browser/device not supported');\n\n\t\toptions = options || {};\n\n\t\t// Computed settings.\n\t\t// @type {Object}\n\t\tthis._settings =\n\t\t{\n\t\t\troomSettings       : options.roomSettings,\n\t\t\trequestTimeout     : options.requestTimeout || 30000,\n\t\t\ttransportOptions   : options.transportOptions || {},\n\t\t\tturnServers        : options.turnServers || [],\n\t\t\ticeTransportPolicy : options.iceTransportPolicy || 'all',\n\t\t\tspy                : Boolean(options.spy)\n\t\t};\n\n\t\t// Room state.\n\t\t// @type {Boolean}\n\t\tthis._state = RoomState.new;\n\n\t\t// My mediasoup Peer name.\n\t\t// @type {String}\n\t\tthis._peerName = null;\n\n\t\t// Map of Transports indexed by id.\n\t\t// @type {map<Number, Transport>}\n\t\tthis._transports = new Map();\n\n\t\t// Map of Producers indexed by id.\n\t\t// @type {map<Number, Producer>}\n\t\tthis._producers = new Map();\n\n\t\t// Map of Peers indexed by name.\n\t\t// @type {map<String, Peer>}\n\t\tthis._peers = new Map();\n\n\t\t// Extended RTP capabilities.\n\t\t// @type {Object}\n\t\tthis._extendedRtpCapabilities = null;\n\n\t\t// Whether we can send audio/video based on computed extended RTP\n\t\t// capabilities.\n\t\t// @type {Object}\n\t\tthis._canSendByKind =\n\t\t{\n\t\t\taudio : false,\n\t\t\tvideo : false\n\t\t};\n\t}\n\n\t/**\n\t * Whether the Room is joined.\n\t *\n\t * @return {Boolean}\n\t */\n\tget joined()\n\t{\n\t\treturn this._state === RoomState.joined;\n\t}\n\n\t/**\n\t * Whether the Room is closed.\n\t *\n\t * @return {Boolean}\n\t */\n\tget closed()\n\t{\n\t\treturn this._state === RoomState.closed;\n\t}\n\n\t/**\n\t * My mediasoup Peer name.\n\t *\n\t * @return {String}\n\t */\n\tget peerName()\n\t{\n\t\treturn this._peerName;\n\t}\n\n\t/**\n\t * The list of Transports.\n\t *\n\t * @return {Array<Transport>}\n\t */\n\tget transports()\n\t{\n\t\treturn Array.from(this._transports.values());\n\t}\n\n\t/**\n\t * The list of Producers.\n\t *\n\t * @return {Array<Producer>}\n\t */\n\tget producers()\n\t{\n\t\treturn Array.from(this._producers.values());\n\t}\n\n\t/**\n\t * The list of Peers.\n\t *\n\t * @return {Array<Peer>}\n\t */\n\tget peers()\n\t{\n\t\treturn Array.from(this._peers.values());\n\t}\n\n\t/**\n\t * Get the Transport with the given id.\n\t *\n\t * @param {Number} id\n\t *\n\t * @return {Transport}\n\t */\n\tgetTransportById(id)\n\t{\n\t\treturn this._transports.get(id);\n\t}\n\n\t/**\n\t * Get the Producer with the given id.\n\t *\n\t * @param {Number} id\n\t *\n\t * @return {Producer}\n\t */\n\tgetProducerById(id)\n\t{\n\t\treturn this._producers.get(id);\n\t}\n\n\t/**\n\t * Get the Peer with the given name.\n\t *\n\t * @param {String} name\n\t *\n\t * @return {Peer}\n\t */\n\tgetPeerByName(name)\n\t{\n\t\treturn this._peers.get(name);\n\t}\n\n\t/**\n\t * Start the procedures to join a remote room.\n\t * @param {String} peerName - My mediasoup Peer name.\n\t * @param {Any} [appData] - App custom data.\n\t * @return {Promise}\n\t */\n\tjoin(peerName, appData)\n\t{\n\t\tlogger.debug('join() [peerName:\"%s\"]', peerName);\n\n\t\tif (typeof peerName !== 'string')\n\t\t\treturn Promise.reject(new TypeError('invalid peerName'));\n\n\t\tif (this._state !== RoomState.new && this._state !== RoomState.closed)\n\t\t{\n\t\t\treturn Promise.reject(\n\t\t\t\tnew _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"](`invalid state \"${this._state}\"`));\n\t\t}\n\n\t\tthis._peerName = peerName;\n\t\tthis._state = RoomState.joining;\n\n\t\tlet roomSettings;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// If Room settings are provided don't query them.\n\t\t\t\tif (this._settings.roomSettings)\n\t\t\t\t{\n\t\t\t\t\troomSettings = this._settings.roomSettings;\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn this._sendRequest('queryRoom', { target: 'room' })\n\t\t\t\t\t\t.then((response) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\troomSettings = response;\n\n\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t'join() | got Room settings:%o', roomSettings);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn _Device__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Handler.getNativeRtpCapabilities();\n\t\t\t})\n\t\t\t.then((nativeRtpCapabilities) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'join() | native RTP capabilities:%o', nativeRtpCapabilities);\n\n\t\t\t\t// Get extended RTP capabilities.\n\t\t\t\tthis._extendedRtpCapabilities = _ortc__WEBPACK_IMPORTED_MODULE_3__[\"getExtendedRtpCapabilities\"](\n\t\t\t\t\tnativeRtpCapabilities, roomSettings.rtpCapabilities);\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'join() | extended RTP capabilities:%o', this._extendedRtpCapabilities);\n\n\t\t\t\t// Check unsupported codecs.\n\t\t\t\tconst unsupportedRoomCodecs = _ortc__WEBPACK_IMPORTED_MODULE_3__[\"getUnsupportedCodecs\"](\n\t\t\t\t\troomSettings.rtpCapabilities,\n\t\t\t\t\troomSettings.mandatoryCodecPayloadTypes,\n\t\t\t\t\tthis._extendedRtpCapabilities);\n\n\t\t\t\tif (unsupportedRoomCodecs.length > 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'%s mandatory room codecs not supported:%o',\n\t\t\t\t\t\tunsupportedRoomCodecs.length,\n\t\t\t\t\t\tunsupportedRoomCodecs);\n\n\t\t\t\t\tthrow new _errors__WEBPACK_IMPORTED_MODULE_2__[\"UnsupportedError\"](\n\t\t\t\t\t\t'mandatory room codecs not supported', unsupportedRoomCodecs);\n\t\t\t\t}\n\n\t\t\t\t// Check whether we can send audio/video.\n\t\t\t\tthis._canSendByKind.audio =\n\t\t\t\t\t_ortc__WEBPACK_IMPORTED_MODULE_3__[\"canSend\"]('audio', this._extendedRtpCapabilities);\n\t\t\t\tthis._canSendByKind.video =\n\t\t\t\t\t_ortc__WEBPACK_IMPORTED_MODULE_3__[\"canSend\"]('video', this._extendedRtpCapabilities);\n\n\t\t\t\t// Generate our effective RTP capabilities for receiving media.\n\t\t\t\tconst effectiveLocalRtpCapabilities =\n\t\t\t\t\t_ortc__WEBPACK_IMPORTED_MODULE_3__[\"getRtpCapabilities\"](this._extendedRtpCapabilities);\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'join() | effective local RTP capabilities for receiving:%o',\n\t\t\t\t\teffectiveLocalRtpCapabilities);\n\n\t\t\t\tconst data =\n\t\t\t\t{\n\t\t\t\t\ttarget          : 'room',\n\t\t\t\t\tpeerName        : this._peerName,\n\t\t\t\t\trtpCapabilities : effectiveLocalRtpCapabilities,\n\t\t\t\t\tspy             : this._settings.spy,\n\t\t\t\t\tappData         : appData\n\t\t\t\t};\n\n\t\t\t\treturn this._sendRequest('join', data)\n\t\t\t\t\t.then((response) => response.peers);\n\t\t\t})\n\t\t\t.then((peers) =>\n\t\t\t{\n\t\t\t\t// Handle Peers already existing in the room.\n\t\t\t\tfor (const peerData of peers || [])\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._handlePeerData(peerData);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (error)\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.error('join() | error handling Peer:%o', error);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._state = RoomState.joined;\n\n\t\t\t\tlogger.debug('join() | joined the Room');\n\n\t\t\t\t// Return the list of already existing Peers.\n\t\t\t\treturn this.peers;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tthis._state = RoomState.new;\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\t/**\n\t * Leave the Room.\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tleave(appData)\n\t{\n\t\tlogger.debug('leave()');\n\n\t\tif (this.closed)\n\t\t\treturn;\n\n\t\t// Send a notification.\n\t\tthis._sendNotification('leave', { appData });\n\n\t\t// Set closed state after sending the notification (otherwise the\n\t\t// notification won't be sent).\n\t\tthis._state = RoomState.closed;\n\n\t\tthis.safeEmit('close', 'local', appData);\n\n\t\t// Close all the Transports.\n\t\tfor (const transport of this._transports.values())\n\t\t{\n\t\t\ttransport.close();\n\t\t}\n\n\t\t// Close all the Producers.\n\t\tfor (const producer of this._producers.values())\n\t\t{\n\t\t\tproducer.close();\n\t\t}\n\n\t\t// Close all the Peers.\n\t\tfor (const peer of this._peers.values())\n\t\t{\n\t\t\tpeer.close();\n\t\t}\n\t}\n\n\t/**\n\t * The remote Room was closed or our remote Peer has been closed.\n\t * Invoked via remote notification or via API.\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tremoteClose(appData)\n\t{\n\t\tlogger.debug('remoteClose()');\n\n\t\tif (this.closed)\n\t\t\treturn;\n\n\t\tthis._state = RoomState.closed;\n\n\t\tthis.safeEmit('close', 'remote', appData);\n\n\t\t// Close all the Transports.\n\t\tfor (const transport of this._transports.values())\n\t\t{\n\t\t\ttransport.remoteClose(null, { destroy: true });\n\t\t}\n\n\t\t// Close all the Producers.\n\t\tfor (const producer of this._producers.values())\n\t\t{\n\t\t\tproducer.remoteClose();\n\t\t}\n\n\t\t// Close all the Peers.\n\t\tfor (const peer of this._peers.values())\n\t\t{\n\t\t\tpeer.remoteClose();\n\t\t}\n\t}\n\n\t/**\n\t * Whether we can send audio/video.\n\t *\n\t * @param {String} kind - 'audio' or 'video'.\n\t *\n\t * @return {Boolean}\n\t */\n\tcanSend(kind)\n\t{\n\t\tif (kind !== 'audio' && kind !== 'video')\n\t\t\tthrow new TypeError(`invalid kind \"${kind}\"`);\n\n\t\tif (!this.joined || this._settings.spy)\n\t\t\treturn false;\n\n\t\treturn this._canSendByKind[kind];\n\t}\n\n\t/**\n\t * Creates a Transport.\n\t *\n\t * @param {String} direction - Must be 'send' or 'recv'.\n\t * @param {Any} [appData] - App custom data.\n\t *\n\t * @return {Transport}\n\t *\n\t * @throws {InvalidStateError} if not joined.\n\t * @throws {TypeError} if wrong arguments.\n\t */\n\tcreateTransport(direction, appData)\n\t{\n\t\tlogger.debug('createTransport() [direction:%s]', direction);\n\n\t\tif (!this.joined)\n\t\t\tthrow new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"](`invalid state \"${this._state}\"`);\n\t\telse if (direction !== 'send' && direction !== 'recv')\n\t\t\tthrow new TypeError(`invalid direction \"${direction}\"`);\n\t\telse if (direction === 'send' && this._settings.spy)\n\t\t\tthrow new TypeError('a spy peer cannot send media to the room');\n\n\t\t// Create a new Transport.\n\t\tconst transport = new _Transport__WEBPACK_IMPORTED_MODULE_5__[\"default\"](\n\t\t\tdirection, this._extendedRtpCapabilities, this._settings, appData);\n\n\t\t// Store it.\n\t\tthis._transports.set(transport.id, transport);\n\n\t\ttransport.on('@request', (method, data, callback, errback) =>\n\t\t{\n\t\t\tthis._sendRequest(method, data)\n\t\t\t\t.then(callback)\n\t\t\t\t.catch(errback);\n\t\t});\n\n\t\ttransport.on('@notify', (method, data) =>\n\t\t{\n\t\t\tthis._sendNotification(method, data);\n\t\t});\n\n\t\ttransport.on('@close', () =>\n\t\t{\n\t\t\tthis._transports.delete(transport.id);\n\t\t});\n\n\t\treturn transport;\n\t}\n\n\t/**\n\t * Creates a Producer.\n\t *\n\t * @param {MediaStreamTrack} track\n\t * @param {Object} [options]\n\t * @param {Object} [options.simulcast]\n\t * @param {Any} [appData] - App custom data.\n\t *\n\t * @return {Producer}\n\t *\n\t * @throws {InvalidStateError} if not joined.\n\t * @throws {TypeError} if wrong arguments.\n\t * @throws {Error} if cannot send the given kindor we are a spy peer.\n\t */\n\tcreateProducer(track, options, appData)\n\t{\n\t\tlogger.debug('createProducer() [track:%o, options:%o]', track, options);\n\n\t\tif (!this.joined)\n\t\t\tthrow new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"](`invalid state \"${this._state}\"`);\n\t\telse if (this._settings.spy)\n\t\t\tthrow new Error('a spy peer cannot send media to the room');\n\t\telse if (!track)\n\t\t\tthrow new TypeError('no track given');\n\t\telse if (!this._canSendByKind[track.kind])\n\t\t\tthrow new Error(`cannot send ${track.kind}`);\n\t\telse if (track.readyState === 'ended')\n\t\t\tthrow new Error('track.readyState is \"ended\"');\n\n\t\toptions = options || {};\n\n\t\t// Create a new Producer.\n\t\tconst producer = new _Producer__WEBPACK_IMPORTED_MODULE_6__[\"default\"](track, options, appData);\n\n\t\t// Store it.\n\t\tthis._producers.set(producer.id, producer);\n\n\t\tproducer.on('@close', () =>\n\t\t{\n\t\t\tthis._producers.delete(producer.id);\n\t\t});\n\n\t\treturn producer;\n\t}\n\n\t/**\n\t * Produce a ICE restart in all the Transports.\n\t */\n\trestartIce(callback, errback)\n\t{\n\t\tif (!this.joined)\n\t\t{\n\t\t\tlogger.warn(`restartIce() | invalid state \"${this._state}\"`);\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const transport of this._transports.values())\n\t\t{\n\t\t\ttransport.restartIce(callback, errback);\n\t\t}\n\t}\n\n\t/**\n\t * Provide the local Room with a notification generated by mediasoup server.\n\t *\n\t * @param {Object} notification\n\t */\n\treceiveNotification(notification)\n\t{\n\t\tif (this.closed)\n\t\t\treturn Promise.reject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"]('Room closed'));\n\t\telse if (typeof notification !== 'object')\n\t\t\treturn Promise.reject(new TypeError('wrong notification Object'));\n\t\telse if (notification.notification !== true)\n\t\t\treturn Promise.reject(new TypeError('not a notification'));\n\t\telse if (typeof notification.method !== 'string')\n\t\t\treturn Promise.reject(new TypeError('wrong/missing notification method'));\n\n\t\tconst { method } = notification;\n\n\t\tif (method !== 'producerStats' && method !== 'consumerStats')\n\t\t{\n\t\t\tlogger.debug(\n\t\t\t\t'receiveNotification() [method:%s, notification:%o]',\n\t\t\t\tmethod, notification);\n\t\t}\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tswitch (method)\n\t\t\t\t{\n\t\t\t\t\tcase 'closed':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { appData } = notification;\n\n\t\t\t\t\t\tthis.remoteClose(appData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'transportClosed':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, appData } = notification;\n\t\t\t\t\t\tconst transport = this._transports.get(id);\n\n\t\t\t\t\t\tif (!transport)\n\t\t\t\t\t\t\tthrow new Error(`Transport not found [id:\"${id}\"]`);\n\n\t\t\t\t\t\ttransport.remoteClose(appData, { destroy: false });\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'transportStats':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, stats } = notification;\n\t\t\t\t\t\tconst transport = this._transports.get(id);\n\n\t\t\t\t\t\tif (!transport)\n\t\t\t\t\t\t\tthrow new Error(`Transport not found [id:${id}]`);\n\n\t\t\t\t\t\ttransport.remoteStats(stats);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'newPeer':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { name } = notification;\n\n\t\t\t\t\t\tif (this._peers.has(name))\n\t\t\t\t\t\t\tthrow new Error(`Peer already exists [name:\"${name}\"]`);\n\n\t\t\t\t\t\tconst peerData = notification;\n\n\t\t\t\t\t\tthis._handlePeerData(peerData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'peerClosed':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst peerName = notification.name;\n\t\t\t\t\t\tconst { appData } = notification;\n\t\t\t\t\t\tconst peer = this._peers.get(peerName);\n\n\t\t\t\t\t\tif (!peer)\n\t\t\t\t\t\t\tthrow new Error(`no Peer found [name:\"${peerName}\"]`);\n\n\t\t\t\t\t\tpeer.remoteClose(appData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'producerPaused':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, appData } = notification;\n\t\t\t\t\t\tconst producer = this._producers.get(id);\n\n\t\t\t\t\t\tif (!producer)\n\t\t\t\t\t\t\tthrow new Error(`Producer not found [id:${id}]`);\n\n\t\t\t\t\t\tproducer.remotePause(appData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'producerResumed':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, appData } = notification;\n\t\t\t\t\t\tconst producer = this._producers.get(id);\n\n\t\t\t\t\t\tif (!producer)\n\t\t\t\t\t\t\tthrow new Error(`Producer not found [id:${id}]`);\n\n\t\t\t\t\t\tproducer.remoteResume(appData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'producerClosed':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, appData } = notification;\n\t\t\t\t\t\tconst producer = this._producers.get(id);\n\n\t\t\t\t\t\tif (!producer)\n\t\t\t\t\t\t\tthrow new Error(`Producer not found [id:${id}]`);\n\n\t\t\t\t\t\tproducer.remoteClose(appData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'producerStats':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, stats } = notification;\n\t\t\t\t\t\tconst producer = this._producers.get(id);\n\n\t\t\t\t\t\tif (!producer)\n\t\t\t\t\t\t\tthrow new Error(`Producer not found [id:${id}]`);\n\n\t\t\t\t\t\tproducer.remoteStats(stats);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'newConsumer':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { peerName } = notification;\n\t\t\t\t\t\tconst peer = this._peers.get(peerName);\n\n\t\t\t\t\t\tif (!peer)\n\t\t\t\t\t\t\tthrow new Error(`no Peer found [name:\"${peerName}\"]`);\n\n\t\t\t\t\t\tconst consumerData = notification;\n\n\t\t\t\t\t\tthis._handleConsumerData(consumerData, peer);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'consumerClosed':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, peerName, appData } = notification;\n\t\t\t\t\t\tconst peer = this._peers.get(peerName);\n\n\t\t\t\t\t\tif (!peer)\n\t\t\t\t\t\t\tthrow new Error(`no Peer found [name:\"${peerName}\"]`);\n\n\t\t\t\t\t\tconst consumer = peer.getConsumerById(id);\n\n\t\t\t\t\t\tif (!consumer)\n\t\t\t\t\t\t\tthrow new Error(`Consumer not found [id:${id}]`);\n\n\t\t\t\t\t\tconsumer.remoteClose(appData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'consumerPaused':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, peerName, appData } = notification;\n\t\t\t\t\t\tconst peer = this._peers.get(peerName);\n\n\t\t\t\t\t\tif (!peer)\n\t\t\t\t\t\t\tthrow new Error(`no Peer found [name:\"${peerName}\"]`);\n\n\t\t\t\t\t\tconst consumer = peer.getConsumerById(id);\n\n\t\t\t\t\t\tif (!consumer)\n\t\t\t\t\t\t\tthrow new Error(`Consumer not found [id:${id}]`);\n\n\t\t\t\t\t\tconsumer.remotePause(appData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'consumerResumed':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, peerName, appData } = notification;\n\t\t\t\t\t\tconst peer = this._peers.get(peerName);\n\n\t\t\t\t\t\tif (!peer)\n\t\t\t\t\t\t\tthrow new Error(`no Peer found [name:\"${peerName}\"]`);\n\n\t\t\t\t\t\tconst consumer = peer.getConsumerById(id);\n\n\t\t\t\t\t\tif (!consumer)\n\t\t\t\t\t\t\tthrow new Error(`Consumer not found [id:${id}]`);\n\n\t\t\t\t\t\tconsumer.remoteResume(appData);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'consumerPreferredProfileSet':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, peerName, profile } = notification;\n\t\t\t\t\t\tconst peer = this._peers.get(peerName);\n\n\t\t\t\t\t\tif (!peer)\n\t\t\t\t\t\t\tthrow new Error(`no Peer found [name:\"${peerName}\"]`);\n\n\t\t\t\t\t\tconst consumer = peer.getConsumerById(id);\n\n\t\t\t\t\t\tif (!consumer)\n\t\t\t\t\t\t\tthrow new Error(`Consumer not found [id:${id}]`);\n\n\t\t\t\t\t\tconsumer.remoteSetPreferredProfile(profile);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'consumerEffectiveProfileChanged':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, peerName, profile } = notification;\n\t\t\t\t\t\tconst peer = this._peers.get(peerName);\n\n\t\t\t\t\t\tif (!peer)\n\t\t\t\t\t\t\tthrow new Error(`no Peer found [name:\"${peerName}\"]`);\n\n\t\t\t\t\t\tconst consumer = peer.getConsumerById(id);\n\n\t\t\t\t\t\tif (!consumer)\n\t\t\t\t\t\t\tthrow new Error(`Consumer not found [id:${id}]`);\n\n\t\t\t\t\t\tconsumer.remoteEffectiveProfileChanged(profile);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase 'consumerStats':\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { id, peerName, stats } = notification;\n\t\t\t\t\t\tconst peer = this._peers.get(peerName);\n\n\t\t\t\t\t\tif (!peer)\n\t\t\t\t\t\t\tthrow new Error(`no Peer found [name:\"${peerName}\"]`);\n\n\t\t\t\t\t\tconst consumer = peer.getConsumerById(id);\n\n\t\t\t\t\t\tif (!consumer)\n\t\t\t\t\t\t\tthrow new Error(`Consumer not found [id:${id}]`);\n\n\t\t\t\t\t\tconsumer.remoteStats(stats);\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`unknown notification method \"${method}\"`);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tlogger.error(\n\t\t\t\t\t'receiveNotification() failed [notification:%o]: %s', notification, error);\n\t\t\t});\n\t}\n\n\t_sendRequest(method, data)\n\t{\n\t\tconst request = Object.assign({ method, target: 'peer' }, data);\n\n\t\t// Should never happen.\n\t\t// Ignore if closed.\n\t\tif (this.closed)\n\t\t{\n\t\t\tlogger.error(\n\t\t\t\t'_sendRequest() | Room closed [method:%s, request:%o]',\n\t\t\t\tmethod, request);\n\n\t\t\treturn Promise.reject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"]('Room closed'));\n\t\t}\n\n\t\tlogger.debug('_sendRequest() [method:%s, request:%o]', method, request);\n\n\t\treturn new Promise((resolve, reject) =>\n\t\t{\n\t\t\tlet done = false;\n\n\t\t\tconst timer = setTimeout(() =>\n\t\t\t{\n\t\t\t\tlogger.error(\n\t\t\t\t\t'request failed [method:%s]: timeout', method);\n\n\t\t\t\tdone = true;\n\t\t\t\treject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"TimeoutError\"]('timeout'));\n\t\t\t}, this._settings.requestTimeout);\n\n\t\t\tconst callback = (response) =>\n\t\t\t{\n\t\t\t\tif (done)\n\t\t\t\t\treturn;\n\n\t\t\t\tdone = true;\n\t\t\t\tclearTimeout(timer);\n\n\t\t\t\tif (this.closed)\n\t\t\t\t{\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'request failed [method:%s]: Room closed', method);\n\n\t\t\t\t\treject(new Error('Room closed'));\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'request succeeded [method:%s, response:%o]', method, response);\n\n\t\t\t\tresolve(response);\n\t\t\t};\n\n\t\t\tconst errback = (error) =>\n\t\t\t{\n\t\t\t\tif (done)\n\t\t\t\t\treturn;\n\n\t\t\t\tdone = true;\n\t\t\t\tclearTimeout(timer);\n\n\t\t\t\tif (this.closed)\n\t\t\t\t{\n\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t'request failed [method:%s]: Room closed', method);\n\n\t\t\t\t\treject(new Error('Room closed'));\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Make sure message is an Error.\n\t\t\t\tif (!(error instanceof Error))\n\t\t\t\t\terror = new Error(String(error));\n\n\t\t\t\tlogger.error('request failed [method:%s]:%o', method, error);\n\n\t\t\t\treject(error);\n\t\t\t};\n\n\t\t\tthis.safeEmit('request', request, callback, errback);\n\t\t});\n\t}\n\n\t_sendNotification(method, data)\n\t{\n\t\t// Ignore if closed.\n\t\tif (this.closed)\n\t\t\treturn;\n\n\t\tconst notification =\n\t\t\tObject.assign({ method, target: 'peer', notification: true }, data);\n\n\t\tlogger.debug(\n\t\t\t'_sendNotification() [method:%s, notification:%o]', method, notification);\n\n\t\tthis.safeEmit('notify', notification);\n\t}\n\n\t_handlePeerData(peerData)\n\t{\n\t\tconst { name, consumers, appData } = peerData;\n\t\tconst peer = new _Peer__WEBPACK_IMPORTED_MODULE_7__[\"default\"](name, appData);\n\n\t\t// Store it.\n\t\tthis._peers.set(peer.name, peer);\n\n\t\tpeer.on('@close', () =>\n\t\t{\n\t\t\tthis._peers.delete(peer.name);\n\t\t});\n\n\t\t// Add consumers.\n\t\tfor (const consumerData of consumers)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis._handleConsumerData(consumerData, peer);\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tlogger.error('error handling existing Consumer in Peer:%o', error);\n\t\t\t}\n\t\t}\n\n\t\t// If already joined emit event.\n\t\tif (this.joined)\n\t\t\tthis.safeEmit('newpeer', peer);\n\t}\n\n\t_handleConsumerData(producerData, peer)\n\t{\n\t\tconst { id, kind, rtpParameters, paused, appData } = producerData;\n\t\tconst consumer = new _Consumer__WEBPACK_IMPORTED_MODULE_8__[\"default\"](id, kind, rtpParameters, peer, appData);\n\t\tconst supported =\n\t\t\t_ortc__WEBPACK_IMPORTED_MODULE_3__[\"canReceive\"](consumer.rtpParameters, this._extendedRtpCapabilities);\n\n\t\tif (supported)\n\t\t\tconsumer.setSupported(true);\n\n\t\tif (paused)\n\t\t\tconsumer.remotePause();\n\n\t\tpeer.addConsumer(consumer);\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/Room.js?");

/***/ }),

/***/ "./lib/mslib/Transport.js":
/*!********************************!*\
  !*** ./lib/mslib/Transport.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Transport; });\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"./lib/mslib/errors.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _Device__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Device */ \"./lib/mslib/Device.js\");\n/* harmony import */ var _CommandQueue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./CommandQueue */ \"./lib/mslib/CommandQueue.js\");\n\n\n\n\n\n\n\nconst DEFAULT_STATS_INTERVAL = 1000;\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('Transport');\n\nclass Transport extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n{\n\t/**\n\t * @private\n\t *\n\t * @emits {state: String} connectionstatechange\n\t * @emits {stats: Object} stats\n\t * @emits {originator: String, [appData]: Any} close\n\t *\n\t * @emits {method: String, [data]: Object, callback: Function, errback: Function} @request\n\t * @emits {method: String, [data]: Object} @notify\n\t * @emits @close\n\t */\n\tconstructor(direction, extendedRtpCapabilities, settings, appData)\n\t{\n\t\tsuper(logger);\n\n\t\tlogger.debug('constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\t// Id.\n\t\t// @type {Number}\n\t\tthis._id = _utils__WEBPACK_IMPORTED_MODULE_3__[\"randomNumber\"]();\n\n\t\t// Closed flag.\n\t\t// @type {Boolean}\n\t\tthis._closed = false;\n\n\t\t// Direction.\n\t\t// @type {String}\n\t\tthis._direction = direction;\n\n\t\t// Room settings.\n\t\t// @type {Object}\n\t\tthis._settings = settings;\n\n\t\t// App custom data.\n\t\t// @type {Any}\n\t\tthis._appData = appData;\n\n\t\t// Periodic stats flag.\n\t\t// @type {Boolean}\n\t\tthis._statsEnabled = false;\n\n\t\t// Commands handler.\n\t\t// @type {CommandQueue}\n\t\tthis._commandQueue = new _CommandQueue__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n\n\t\t// Device specific handler.\n\t\tthis._handler = new _Device__WEBPACK_IMPORTED_MODULE_4__[\"default\"].Handler(direction, extendedRtpCapabilities, settings);\n\n\t\t// Transport state. Values can be:\n\t\t// 'new'/'connecting'/'connected'/'failed'/'disconnected'/'closed'\n\t\t// @type {String}\n\t\tthis._connectionState = 'new';\n\n        // Distinct audio and video kind for sending meidaStream(consists of audio and video) convenience.\n        // @type {Boolean}\n        this._audioSent = false; // is sent of this transport by audio track.\n\n        // @type {Boolean}\n        this._videoSent = false; // is sent of this transport by video track.\n\n\t\tthis._commandQueue.on('exec', this._execCommand.bind(this));\n\n\t\tthis._handleHandler();\n\t}\n\n\t/**\n\t * Transport id.\n\t *\n\t * @return {Number}\n\t */\n\tget id()\n\t{\n\t\treturn this._id;\n\t}\n\n\t/**\n\t * Whether the Transport is closed.\n\t *\n\t * @return {Boolean}\n\t */\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\t/**\n\t * Transport direction.\n\t *\n\t * @return {String}\n\t */\n\tget direction()\n\t{\n\t\treturn this._direction;\n\t}\n\n\t/**\n\t * App custom data.\n\t *\n\t * @return {Any}\n\t */\n\tget appData()\n\t{\n\t\treturn this._appData;\n\t}\n\n\t/**\n\t * Connection state.\n\t *\n\t * @return {String}\n\t */\n\tget connectionState()\n\t{\n\t\treturn this._connectionState;\n\t}\n\n\t/**\n\t * Device handler.\n\t *\n\t * @return {Handler}\n\t */\n\tget handler()\n\t{\n\t\treturn this._handler;\n\t}\n\n\t/**\n\t * Close the Transport.\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t */\n\tclose(appData)\n\t{\n\t\tlogger.debug('close()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._closed = true;\n\n        this._audioSent = false;\n        this._videoSent = false;\n\n\t\tif (this._statsEnabled)\n\t\t{\n\t\t\tthis._statsEnabled = false;\n\t\t\tthis.disableStats();\n\t\t}\n\n\t\tthis.safeEmit(\n\t\t\t'@notify', 'closeTransport', { id: this._id, appData });\n\n\t\tthis.emit('@close');\n\t\tthis.safeEmit('close', 'local', appData);\n\n\t\tthis._destroy();\n\t}\n\n\t/**\n\t * My remote Transport was closed.\n\t * Invoked via remote notification.\n\t *\n\t * @private\n\t *\n\t * @param {Any} [appData] - App custom data.\n\t * @param {Object} destroy - Whether the local transport must be destroyed.\n\t */\n\tremoteClose(appData, { destroy })\n\t{\n\t\tlogger.debug('remoteClose() [destroy:%s]', destroy);\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tif (!destroy)\n\t\t{\n\t\t\tthis._handler.remoteClosed();\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis._closed = true;\n        this._audioSent = false;\n        this._videoSent = false;\n\n\t\tthis.emit('@close');\n\t\tthis.safeEmit('close', 'remote', appData);\n\n\t\tthis._destroy();\n\t}\n\n\t_destroy()\n\t{\n\t\t// Close the CommandQueue.\n\t\tthis._commandQueue.close();\n\n\t\t// Close the handler.\n\t\tthis._handler.close();\n\t}\n\n\trestartIce(callback, errback)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\t\telse if (this._connectionState === 'new')\n\t\t\treturn;\n\n\t\tPromise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst data =\n\t\t\t\t{\n\t\t\t\t\tid : this._id\n\t\t\t\t};\n\n\t\t\t\treturn this.safeEmitAsPromise('@request', 'restartTransport', data);\n\t\t\t})\n\t\t\t.then((response) =>\n\t\t\t{\n\t\t\t\tconst remoteIceParameters = response.iceParameters;\n\n\t\t\t\t// Enqueue command.\n\t\t\t\treturn this._commandQueue.push('restartIce', { remoteIceParameters });\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\tif (errback)\n\t\t\t\t{\n\t\t\t\t\terrback(error);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlogger.error('restartIce() | failed: %o', error);\n\t\t\t});\n\t}\n\n\tenableStats(interval = DEFAULT_STATS_INTERVAL)\n\t{\n\t\tlogger.debug('enableStats() [interval:%s]', interval);\n\n\t\tif (typeof interval !== 'number' || interval < 1000)\n\t\t\tinterval = DEFAULT_STATS_INTERVAL;\n\n\t\tthis._statsEnabled = true;\n\n\t\tconst data =\n\t\t{\n\t\t\tid       : this._id,\n\t\t\tinterval : interval\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'enableTransportStats', data);\n\t}\n\n\tdisableStats()\n\t{\n\t\tlogger.debug('disableStats()');\n\n\t\tthis._statsEnabled = false;\n\n\t\tconst data =\n\t\t{\n\t\t\tid : this._id\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'disableTransportStats', data);\n\t}\n\n\t_handleHandler()\n\t{\n\t\tconst handler = this._handler;\n\n\t\thandler.on('@connectionstatechange', (state) =>\n\t\t{\n\t\t\tif (this._connectionState === state)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('Transport connection state changed to %s', state);\n\n\t\t\tthis._connectionState = state;\n\n\t\t\tif (!this._closed)\n\t\t\t\tthis.safeEmit('connectionstatechange', state);\n\t\t});\n\n\t\thandler.on(\n\t\t\t'@needcreatetransport',\n\t\t\t(transportLocalParameters, callback, errback) =>\n\t\t\t{\n\t\t\t\tconst data =\n\t\t\t\t{\n\t\t\t\t\tid        : this._id,\n\t\t\t\t\tdirection : this._direction,\n\t\t\t\t\toptions   : this._settings.transportOptions,\n\t\t\t\t\tappData   : this._appData\n\t\t\t\t};\n\n\t\t\t\tif (transportLocalParameters)\n\t\t\t\t{\n\t\t\t\t\tif (transportLocalParameters.dtlsParameters)\n\t\t\t\t\t\tdata.dtlsParameters = transportLocalParameters.dtlsParameters;\n\n\t\t\t\t\telse if (transportLocalParameters.plainRtpParameters)\n\t\t\t\t\t\tdata.plainRtpParameters = transportLocalParameters.plainRtpParameters;\n\t\t\t\t}\n\n\t\t\t\tthis.safeEmit('@request', 'createTransport', data, callback, errback);\n\t\t\t});\n\n\t\thandler.on('@needupdatetransport', (transportLocalParameters) =>\n\t\t{\n\t\t\tconst data =\n\t\t\t{\n\t\t\t\tid : this._id\n\t\t\t};\n\n\t\t\tif (transportLocalParameters)\n\t\t\t{\n\t\t\t\tif (transportLocalParameters.dtlsParameters)\n\t\t\t\t\tdata.dtlsParameters = transportLocalParameters.dtlsParameters;\n\n\t\t\t\telse if (transportLocalParameters.plainRtpParameters)\n\t\t\t\t\tdata.plainRtpParameters = transportLocalParameters.plainRtpParameters;\n\t\t\t}\n\n\t\t\tthis.safeEmit('@notify', 'updateTransport', data);\n\t\t});\n\n\t\thandler.on('@needupdateproducer', (producer, rtpParameters) =>\n\t\t{\n\t\t\tconst data =\n\t\t\t{\n\t\t\t\tid            : producer.id,\n\t\t\t\trtpParameters : rtpParameters\n\t\t\t};\n\n\t\t\t// Update Producer RTP parameters.\n\t\t\tproducer.setRtpParameters(rtpParameters);\n\n\t\t\t// Notify the server.\n\t\t\tthis.safeEmit('@notify', 'updateProducer', data);\n\t\t});\n\t}\n\n\t/**\n\t * Send the given Producer over this Transport.\n\t *\n\t * @private\n\t *\n\t * @param {Producer} producer\n\t *\n\t * @return {Promise}\n\t */\n\taddProducer(producer)\n\t{\n\t\tlogger.debug('addProducer() [producer:%o]', producer);\n\n\t\tif (this._closed)\n\t\t\treturn Promise.reject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"]('Transport closed'));\n\t\telse if (this._direction !== 'send')\n\t\t\treturn Promise.reject(new Error('not a sending Transport'));\n\n\t\t// Enqueue command.\n\t\treturn this._commandQueue.push('addProducer', { producer });\n\t}\n\n\t/**\n\t * @private\n\t */\n\tremoveProducer(producer, originator, appData)\n\t{\n\t\tlogger.debug('removeProducer() [producer:%o]', producer);\n\n\t\t// Enqueue command.\n\t\tif (!this._closed)\n\t\t{\n\t\t\tthis._commandQueue.push('removeProducer', { producer })\n\t\t\t\t.catch(() => {});\n\t\t}\n\n\t\tif (originator === 'local')\n\t\t\tthis.safeEmit('@notify', 'closeProducer', { id: producer.id, appData });\n\t}\n\n\t/**\n\t * @private\n\t */\n\tpauseProducer(producer, appData)\n\t{\n\t\tlogger.debug('pauseProducer() [producer:%o]', producer);\n\n\t\tconst data =\n\t\t{\n\t\t\tid      : producer.id,\n\t\t\tappData : appData\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'pauseProducer', data);\n\t}\n\n\t/**\n\t * @private\n\t */\n\tresumeProducer(producer, appData)\n\t{\n\t\tlogger.debug('resumeProducer() [producer:%o]', producer);\n\n\t\tconst data =\n\t\t{\n\t\t\tid      : producer.id,\n\t\t\tappData : appData\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'resumeProducer', data);\n\t}\n\n\t/**\n\t * @private\n\t *\n\t * @return {Promise}\n\t */\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug('replaceProducerTrack() [producer:%o]', producer);\n\n\t\treturn this._commandQueue.push(\n\t\t\t'replaceProducerTrack', { producer, track });\n\t}\n\n\t/**\n\t * @private\n\t */\n\tenableProducerStats(producer, interval)\n\t{\n\t\tlogger.debug('enableProducerStats() [producer:%o]', producer);\n\n\t\tconst data =\n\t\t{\n\t\t\tid       : producer.id,\n\t\t\tinterval : interval\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'enableProducerStats', data);\n\t}\n\n\t/**\n\t * @private\n\t */\n\tdisableProducerStats(producer)\n\t{\n\t\tlogger.debug('disableProducerStats() [producer:%o]', producer);\n\n\t\tconst data =\n\t\t{\n\t\t\tid : producer.id\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'disableProducerStats', data);\n\t}\n\n\t/**\n\t * Receive the given Consumer over this Transport.\n\t *\n\t * @private\n\t *\n\t * @param {Consumer} consumer\n\t *\n\t * @return {Promise} Resolves to a remote MediaStreamTrack.\n\t */\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug('addConsumer() [consumer:%o]', consumer);\n\n\t\tif (this._closed)\n\t\t\treturn Promise.reject(new _errors__WEBPACK_IMPORTED_MODULE_2__[\"InvalidStateError\"]('Transport closed'));\n\t\telse if (this._direction !== 'recv')\n\t\t\treturn Promise.reject(new Error('not a receiving Transport'));\n\n\t\t// Enqueue command.\n\t\treturn this._commandQueue.push('addConsumer', { consumer });\n\t}\n\n\t/**\n\t * @private\n\t */\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug('removeConsumer() [consumer:%o]', consumer);\n\n\t\t// Enqueue command.\n\t\tthis._commandQueue.push('removeConsumer', { consumer })\n\t\t\t.catch(() => {});\n\t}\n\n\t/**\n\t * @private\n\t */\n\tpauseConsumer(consumer, appData)\n\t{\n\t\tlogger.debug('pauseConsumer() [consumer:%o]', consumer);\n\n\t\tconst data =\n\t\t{\n\t\t\tid      : consumer.id,\n\t\t\tappData : appData\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'pauseConsumer', data);\n\t}\n\n\t/**\n\t * @private\n\t */\n\tresumeConsumer(consumer, appData)\n\t{\n\t\tlogger.debug('resumeConsumer() [consumer:%o]', consumer);\n\n\t\tconst data =\n\t\t{\n\t\t\tid      : consumer.id,\n\t\t\tappData : appData\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'resumeConsumer', data);\n\t}\n\n\t/**\n\t * @private\n\t */\n\tsetConsumerPreferredProfile(consumer, profile)\n\t{\n\t\tlogger.debug('setConsumerPreferredProfile() [consumer:%o]', consumer);\n\n\t\tconst data =\n\t\t{\n\t\t\tid      : consumer.id,\n\t\t\tprofile : profile\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'setConsumerPreferredProfile', data);\n\t}\n\n\t/**\n\t * @private\n\t */\n\tenableConsumerStats(consumer, interval)\n\t{\n\t\tlogger.debug('enableConsumerStats() [consumer:%o]', consumer);\n\n\t\tconst data =\n\t\t{\n\t\t\tid       : consumer.id,\n\t\t\tinterval : interval\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'enableConsumerStats', data);\n\t}\n\n\t/**\n\t * @private\n\t */\n\tdisableConsumerStats(consumer)\n\t{\n\t\tlogger.debug('disableConsumerStats() [consumer:%o]', consumer);\n\n\t\tconst data =\n\t\t{\n\t\t\tid : consumer.id\n\t\t};\n\n\t\tthis.safeEmit('@notify', 'disableConsumerStats', data);\n\t}\n\n\t/**\n\t * Receive remote stats.\n\t *\n\t * @private\n\t *\n\t * @param {Object} stats\n\t */\n\tremoteStats(stats)\n\t{\n\t\tthis.safeEmit('stats', stats);\n\t}\n\n    /**\n     * Get handler stats.\n     *\n     * @public\n     *\n     * @param {Object} selector\n     */\n    getStats(selector)\n\t{\n        return this._handler.getPCStats(selector);\n    }\n\n    removeTrack(track)\n\t{\n        return this._handler.removeTrack(track);\n    }\n\n    audioSent()\n\t{\n        return this._audioSent;\n    }\n\n    videoSent()\n\t{\n        return this._videoSent;\n    }\n\n    updateTrack(producer, track)\n\t{\n        return this._handler.updateTrack(producer, track);\n    }\n\n\t_execCommand(command, promiseHolder)\n\t{\n\t\tlet promise;\n\n\t\ttry\n\t\t{\n\t\t\tswitch (command.method)\n\t\t\t{\n\t\t\t\tcase 'addProducer':\n\t\t\t\t{\n\t\t\t\t\tconst { producer } = command;\n\n\t\t\t\t\tpromise = this._execAddProducer(producer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 'removeProducer':\n\t\t\t\t{\n\t\t\t\t\tconst { producer } = command;\n\n\t\t\t\t\tpromise = this._execRemoveProducer(producer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 'replaceProducerTrack':\n\t\t\t\t{\n\t\t\t\t\tconst { producer, track } = command;\n\n\t\t\t\t\tpromise = this._execReplaceProducerTrack(producer, track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 'addConsumer':\n\t\t\t\t{\n\t\t\t\t\tconst { consumer } = command;\n\n\t\t\t\t\tpromise = this._execAddConsumer(consumer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 'removeConsumer':\n\t\t\t\t{\n\t\t\t\t\tconst { consumer } = command;\n\n\t\t\t\t\tpromise = this._execRemoveConsumer(consumer);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcase 'restartIce':\n\t\t\t\t{\n\t\t\t\t\tconst { remoteIceParameters } = command;\n\n\t\t\t\t\tpromise = this._execRestartIce(remoteIceParameters);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t{\n\t\t\t\t\tpromise = Promise.reject(\n\t\t\t\t\t\tnew Error(`unknown command method \"${command.method}\"`));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tpromise = Promise.reject(error);\n\t\t}\n\n\t\t// Fill the given Promise holder.\n\t\tpromiseHolder.promise = promise;\n\t}\n\n\t_execAddProducer(producer)\n\t{\n\t\tlogger.debug('_execAddProducer()');\n\n\t\tlet producerRtpParameters;\n\n\t\t// Call the handler.\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._handler.addProducer(producer);\n\t\t\t})\n\t\t\t.then((rtpParameters) =>\n\t\t\t{\n\t\t\t\tproducerRtpParameters = rtpParameters;\n\n\t\t\t\tconst data =\n\t\t\t\t{\n\t\t\t\t\tid            : producer.id,\n\t\t\t\t\tkind          : producer.kind,\n\t\t\t\t\ttransportId   : this._id,\n\t\t\t\t\trtpParameters : rtpParameters,\n\t\t\t\t\tpaused        : producer.locallyPaused,\n\t\t\t\t\tappData       : producer.appData\n\t\t\t\t};\n\n\t\t\t\treturn this.safeEmitAsPromise('@request', 'createProducer', data);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tproducer.setRtpParameters(producerRtpParameters);\n\t\t\t});\n\t}\n\n\t_execRemoveProducer(producer)\n\t{\n\t\tlogger.debug('_execRemoveProducer()');\n\n\t\t// Call the handler.\n\t\treturn this._handler.removeProducer(producer);\n\t}\n\n\t_execReplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug('_execReplaceProducerTrack()');\n\n\t\t// Call the handler.\n\t\treturn this._handler.replaceProducerTrack(producer, track);\n\t}\n\n\t_execAddConsumer(consumer)\n\t{\n\t\tlogger.debug('_execAddConsumer()');\n\n\t\tlet consumerTrack;\n\n\t\t// Call the handler.\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._handler.addConsumer(consumer);\n\t\t\t})\n\t\t\t.then((track) =>\n\t\t\t{\n\t\t\t\tconsumerTrack = track;\n\n\t\t\t\tconst data =\n\t\t\t\t{\n\t\t\t\t\tid               : consumer.id,\n\t\t\t\t\ttransportId      : this.id,\n\t\t\t\t\tpaused           : consumer.locallyPaused,\n\t\t\t\t\tpreferredProfile : consumer.preferredProfile\n\t\t\t\t};\n\n\t\t\t\treturn this.safeEmitAsPromise('@request', 'enableConsumer', data);\n\t\t\t})\n\t\t\t.then((response) =>\n\t\t\t{\n\t\t\t\tconst { paused, preferredProfile, effectiveProfile } = response;\n\n\t\t\t\tif (paused)\n\t\t\t\t\tconsumer.remotePause();\n\n\t\t\t\tif (preferredProfile)\n\t\t\t\t\tconsumer.remoteSetPreferredProfile(preferredProfile);\n\n\t\t\t\tif (effectiveProfile)\n\t\t\t\t\tconsumer.remoteEffectiveProfileChanged(effectiveProfile);\n\n\t\t\t\treturn consumerTrack;\n\t\t\t});\n\t}\n\n\t_execRemoveConsumer(consumer)\n\t{\n\t\tlogger.debug('_execRemoveConsumer()');\n\n\t\t// Call the handler.\n\t\treturn this._handler.removeConsumer(consumer);\n\t}\n\n\t_execRestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('_execRestartIce()');\n\n\t\t// Call the handler.\n\t\treturn this._handler.restartIce(remoteIceParameters);\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/Transport.js?");

/***/ }),

/***/ "./lib/mslib/errors.js":
/*!*****************************!*\
  !*** ./lib/mslib/errors.js ***!
  \*****************************/
/*! exports provided: InvalidStateError, TimeoutError, UnsupportedError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InvalidStateError\", function() { return InvalidStateError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeoutError\", function() { return TimeoutError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsupportedError\", function() { return UnsupportedError; });\n/**\n * Error produced when calling a method in an invalid state.\n */\nclass InvalidStateError extends Error\n{\n\tconstructor(message)\n\t{\n\t\tsuper(message);\n\n\t\tthis.name = 'InvalidStateError';\n\n\t\tif (Error.hasOwnProperty('captureStackTrace')) // Just in V8.\n\t\t\tError.captureStackTrace(this, InvalidStateError);\n\t\telse\n\t\t\tthis.stack = (new Error(message)).stack;\n\t}\n}\n\n/**\n * Error produced when a Promise is rejected due to a timeout.\n */\nclass TimeoutError extends Error\n{\n\tconstructor(message)\n\t{\n\t\tsuper(message);\n\n\t\tthis.name = 'TimeoutError';\n\n\t\tif (Error.hasOwnProperty('captureStackTrace')) // Just in V8.\n\t\t\tError.captureStackTrace(this, TimeoutError);\n\t\telse\n\t\t\tthis.stack = (new Error(message)).stack;\n\t}\n}\n\n/**\n * Error indicating not support for something.\n */\nclass UnsupportedError extends Error\n{\n\tconstructor(message, data)\n\t{\n\t\tsuper(message);\n\n\t\tthis.name = 'UnsupportedError';\n\n\t\tif (Error.hasOwnProperty('captureStackTrace')) // Just in V8.\n\t\t\tError.captureStackTrace(this, UnsupportedError);\n\t\telse\n\t\t\tthis.stack = (new Error(message)).stack;\n\n\t\tthis.data = data;\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/errors.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Chrome55.js":
/*!****************************************!*\
  !*** ./lib/mslib/handlers/Chrome55.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Chrome55; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/planBUtils */ \"./lib/mslib/handlers/sdp/planBUtils.js\");\n/* harmony import */ var _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemotePlanBSdp */ \"./lib/mslib/handlers/sdp/RemotePlanBSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Chrome55');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemotePlanBSdp}\n\t\tthis._remoteSdp = new _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Local stream.\n\t\t// @type {MediaStream}\n\t\tthis._stream = new MediaStream();\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._stream.getTrackById(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet localSdpObj;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Add the track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\tthis._pc.addStream(this._stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\t// If simulcast is set, mangle the offer.\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tconst sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n\n\t\t\t\t\tconst offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n\t\t\t\t\toffer = { type: 'offer', sdp: offerSdp };\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill the RTP parameters for this track.\n\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track);\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\tthis._stream.removeTrack(track);\n\t\t\t\tthis._pc.addStream(this._stream);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the track from the local stream.\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\tthis._pc.addStream(this._stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// NOTE: If there are no sending tracks, setLocalDescription() will fail with\n\t\t\t\t// \"Failed to create channels\". If so, ignore it.\n\t\t\t\tif (this._stream.getTracks().length === 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'removeProducer() | ignoring expected error due no sending tracks: %s',\n\t\t\t\t\t\terror.toString());\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (this._pc.signalingState === 'stable')\n\t\t\t\t\treturn;\n\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\t\tlet localSdpObj;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track from the local stream.\n\t\t\t\tthis._stream.removeTrack(oldTrack);\n\n\t\t\t\t// Add the new track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\tthis._pc.addStream(this._stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\t// If simulcast is set, mangle the offer.\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tconst sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n\n\t\t\t\t\tconst offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n\t\t\t\t\toffer = { type: 'offer', sdp: offerSdp };\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'replaceProducerTrack() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'replaceProducerTrack() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill the RTP parameters for the new track.\n\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track);\n\n\t\t\t\t// We need to provide new RTP parameters.\n\t\t\t\tthis.safeEmit('@needupdateproducer', producer, rtpParameters);\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\tthis._stream.removeTrack(track);\n\t\t\t\tthis._stream.addTrack(oldTrack);\n\t\t\t\tthis._pc.addStream(this._stream);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    getPCStats(selector)\n\t{\n        // logger.debug('getPCStats of revc', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n                /*\n                sdpPlanBUtils.addPlanBSimulcast(sdpObject, track, {\n                    mid: transceiver.mid\n                });\n                */\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n\t\t\tvar answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track);\n            /*\n            sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            */\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Seen media kinds.\n\t\t// @type {Set<String>}\n\t\tthis._kinds = new Set();\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - kind {String}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tkind     : consumer.kind,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\t\tthis._kinds.add(consumer.kind);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst stream = this._pc.getRemoteStreams()\n\t\t\t\t\t.find((s) => s.id === consumerInfo.streamId);\n\t\t\t\tconst track = stream.getTrackById(consumerInfo.trackId);\n\n\t\t\t\tif (!track)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (!this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tthis._consumerInfos.delete(consumer.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n\n    getPCStats(selector)\n\t{\n        // logger.debug('getPCStats of revc', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n}\n\nclass Chrome55\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Chrome55';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\treturn pc.createOffer(\n\t\t\t{\n\t\t\t\tofferToReceiveAudio : true,\n\t\t\t\tofferToReceiveVideo : true\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Chrome55.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Chrome67.js":
/*!****************************************!*\
  !*** ./lib/mslib/handlers/Chrome67.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Chrome67; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/planBUtils */ \"./lib/mslib/handlers/sdp/planBUtils.js\");\n/* harmony import */ var _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemotePlanBSdp */ \"./lib/mslib/handlers/sdp/RemotePlanBSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Chrome67');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require',\n\t\t\t\tsdpSemantics       : 'plan-b'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemotePlanBSdp}\n\t\tthis._remoteSdp = new _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Local stream.\n\t\t// @type {MediaStream}\n\t\tthis._stream = new MediaStream();\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._stream.getTrackById(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet localSdpObj;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Add the track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\tthis._pc.addStream(this._stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\t// If simulcast is set, mangle the offer.\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tconst sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n\n\t\t\t\t\tconst offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n\t\t\t\t\toffer = { type: 'offer', sdp: offerSdp };\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill the RTP parameters for this track.\n\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track);\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\tthis._stream.removeTrack(track);\n\t\t\t\tthis._pc.addStream(this._stream);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the track from the local stream.\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\tthis._pc.addStream(this._stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// NOTE: If there are no sending tracks, setLocalDescription() will fail with\n\t\t\t\t// \"Failed to create channels\". If so, ignore it.\n\t\t\t\tif (this._stream.getTracks().length === 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'removeProducer() | ignoring expected error due no sending tracks: %s',\n\t\t\t\t\t\terror.toString());\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (this._pc.signalingState === 'stable')\n\t\t\t\t\treturn;\n\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === oldTrack);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\treturn rtpSender.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track from the local stream.\n\t\t\t\tthis._stream.removeTrack(oldTrack);\n\n\t\t\t\t// Add the new track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    getPCStats(selector)\n\t{\n        // logger.debug('getPCStats of revc', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n                /*\n                sdpPlanBUtils.addPlanBSimulcast(sdpObject, track, {\n                    mid: transceiver.mid\n                });\n                */\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n            _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track);\n\n            /*\n            sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            */\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Seen media kinds.\n\t\t// @type {Set<String>}\n\t\tthis._kinds = new Set();\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - kind {String}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tkind     : consumer.kind,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\t\tthis._kinds.add(consumer.kind);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst stream = this._pc.getRemoteStreams()\n\t\t\t\t\t.find((s) => s.id === consumerInfo.streamId);\n\t\t\t\tconst track = stream.getTrackById(consumerInfo.trackId);\n\n\t\t\t\tif (!track)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (!this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tthis._consumerInfos.delete(consumer.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n\n    getPCStats(selector)\n\t{\n        // logger.debug('getPCStats of revc', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n}\n\nclass Chrome67\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Chrome67';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require',\n\t\t\t\tsdpSemantics       : 'plan-b'\n\t\t\t});\n\n\t\treturn pc.createOffer(\n\t\t\t{\n\t\t\t\tofferToReceiveAudio : true,\n\t\t\t\tofferToReceiveVideo : true\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Chrome67.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Chrome69.js":
/*!****************************************!*\
  !*** ./lib/mslib/handlers/Chrome69.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Chrome69; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/planBUtils */ \"./lib/mslib/handlers/sdp/planBUtils.js\");\n/* harmony import */ var _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemotePlanBSdp */ \"./lib/mslib/handlers/sdp/RemotePlanBSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Chrome69');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require',\n\t\t\t\tsdpSemantics       : 'plan-b'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemotePlanBSdp}\n\t\tthis._remoteSdp = new _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Local stream.\n\t\t// @type {MediaStream}\n\t\tthis._stream = new MediaStream();\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._stream.getTrackById(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet rtpSender;\n\t\tlet localSdpObj;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Add the track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\trtpSender = this._pc.addTrack(track, this._stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\t// If simulcast is set, mangle the offer.\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tconst sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n\n\t\t\t\t\tconst offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n\t\t\t\t\toffer = { type: 'offer', sdp: offerSdp };\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill the RTP parameters for this track.\n\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track);\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\ttry { this._pc.removeTrack(rtpSender); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === track);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('RTCRtpSender not found');\n\n\t\t\t\t// Remove the associated RtpSender.\n\t\t\t\tthis._pc.removeTrack(rtpSender);\n\n\t\t\t\t// Remove the track from the local stream.\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// NOTE: If there are no sending tracks, setLocalDescription() will fail with\n\t\t\t\t// \"Failed to create channels\". If so, ignore it.\n\t\t\t\tif (this._stream.getTracks().length === 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'removeProducer() | ignoring expected error due no sending tracks: %s',\n\t\t\t\t\t\terror.toString());\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (this._pc.signalingState === 'stable')\n\t\t\t\t\treturn;\n\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === oldTrack);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\treturn rtpSender.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track from the local stream.\n\t\t\t\tthis._stream.removeTrack(oldTrack);\n\n\t\t\t\t// Add the new track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of revc', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n                /*\n                sdpPlanBUtils.addPlanBSimulcast(sdpObject, track, {\n                    mid: transceiver.mid\n                });\n                */\n\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track);\n            /*\n            sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            */\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Seen media kinds.\n\t\t// @type {Set<String>}\n\t\tthis._kinds = new Set();\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - kind {String}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tkind     : consumer.kind,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\t\tthis._kinds.add(consumer.kind);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst newRtpReceiver = this._pc.getReceivers()\n\t\t\t\t\t.find((rtpReceiver) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { track } = rtpReceiver;\n\n\t\t\t\t\t\tif (!track)\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\treturn track.id === consumerInfo.trackId;\n\t\t\t\t\t});\n\n\t\t\t\tif (!newRtpReceiver)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn newRtpReceiver.track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (!this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tthis._consumerInfos.delete(consumer.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of revc', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n}\n\nclass Chrome69\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Chrome69';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require',\n\t\t\t\tsdpSemantics       : 'plan-b'\n\t\t\t});\n\n\t\treturn pc.createOffer(\n\t\t\t{\n\t\t\t\tofferToReceiveAudio : true,\n\t\t\t\tofferToReceiveVideo : true\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Chrome69.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Chrome70.js":
/*!****************************************!*\
  !*** ./lib/mslib/handlers/Chrome70.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Chrome70; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./lib/mslib/handlers/sdp/unifiedPlanUtils.js\");\n/* harmony import */ var _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemoteUnifiedPlanSdp */ \"./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Chrome70');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require',\n\t\t\t\tsdpSemantics       : 'unified-plan'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemoteUnifiedPlanSdp}\n\t\tthis._remoteSdp = new _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Ids of alive local tracks.\n\t\t// @type {Set<Number>}\n\t\tthis._trackIds = new Set();\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._trackIds.has(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet transceiver;\n\t\tlet localSdpObj;\n\n\t\t// Add the track id to the Set.\n\t\tthis._trackIds.add(track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Let's check if there is any inactive transceiver for same kind and\n\t\t\t\t// reuse it if so.\n\t\t\t\ttransceiver = this._pc.getTransceivers()\n\t\t\t\t\t.find((t) => t.receiver.track.kind === track.kind && t.direction === 'inactive');\n\n\t\t\t\tif (transceiver)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | reusing an inactive transceiver');\n\n\t\t\t\t\ttransceiver.direction = 'sendonly';\n\n\t\t\t\t\treturn transceiver.sender.replaceTrack(track);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttransceiver = this._pc.addTransceiver(track, { direction: 'sendonly' });\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => this._pc.createOffer())\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\t// If simulcast is set, mangle the offer.\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tconst sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t\t_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"addPlanBSimulcast\"](\n\t\t\t\t\t\tsdpObject, track, { mid: transceiver.mid });\n\n\t\t\t\t\tconst offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n\t\t\t\t\toffer = { type: 'offer', sdp: offerSdp };\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters,\n\t\t\t\t\tlocalSdpObj,\n\t\t\t\t\ttrack,\n\t\t\t\t\t{ mid: transceiver.mid, planBSimulcast: true });\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\ttry { transceiver.direction = 'inactive'; }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthis._trackIds.delete(track.id);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tif (!this._trackIds.has(track.id))\n\t\t\treturn Promise.reject(new Error('track not found'));\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === track);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\tthis._pc.removeTrack(rtpSender);\n\n\t\t\t\t// Remove the track id from the Set.\n\t\t\t\tthis._trackIds.delete(track.id);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === oldTrack);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\treturn rtpSender.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track id from the Set.\n\t\t\t\tthis._trackIds.delete(oldTrack.id);\n\n\t\t\t\t// Add the new track id to the Set.\n\t\t\t\tthis._trackIds.add(track.id);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of send', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n\n    updateTrack(producer, track)\n    {\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"addPlanBSimulcast\"](sdpObject, track, {\n                    mid: transceiver.mid\n                });\n\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - mid {String}\n\t\t// - kind {String}\n\t\t// - closed {Boolean}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tmid      : `${consumer.kind[0]}${consumer.id}`,\n\t\t\tkind     : consumer.kind,\n\t\t\tclosed   : consumer.closed,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() kind:%s [offer:%o]',\n\t\t\t\t\tconsumer.kind, offer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() => this._pc.createAnswer())\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() kind:%s [answer:%o]',\n\t\t\t\t\tconsumer.kind, answer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst transceiver = this._pc.getTransceivers()\n\t\t\t\t\t.find((t) => t.mid === consumerInfo.mid);\n\n\t\t\t\tif (!transceiver)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn transceiver.receiver.track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tconst consumerInfo = this._consumerInfos.get(consumer.id);\n\n\t\tif (!consumerInfo)\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tconsumerInfo.closed = true;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of revc', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n}\n\nclass Chrome70\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Chrome70';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require',\n\t\t\t\tsdpSemantics       : 'unified-plan'\n\t\t\t});\n\n\t\tpc.addTransceiver('audio');\n\t\tpc.addTransceiver('video');\n\n\t\treturn pc.createOffer()\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Chrome70.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Edge11.js":
/*!**************************************!*\
  !*** ./lib/mslib/handlers/Edge11.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Edge11; });\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _ortc_edgeUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ortc/edgeUtils */ \"./lib/mslib/handlers/ortc/edgeUtils.js\");\n/* global RTCIceGatherer, RTCIceTransport, RTCDtlsTransport, RTCRtpReceiver, RTCRtpSender */\n\n\n\n\n\n\n\nconst CNAME = `CNAME-EDGE-${_utils__WEBPACK_IMPORTED_MODULE_2__[\"randomNumber\"]()}`;\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('Edge11');\n\nclass Edge11 extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Edge11';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\treturn Promise.resolve(_ortc_edgeUtils__WEBPACK_IMPORTED_MODULE_4__[\"getCapabilities\"]());\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tsuper(logger);\n\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind =\n\t\t{\n\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_3__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_3__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t};\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// ICE gatherer.\n\t\tthis._iceGatherer = null;\n\n\t\t// ICE transport.\n\t\tthis._iceTransport = null;\n\n\t\t// DTLS transport.\n\t\t// @type {RTCDtlsTransport}\n\t\tthis._dtlsTransport = null;\n\n\t\t// Map of RTCRtpSenders indexed by Producer.id.\n\t\t// @type {Map<Number, RTCRtpSender}\n\t\tthis._rtpSenders = new Map();\n\n\t\t// Map of RTCRtpReceivers indexed by Consumer.id.\n\t\t// @type {Map<Number, RTCRtpReceiver}\n\t\tthis._rtpReceivers = new Map();\n\n\t\t// Remote Transport parameters.\n\t\t// @type {Object}\n\t\tthis._transportRemoteParameters = null;\n\n\t\tthis._setIceGatherer(settings);\n\t\tthis._setIceTransport();\n\t\tthis._setDtlsTransport();\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close the ICE gatherer.\n\t\t// NOTE: Not yet implemented by Edge.\n\t\ttry { this._iceGatherer.close(); }\n\t\tcatch (error) {}\n\n\t\t// Close the ICE transport.\n\t\ttry { this._iceTransport.stop(); }\n\t\tcatch (error) {}\n\n\t\t// Close the DTLS transport.\n\t\ttry { this._dtlsTransport.stop(); }\n\t\tcatch (error) {}\n\n\t\t// Close RTCRtpSenders.\n\t\tfor (const rtpSender of this._rtpSenders.values())\n\t\t{\n\t\t\ttry { rtpSender.stop(); }\n\t\t\tcatch (error) {}\n\t\t}\n\n\t\t// Close RTCRtpReceivers.\n\t\tfor (const rtpReceiver of this._rtpReceivers.values())\n\t\t{\n\t\t\ttry { rtpReceiver.stop(); }\n\t\t\tcatch (error) {}\n\t\t}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._rtpSenders.has(producer.id))\n\t\t\treturn Promise.reject(new Error('Producer already added'));\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlogger.debug('addProducer() | calling new RTCRtpSender()');\n\n\t\t\t\tconst rtpSender = new RTCRtpSender(track, this._dtlsTransport);\n\t\t\t\tconst rtpParameters =\n\t\t\t\t\t_utils__WEBPACK_IMPORTED_MODULE_2__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill RTCRtpParameters.encodings.\n\t\t\t\tconst encoding =\n\t\t\t\t{\n\t\t\t\t\tssrc : _utils__WEBPACK_IMPORTED_MODULE_2__[\"randomNumber\"]()\n\t\t\t\t};\n\n\t\t\t\tif (rtpParameters.codecs.some((codec) => codec.name === 'rtx'))\n\t\t\t\t{\n\t\t\t\t\tencoding.rtx =\n\t\t\t\t\t{\n\t\t\t\t\t\tssrc : _utils__WEBPACK_IMPORTED_MODULE_2__[\"randomNumber\"]()\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\trtpParameters.encodings.push(encoding);\n\n\t\t\t\t// Fill RTCRtpParameters.rtcp.\n\t\t\t\trtpParameters.rtcp =\n\t\t\t\t{\n\t\t\t\t\tcname       : CNAME,\n\t\t\t\t\treducedSize : true,\n\t\t\t\t\tmux         : true\n\t\t\t\t};\n\n\t\t\t\t// NOTE: Convert our standard RTCRtpParameters into those that Edge\n\t\t\t\t// expects.\n\t\t\t\tconst edgeRtpParameters = _ortc_edgeUtils__WEBPACK_IMPORTED_MODULE_4__[\"mangleRtpParameters\"](rtpParameters);\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling rtpSender.send() [params:%o]',\n\t\t\t\t\tedgeRtpParameters);\n\n\t\t\t\trtpSender.send(edgeRtpParameters);\n\n\t\t\t\t// Store it.\n\t\t\t\tthis._rtpSenders.set(producer.id, rtpSender);\n\n\t\t\t\treturn rtpParameters;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpSender = this._rtpSenders.get(producer.id);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('RTCRtpSender not found');\n\n\t\t\t\tthis._rtpSenders.delete(producer.id);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('removeProducer() | calling rtpSender.stop()');\n\n\t\t\t\t\trtpSender.stop();\n\t\t\t\t}\n\t\t\t\tcatch (error)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('rtpSender.stop() failed:%o', error);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpSender = this._rtpSenders.get(producer.id);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('RTCRtpSender not found');\n\n\t\t\t\trtpSender.setTrack(track);\n\t\t\t});\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._rtpReceivers.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlogger.debug('addConsumer() | calling new RTCRtpReceiver()');\n\n\t\t\t\tconst rtpReceiver =\n\t\t\t\t\tnew RTCRtpReceiver(this._dtlsTransport, consumer.kind);\n\n\t\t\t\trtpReceiver.addEventListener('error', (event) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.error('iceGatherer \"error\" event [event:%o]', event);\n\t\t\t\t});\n\n\t\t\t\t// NOTE: Convert our standard RTCRtpParameters into those that Edge\n\t\t\t\t// expects.\n\t\t\t\tconst edgeRtpParameters = _ortc_edgeUtils__WEBPACK_IMPORTED_MODULE_4__[\"mangleRtpParameters\"](consumer.rtpParameters);\n\n\t\t\t\t// Ignore MID RTP extension for receiving media.\n\t\t\t\tedgeRtpParameters.headerExtensions = edgeRtpParameters.headerExtensions\n\t\t\t\t\t.filter((extension) => extension.uri !== 'urn:ietf:params:rtp-hdrext:sdes:mid');\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling rtpReceiver.receive() [params:%o]',\n\t\t\t\t\tedgeRtpParameters);\n\n\t\t\t\trtpReceiver.receive(edgeRtpParameters);\n\n\t\t\t\t// Store it.\n\t\t\t\tthis._rtpReceivers.set(consumer.id, rtpReceiver);\n\n\t\t\t\treturn rtpReceiver.track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpReceiver = this._rtpReceivers.get(consumer.id);\n\n\t\t\t\tif (!rtpReceiver)\n\t\t\t\t\tthrow new Error('RTCRtpReceiver not found');\n\n\t\t\t\tthis._rtpReceivers.delete(consumer.id);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('removeConsumer() | calling rtpReceiver.stop()');\n\n\t\t\t\t\trtpReceiver.stop();\n\t\t\t\t}\n\t\t\t\tcatch (error)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('rtpReceiver.stop() failed:%o', error);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\tPromise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tthis._transportRemoteParameters.iceParameters = remoteIceParameters;\n\n\t\t\t\tconst remoteIceCandidates = this._transportRemoteParameters.iceCandidates;\n\n\t\t\t\tlogger.debug('restartIce() | calling iceTransport.start()');\n\n\t\t\t\tthis._iceTransport.start(\n\t\t\t\t\tthis._iceGatherer, remoteIceParameters, 'controlling');\n\n\t\t\t\tfor (const candidate of remoteIceCandidates)\n\t\t\t\t{\n\t\t\t\t\tthis._iceTransport.addRemoteCandidate(candidate);\n\t\t\t\t}\n\n\t\t\t\tthis._iceTransport.addRemoteCandidate({});\n\t\t\t});\n\t}\n\n\t_setIceGatherer(settings)\n\t{\n\t\tconst iceGatherer = new RTCIceGatherer(\n\t\t\t{\n\t\t\t\ticeServers   : settings.turnServers || [],\n\t\t\t\tgatherPolicy : settings.iceTransportPolicy\n\t\t\t});\n\n\t\ticeGatherer.addEventListener('error', (event) =>\n\t\t{\n\t\t\tlogger.error('iceGatherer \"error\" event [event:%o]', event);\n\t\t});\n\n\t\t// NOTE: Not yet implemented by Edge, which starts gathering automatically.\n\t\ttry\n\t\t{\n\t\t\ticeGatherer.gather();\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.debug('iceGatherer.gather() failed: %s', error.toString());\n\t\t}\n\n\t\tthis._iceGatherer = iceGatherer;\n\t}\n\n\t_setIceTransport()\n\t{\n\t\tconst iceTransport = new RTCIceTransport(this._iceGatherer);\n\n\t\t// NOTE: Not yet implemented by Edge.\n\t\ticeTransport.addEventListener('statechange', () =>\n\t\t{\n\t\t\tswitch (iceTransport.state)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\t// NOTE: Not standard, but implemented by Edge.\n\t\ticeTransport.addEventListener('icestatechange', () =>\n\t\t{\n\t\t\tswitch (iceTransport.state)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\ticeTransport.addEventListener('candidatepairchange', (event) =>\n\t\t{\n\t\t\tlogger.debug(\n\t\t\t\t'iceTransport \"candidatepairchange\" event [pair:%o]', event.pair);\n\t\t});\n\n\t\tthis._iceTransport = iceTransport;\n\t}\n\n\t_setDtlsTransport()\n\t{\n\t\tconst dtlsTransport = new RTCDtlsTransport(this._iceTransport);\n\n\t\t// NOTE: Not yet implemented by Edge.\n\t\tdtlsTransport.addEventListener('statechange', () =>\n\t\t{\n\t\t\tlogger.debug(\n\t\t\t\t'dtlsTransport \"statechange\" event [state:%s]', dtlsTransport.state);\n\t\t});\n\n\t\t// NOTE: Not standard, but implemented by Edge.\n\t\tdtlsTransport.addEventListener('dtlsstatechange', () =>\n\t\t{\n\t\t\tlogger.debug(\n\t\t\t\t'dtlsTransport \"dtlsstatechange\" event [state:%s]', dtlsTransport.state);\n\n\t\t\tif (dtlsTransport.state === 'closed')\n\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t});\n\n\t\tdtlsTransport.addEventListener('error', (event) =>\n\t\t{\n\t\t\tlogger.error('dtlsTransport \"error\" event [event:%o]', event);\n\t\t});\n\n\t\tthis._dtlsTransport = dtlsTransport;\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst dtlsParameters = this._dtlsTransport.getLocalParameters();\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\tthis._transportRemoteParameters = transportRemoteParameters;\n\n\t\t\t\tconst remoteIceParameters = transportRemoteParameters.iceParameters;\n\t\t\t\tconst remoteIceCandidates = transportRemoteParameters.iceCandidates;\n\t\t\t\tconst remoteDtlsParameters = transportRemoteParameters.dtlsParameters;\n\n\t\t\t\t// Start the RTCIceTransport.\n\t\t\t\tthis._iceTransport.start(\n\t\t\t\t\tthis._iceGatherer, remoteIceParameters, 'controlling');\n\n\t\t\t\t// Add remote ICE candidates.\n\t\t\t\tfor (const candidate of remoteIceCandidates)\n\t\t\t\t{\n\t\t\t\t\tthis._iceTransport.addRemoteCandidate(candidate);\n\t\t\t\t}\n\n\t\t\t\t// Also signal a 'complete' candidate as per spec.\n\t\t\t\t// NOTE: It should be {complete: true} but Edge prefers {}.\n\t\t\t\t// NOTE: If we don't signal end of candidates, the Edge RTCIceTransport\n\t\t\t\t// won't enter the 'completed' state.\n\t\t\t\tthis._iceTransport.addRemoteCandidate({});\n\n\t\t\t\t// NOTE: Edge does not like SHA less than 256.\n\t\t\t\tremoteDtlsParameters.fingerprints = remoteDtlsParameters.fingerprints.\n\t\t\t\t\tfilter((fingerprint) =>\n\t\t\t\t\t{\n\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\tfingerprint.algorithm === 'sha-256' ||\n\t\t\t\t\t\t\tfingerprint.algorithm === 'sha-384' ||\n\t\t\t\t\t\t\tfingerprint.algorithm === 'sha-512'\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\n\t\t\t\t// Start the RTCDtlsTransport.\n\t\t\t\tthis._dtlsTransport.start(remoteDtlsParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Edge11.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Firefox50.js":
/*!*****************************************!*\
  !*** ./lib/mslib/handlers/Firefox50.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Firefox50; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./lib/mslib/handlers/sdp/unifiedPlanUtils.js\");\n/* harmony import */ var _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemoteUnifiedPlanSdp */ \"./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Firefox50');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemoteUnifiedPlanSdp}\n\t\tthis._remoteSdp = new _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Local stream.\n\t\t// @type {MediaStream}\n\t\tthis._stream = new MediaStream();\n\n\t\t// RID value counter for simulcast (so they never match).\n\t\t// @type {Number}\n\t\tthis._nextRid = 1;\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._stream.getTrackById(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet rtpSender;\n\t\tlet localSdpObj;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tthis._stream.addTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\trtpSender = this._pc.addTrack(track, this._stream);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst encodings = [];\n\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tif (producer.simulcast.high)\n\t\t\t\t\t{\n\t\t\t\t\t\tencodings.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trid        : `high${this._nextRid}`,\n\t\t\t\t\t\t\t\tactive     : true,\n\t\t\t\t\t\t\t\tpriority   : 'low',\n\t\t\t\t\t\t\t\tmaxBitrate : producer.simulcast.high\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (producer.simulcast.medium)\n\t\t\t\t\t{\n\t\t\t\t\t\tencodings.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trid        : `medium${this._nextRid}`,\n\t\t\t\t\t\t\t\tactive     : true,\n\t\t\t\t\t\t\t\tpriority   : 'medium',\n\t\t\t\t\t\t\t\tmaxBitrate : producer.simulcast.medium\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (producer.simulcast.low)\n\t\t\t\t\t{\n\t\t\t\t\t\tencodings.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trid        : `low${this._nextRid}`,\n\t\t\t\t\t\t\t\tactive     : true,\n\t\t\t\t\t\t\t\tpriority   : 'high',\n\t\t\t\t\t\t\t\tmaxBitrate : producer.simulcast.low\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update RID counter for future ones.\n\t\t\t\t\tthis._nextRid++;\n\t\t\t\t}\n\n\t\t\t\tconst parameters = rtpSender.getParameters();\n\n\t\t\t\treturn rtpSender.setParameters({ ...parameters, encodings });\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill the RTP parameters for this track.\n\t\t\t\t_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track);\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\ttry { this._pc.removeTrack(rtpSender); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === track);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('RTCRtpSender not found');\n\n\t\t\t\t// Remove the associated RtpSender.\n\t\t\t\tthis._pc.removeTrack(rtpSender);\n\n\t\t\t\t// Remove the track from the local stream.\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === oldTrack);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\treturn rtpSender.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track from the local stream.\n\t\t\t\tthis._stream.removeTrack(oldTrack);\n\n\t\t\t\t// Add the new track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"addPlanBSimulcast\"](sdpObject, track, {\n                    mid: transceiver.mid\n                });\n\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - mid {String}\n\t\t// - kind {String}\n\t\t// - closed {Boolean}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\n\t\t// Add an entry into consumers info to hold a fake DataChannel, so\n\t\t// the first m= section of the remote SDP is always \"active\" and Firefox\n\t\t// does not close the transport when there is no remote audio/video Consumers.\n\t\t//\n\t\t// ISSUE: https://github.com/versatica/mediasoup-client/issues/2\n\t\tconst fakeDataChannelConsumerInfo =\n\t\t{\n\t\t\tmid    : 'fake-dc',\n\t\t\tkind   : 'application',\n\t\t\tclosed : false,\n\t\t\tcname  : null\n\t\t};\n\n\t\tthis._consumerInfos.set(555, fakeDataChannelConsumerInfo);\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tmid      : `${consumer.kind[0]}${consumer.id}`,\n\t\t\tkind     : consumer.kind,\n\t\t\tclosed   : consumer.closed,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst newRtpReceiver = this._pc.getReceivers()\n\t\t\t\t\t.find((rtpReceiver) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { track } = rtpReceiver;\n\n\t\t\t\t\t\tif (!track)\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\treturn track.id === consumerInfo.trackId;\n\t\t\t\t\t});\n\n\t\t\t\tif (!newRtpReceiver)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn newRtpReceiver.track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tconst consumerInfo = this._consumerInfos.get(consumer.id);\n\n\t\tif (!consumerInfo)\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tconsumerInfo.closed = true;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n}\n\nclass Firefox50\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Firefox50';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// NOTE: We need to add a real video track to get the RID extension mapping.\n\t\tconst canvas = document.createElement('canvas');\n\n\t\t// NOTE: Otherwise Firefox fails in next line.\n\t\tcanvas.getContext('2d');\n\n\t\tconst fakeStream = canvas.captureStream();\n\t\tconst fakeVideoTrack = fakeStream.getVideoTracks()[0];\n\t\tconst rtpSender = pc.addTrack(fakeVideoTrack, fakeStream);\n\n\t\trtpSender.setParameters(\n\t\t\t{\n\t\t\t\tencodings :\n\t\t\t\t[\n\t\t\t\t\t{ rid: 'RID1', maxBitrate: 40000 },\n\t\t\t\t\t{ rid: 'RID2', maxBitrate: 10000 }\n\t\t\t\t]\n\t\t\t});\n\n\t\treturn pc.createOffer(\n\t\t\t{\n\t\t\t\tofferToReceiveAudio : true,\n\t\t\t\tofferToReceiveVideo : true\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { canvas.remove(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\ttry { fakeVideoTrack.stop(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { canvas.remove(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\ttry { fakeVideoTrack.stop(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Firefox50.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Firefox59.js":
/*!*****************************************!*\
  !*** ./lib/mslib/handlers/Firefox59.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Firefox59; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./lib/mslib/handlers/sdp/unifiedPlanUtils.js\");\n/* harmony import */ var _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemoteUnifiedPlanSdp */ \"./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Firefox59');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemoteUnifiedPlanSdp}\n\t\tthis._remoteSdp = new _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Local stream.\n\t\t// @type {MediaStream}\n\t\tthis._stream = new MediaStream();\n\n\t\t// RID value counter for simulcast (so they never match).\n\t\t// @type {Number}\n\t\tthis._nextRid = 1;\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._stream.getTrackById(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet rtpSender;\n\t\tlet localSdpObj;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Add the track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\trtpSender = this._pc.addTrack(track, this._stream);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst encodings = [];\n\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tif (producer.simulcast.high)\n\t\t\t\t\t{\n\t\t\t\t\t\tencodings.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trid        : `high${this._nextRid}`,\n\t\t\t\t\t\t\t\tactive     : true,\n\t\t\t\t\t\t\t\tpriority   : 'low',\n\t\t\t\t\t\t\t\tmaxBitrate : producer.simulcast.high\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (producer.simulcast.medium)\n\t\t\t\t\t{\n\t\t\t\t\t\tencodings.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trid        : `medium${this._nextRid}`,\n\t\t\t\t\t\t\t\tactive     : true,\n\t\t\t\t\t\t\t\tpriority   : 'medium',\n\t\t\t\t\t\t\t\tmaxBitrate : producer.simulcast.medium\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (producer.simulcast.low)\n\t\t\t\t\t{\n\t\t\t\t\t\tencodings.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trid        : `low${this._nextRid}`,\n\t\t\t\t\t\t\t\tactive     : true,\n\t\t\t\t\t\t\t\tpriority   : 'high',\n\t\t\t\t\t\t\t\tmaxBitrate : producer.simulcast.low\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update RID counter for future ones.\n\t\t\t\t\tthis._nextRid++;\n\t\t\t\t}\n\n\t\t\t\tconst parameters = rtpSender.getParameters();\n\n\t\t\t\treturn rtpSender.setParameters({ ...parameters, encodings });\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill the RTP parameters for this track.\n\t\t\t\t_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track);\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\ttry { this._pc.removeTrack(rtpSender); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === track);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('RTCRtpSender not found');\n\n\t\t\t\t// Remove the associated RtpSender.\n\t\t\t\tthis._pc.removeTrack(rtpSender);\n\n\t\t\t\t// Remove the track from the local stream.\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\t\t\t\t\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\t\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === oldTrack);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\treturn rtpSender.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track from the local stream.\n\t\t\t\tthis._stream.removeTrack(oldTrack);\n\n\t\t\t\t// Add the new track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"addPlanBSimulcast\"](sdpObject, track, {\n                    mid: transceiver.mid\n                });\n\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - mid {String}\n\t\t// - kind {String}\n\t\t// - closed {Boolean}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tmid      : `${consumer.kind[0]}${consumer.id}`,\n\t\t\tkind     : consumer.kind,\n\t\t\tclosed   : consumer.closed,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst newTransceiver = this._pc.getTransceivers()\n\t\t\t\t\t.find((transceiver) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { receiver } = transceiver;\n\n\t\t\t\t\t\tif (!receiver)\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\tconst { track } = receiver;\n\n\t\t\t\t\t\tif (!track)\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\treturn transceiver.mid === consumerInfo.mid;\n\t\t\t\t\t});\n\n\t\t\t\tif (!newTransceiver)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn newTransceiver.receiver.track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tconst consumerInfo = this._consumerInfos.get(consumer.id);\n\n\t\tif (!consumerInfo)\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tconsumerInfo.closed = true;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n}\n\nclass Firefox59\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Firefox59';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// NOTE: We need to add a real video track to get the RID extension mapping.\n\t\tconst canvas = document.createElement('canvas');\n\n\t\t// NOTE: Otherwise Firefox fails in next line.\n\t\tcanvas.getContext('2d');\n\n\t\tconst fakeStream = canvas.captureStream();\n\t\tconst fakeVideoTrack = fakeStream.getVideoTracks()[0];\n\t\tconst rtpSender = pc.addTrack(fakeVideoTrack, fakeStream);\n\n\t\trtpSender.setParameters(\n\t\t\t{\n\t\t\t\tencodings :\n\t\t\t\t[\n\t\t\t\t\t{ rid: 'RID1', maxBitrate: 40000 },\n\t\t\t\t\t{ rid: 'RID2', maxBitrate: 10000 }\n\t\t\t\t]\n\t\t\t});\n\n\t\treturn pc.createOffer(\n\t\t\t{\n\t\t\t\tofferToReceiveAudio : true,\n\t\t\t\tofferToReceiveVideo : true\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { canvas.remove(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\ttry { fakeVideoTrack.stop(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { canvas.remove(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\ttry { fakeVideoTrack.stop(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Firefox59.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Firefox65.js":
/*!*****************************************!*\
  !*** ./lib/mslib/handlers/Firefox65.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Firefox65; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./lib/mslib/handlers/sdp/unifiedPlanUtils.js\");\n/* harmony import */ var _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemoteUnifiedPlanSdp */ \"./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Firefox65');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemoteUnifiedPlanSdp}\n\t\tthis._remoteSdp = new _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Ids of alive local tracks.\n\t\t// @type {Set<Number>}\n\t\tthis._trackIds = new Set();\n\n\t\t// RID value counter for simulcast (so they never match).\n\t\t// @type {Number}\n\t\tthis._nextRid = 1;\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._trackIds.has(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet transceiver;\n\t\tlet localSdpObj;\n\n\t\t// Add the track id to the Set.\n\t\tthis._trackIds.add(track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Let's check if there is any inactive transceiver for same kind and\n\t\t\t\t// reuse it if so.\n\t\t\t\ttransceiver = this._pc.getTransceivers()\n\t\t\t\t\t.find((t) => t.receiver.track.kind === track.kind && t.direction === 'inactive');\n\n\t\t\t\tif (transceiver)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | reusing an inactive transceiver');\n\n\t\t\t\t\ttransceiver.direction = 'sendonly';\n\n\t\t\t\t\treturn transceiver.sender.replaceTrack(track);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttransceiver = this._pc.addTransceiver(track, { direction: 'sendonly' });\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst { sender } = transceiver;\n\t\t\t\tconst encodings = [];\n\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tif (producer.simulcast.high)\n\t\t\t\t\t{\n\t\t\t\t\t\tencodings.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trid        : `high${this._nextRid}`,\n\t\t\t\t\t\t\t\tactive     : true,\n\t\t\t\t\t\t\t\tpriority   : 'low',\n\t\t\t\t\t\t\t\tmaxBitrate : producer.simulcast.high\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (producer.simulcast.medium)\n\t\t\t\t\t{\n\t\t\t\t\t\tencodings.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trid        : `medium${this._nextRid}`,\n\t\t\t\t\t\t\t\tactive     : true,\n\t\t\t\t\t\t\t\tpriority   : 'medium',\n\t\t\t\t\t\t\t\tmaxBitrate : producer.simulcast.medium\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (producer.simulcast.low)\n\t\t\t\t\t{\n\t\t\t\t\t\tencodings.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trid        : `low${this._nextRid}`,\n\t\t\t\t\t\t\t\tactive     : true,\n\t\t\t\t\t\t\t\tpriority   : 'high',\n\t\t\t\t\t\t\t\tmaxBitrate : producer.simulcast.low\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update RID counter for future ones.\n\t\t\t\t\tthis._nextRid++;\n\t\t\t\t}\n\n\t\t\t\tconst parameters = sender.getParameters();\n\n\t\t\t\treturn sender.setParameters({ ...parameters, encodings });\n\t\t\t})\n\t\t\t.then(() => this._pc.createOffer())\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track, { mid: transceiver.mid });\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\ttry { transceiver.direction = 'inactive'; }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthis._trackIds.delete(track.id);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tif (!this._trackIds.has(track.id))\n\t\t\treturn Promise.reject(new Error('track not found'));\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === track);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\tthis._pc.removeTrack(rtpSender);\n\n\t\t\t\t// Remove the track id from the Set.\n\t\t\t\tthis._trackIds.delete(track.id);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === oldTrack);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\treturn rtpSender.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track id from the Set.\n\t\t\t\tthis._trackIds.delete(oldTrack.id);\n\n\t\t\t\t// Add the new track id to the Set.\n\t\t\t\tthis._trackIds.add(track.id);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"addPlanBSimulcast\"](sdpObject, track, {\n                    mid: transceiver.mid\n                });\n\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - mid {String}\n\t\t// - kind {String}\n\t\t// - closed {Boolean}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tmid      : `${consumer.kind[0]}${consumer.id}`,\n\t\t\tkind     : consumer.kind,\n\t\t\tclosed   : consumer.closed,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() => this._pc.createAnswer())\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst transceiver = this._pc.getTransceivers()\n\t\t\t\t\t.find((t) => t.mid === consumerInfo.mid);\n\n\t\t\t\tif (!transceiver)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn transceiver.receiver.track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tconst consumerInfo = this._consumerInfos.get(consumer.id);\n\n\t\tif (!consumerInfo)\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tconsumerInfo.closed = true;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n}\n\nclass Firefox65\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Firefox65';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// NOTE: We need to add a real video track to get the RID extension mapping.\n\t\tconst canvas = document.createElement('canvas');\n\n\t\t// NOTE: Otherwise Firefox fails in next line.\n\t\tcanvas.getContext('2d');\n\n\t\tconst fakeStream = canvas.captureStream();\n\t\tconst fakeVideoTrack = fakeStream.getVideoTracks()[0];\n\t\tconst rtpSender = pc.addTrack(fakeVideoTrack, fakeStream);\n\n\t\trtpSender.setParameters(\n\t\t\t{\n\t\t\t\tencodings :\n\t\t\t\t[\n\t\t\t\t\t{ rid: 'RID1', maxBitrate: 40000 },\n\t\t\t\t\t{ rid: 'RID2', maxBitrate: 10000 }\n\t\t\t\t]\n\t\t\t});\n\n\t\treturn pc.createOffer(\n\t\t\t{\n\t\t\t\tofferToReceiveAudio : true,\n\t\t\t\tofferToReceiveVideo : true\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { canvas.remove(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\ttry { fakeVideoTrack.stop(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { canvas.remove(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\ttry { fakeVideoTrack.stop(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Firefox65.js?");

/***/ }),

/***/ "./lib/mslib/handlers/ReactNative.js":
/*!*******************************************!*\
  !*** ./lib/mslib/handlers/ReactNative.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ReactNative; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/planBUtils */ \"./lib/mslib/handlers/sdp/planBUtils.js\");\n/* harmony import */ var _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemotePlanBSdp */ \"./lib/mslib/handlers/sdp/RemotePlanBSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('ReactNative');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemotePlanBSdp}\n\t\tthis._remoteSdp = new _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Handled tracks.\n\t\t// @type {Set<MediaStreamTrack>}\n\t\tthis._tracks = new Set();\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._tracks.has(track))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tif (!track.streamReactTag)\n\t\t\treturn Promise.reject(new Error('no track.streamReactTag property'));\n\n\t\tlet stream;\n\t\tlet localSdpObj;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Add the track to the Set.\n\t\t\t\tthis._tracks.add(track);\n\n\t\t\t\t// Hack: Create a new stream with track.streamReactTag as id.\n\t\t\t\tstream = new MediaStream(track.streamReactTag);\n\n\t\t\t\t// Add the track to the stream.\n\t\t\t\tstream.addTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\tthis._pc.addStream(stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\t// If simulcast is set, mangle the offer.\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tconst sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n\n\t\t\t\t\tconst offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n\t\t\t\t\toffer = { type: 'offer', sdp: offerSdp };\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\tconst offerDesc = new RTCSessionDescription(offer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offerDesc);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\tconst answerDesc = new RTCSessionDescription(answer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answerDesc);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill the RTP parameters for this track.\n\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track);\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\tthis._tracks.delete(track);\n\t\t\t\tstream.removeTrack(track);\n\t\t\t\tthis._pc.removeStream(stream);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (!track.streamReactTag)\n\t\t\treturn Promise.reject(new Error('no track.streamReactTag property'));\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the track from the Set.\n\t\t\t\tthis._tracks.delete(track);\n\n\t\t\t\t// Hack: Create a new stream with track.streamReactTag as id.\n\t\t\t\tconst stream = new MediaStream(track.streamReactTag);\n\n\t\t\t\t// Add the track to the stream.\n\t\t\t\tstream.addTrack(track);\n\n\t\t\t\t// Remove the stream from the PeerConnection.\n\t\t\t\tthis._pc.removeStream(stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// NOTE: If there are no sending tracks, setLocalDescription() will fail with\n\t\t\t\t// \"Failed to create channels\". If so, ignore it.\n\t\t\t\tif (this._tracks.size === 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'removeProducer() | ignoring expected error due no sending tracks: %s',\n\t\t\t\t\t\terror.toString());\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (this._pc.signalingState === 'stable')\n\t\t\t\t\treturn;\n\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\tconst answerDesc = new RTCSessionDescription(answer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answerDesc);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (!track.streamReactTag)\n\t\t\treturn Promise.reject(new Error('no track.streamReactTag property'));\n\n\t\tconst oldTrack = producer.track;\n\t\tlet stream;\n\t\tlet localSdpObj;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Add the new Track to the Set and remove the old one.\n\t\t\t\tthis._tracks.add(track);\n\t\t\t\tthis._tracks.delete(oldTrack);\n\n\t\t\t\t// Hack: Create a new stream with track.streamReactTag as id.\n\t\t\t\tstream = new MediaStream(track.streamReactTag);\n\n\t\t\t\t// Add the track to the stream and remove the old one.\n\t\t\t\tstream.addTrack(track);\n\t\t\t\tstream.removeTrack(oldTrack);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\tthis._pc.addStream(stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\t// If simulcast is set, mangle the offer.\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tconst sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n\n\t\t\t\t\tconst offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n\t\t\t\t\toffer = { type: 'offer', sdp: offerSdp };\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'replaceProducerTrack() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\tconst offerDesc = new RTCSessionDescription(offer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offerDesc);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'replaceProducerTrack() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\tconst answerDesc = new RTCSessionDescription(answer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answerDesc);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill the RTP parameters for the new track.\n\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track);\n\n\t\t\t\t// We need to provide new RTP parameters.\n\t\t\t\tthis.safeEmit('@needupdateproducer', producer, rtpParameters);\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\tthis._tracks.delete(track);\n\t\t\t\tstream.removeTrack(track);\n\t\t\t\tthis._pc.addStream(stream);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\tconst answerDesc = new RTCSessionDescription(answer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answerDesc);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n                /*\n                sdpPlanBUtils.addPlanBSimulcast(sdpObject, track, {\n                    mid: transceiver.mid\n                });\n                */\n\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track);\n            /*\n            sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            */\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Seen media kinds.\n\t\t// @type {Set<String>}\n\t\tthis._kinds = new Set();\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - kind {String}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tkind     : consumer.kind,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\t\tthis._kinds.add(consumer.kind);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\tconst offerDesc = new RTCSessionDescription(offer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offerDesc);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst stream = this._pc.getRemoteStreams()\n\t\t\t\t\t.find((s) => s.id === consumerInfo.streamId);\n\t\t\t\tconst track = stream.getTrackById(consumerInfo.trackId);\n\n\t\t\t\t// Hack: Add a streamReactTag property with the reactTag of the MediaStream\n\t\t\t\t// generated by react-native-webrtc (this is needed because react-native-webrtc\n\t\t\t\t// assumes that we're gonna use the streams generated by it).\n\t\t\t\ttrack.streamReactTag = stream.reactTag;\n\n\t\t\t\tif (!track)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (!this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tthis._consumerInfos.delete(consumer.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\tconst offerDesc = new RTCSessionDescription(offer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offerDesc);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\tconst offerDesc = new RTCSessionDescription(offer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offerDesc);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n}\n\nclass ReactNative\n{\n\tstatic get tag()\n\t{\n\t\treturn 'ReactNative';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\treturn pc.createOffer(\n\t\t\t{\n\t\t\t\tofferToReceiveAudio : true,\n\t\t\t\tofferToReceiveVideo : true\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/ReactNative.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Safari11.js":
/*!****************************************!*\
  !*** ./lib/mslib/handlers/Safari11.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Safari11; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/planBUtils */ \"./lib/mslib/handlers/sdp/planBUtils.js\");\n/* harmony import */ var _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemotePlanBSdp */ \"./lib/mslib/handlers/sdp/RemotePlanBSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Safari11');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemotePlanBSdp}\n\t\tthis._remoteSdp = new _sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Local stream.\n\t\t// @type {MediaStream}\n\t\tthis._stream = new MediaStream();\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._stream.getTrackById(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet rtpSender;\n\t\tlet localSdpObj;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Add the track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\n\t\t\t\t// Add the stream to the PeerConnection.\n\t\t\t\trtpSender = this._pc.addTrack(track, this._stream);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t// Fill the RTP parameters for this track.\n\t\t\t\t_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters, localSdpObj, track);\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\ttry { this._pc.removeTrack(rtpSender); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === track);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('RTCRtpSender not found');\n\n\t\t\t\t// Remove the associated RtpSender.\n\t\t\t\tthis._pc.removeTrack(rtpSender);\n\n\t\t\t\t// Remove the track from the local stream.\n\t\t\t\tthis._stream.removeTrack(track);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// NOTE: If there are no sending tracks, setLocalDescription() will fail with\n\t\t\t\t// \"Failed to create channels\". If so, ignore it.\n\t\t\t\tif (this._stream.getTracks().length === 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t'removeProducer() | ignoring expected error due no sending tracks: %s',\n\t\t\t\t\t\terror.toString());\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (this._pc.signalingState === 'stable')\n\t\t\t\t\treturn;\n\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === oldTrack);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\treturn rtpSender.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track from the local stream.\n\t\t\t\tthis._stream.removeTrack(oldTrack);\n\n\t\t\t\t// Add the new track to the local stream.\n\t\t\t\tthis._stream.addTrack(track);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of send', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"addSimulcastForTrack\"](sdpObject, track);\n                /*\n                sdpPlanBUtils.addPlanBSimulcast(sdpObject, track, {\n                    mid: transceiver.mid\n                });\n                */\n\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track);\n            /*\n            sdpPlanBUtils.fillRtpParametersForTrack(rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            */\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Seen media kinds.\n\t\t// @type {Set<String>}\n\t\tthis._kinds = new Set();\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - kind {String}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tkind     : consumer.kind,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\t\tthis._kinds.add(consumer.kind);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst newRtpReceiver = this._pc.getReceivers()\n\t\t\t\t\t.find((rtpReceiver) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tconst { track } = rtpReceiver;\n\n\t\t\t\t\t\tif (!track)\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\treturn track.id === consumerInfo.trackId;\n\t\t\t\t\t});\n\n\t\t\t\tif (!newRtpReceiver)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn newRtpReceiver.track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (!this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tthis._consumerInfos.delete(consumer.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._kinds), Array.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of recv', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n}\n\nclass Safari11\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Safari11';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\tpc.addTransceiver('audio');\n\t\tpc.addTransceiver('video');\n\n\t\treturn pc.createOffer()\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Safari11.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Safari12.js":
/*!****************************************!*\
  !*** ./lib/mslib/handlers/Safari12.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Safari12; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./lib/mslib/handlers/sdp/unifiedPlanUtils.js\");\n/* harmony import */ var _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemoteUnifiedPlanSdp */ \"./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Safari12');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemoteUnifiedPlanSdp}\n\t\tthis._remoteSdp = new _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Ids of alive local tracks.\n\t\t// @type {Set<Number>}\n\t\tthis._trackIds = new Set();\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._trackIds.has(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet transceiver;\n\t\tlet localSdpObj;\n\n\t\t// Add the track id to the Set.\n\t\tthis._trackIds.add(track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Let's check if there is any inactive transceiver for same kind and\n\t\t\t\t// reuse it if so.\n\t\t\t\ttransceiver = this._pc.getTransceivers()\n\t\t\t\t\t.find((t) => t.receiver.track.kind === track.kind && t.direction === 'inactive');\n\n\t\t\t\tif (transceiver)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | reusing an inactive transceiver');\n\n\t\t\t\t\ttransceiver.direction = 'sendonly';\n\n\t\t\t\t\treturn transceiver.sender.replaceTrack(track);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttransceiver = this._pc.addTransceiver(track, { direction: 'sendonly' });\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => this._pc.createOffer())\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\t// If simulcast is set, mangle the offer.\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tconst sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t\t_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"addPlanBSimulcast\"](\n\t\t\t\t\t\tsdpObject, track, { mid: transceiver.mid });\n\n\t\t\t\t\tconst offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n\t\t\t\t\toffer = { type: 'offer', sdp: offerSdp };\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters,\n\t\t\t\t\tlocalSdpObj,\n\t\t\t\t\ttrack,\n\t\t\t\t\t{ mid: transceiver.mid, planBSimulcast: true });\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\ttry { transceiver.direction = 'inactive'; }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthis._trackIds.delete(track.id);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tif (!this._trackIds.has(track.id))\n\t\t\treturn Promise.reject(new Error('track not found'));\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === track);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\tthis._pc.removeTrack(rtpSender);\n\n\t\t\t\t// Remove the track id from the Set.\n\t\t\t\tthis._trackIds.delete(track.id);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === oldTrack);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\treturn rtpSender.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track id from the Set.\n\t\t\t\tthis._trackIds.delete(oldTrack.id);\n\n\t\t\t\t// Add the new track id to the Set.\n\t\t\t\tthis._trackIds.add(track.id);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of send', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"addPlanBSimulcast\"](sdpObject, track, {\n                    mid: transceiver.mid\n                });\n\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - mid {String}\n\t\t// - kind {String}\n\t\t// - closed {Boolean}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tmid      : `${consumer.kind[0]}${consumer.id}`,\n\t\t\tkind     : consumer.kind,\n\t\t\tclosed   : consumer.closed,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() => this._pc.createAnswer())\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst transceiver = this._pc.getTransceivers()\n\t\t\t\t\t.find((t) => t.mid === consumerInfo.mid);\n\n\t\t\t\tif (!transceiver)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn transceiver.receiver.track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tconst consumerInfo = this._consumerInfos.get(consumer.id);\n\n\t\tif (!consumerInfo)\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tconsumerInfo.closed = true;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of recv', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n}\n\nclass Safari12\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Safari12';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\tpc.addTransceiver('audio');\n\t\tpc.addTransceiver('video');\n\n\t\treturn pc.createOffer()\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Safari12.js?");

/***/ }),

/***/ "./lib/mslib/handlers/Safari13.js":
/*!****************************************!*\
  !*** ./lib/mslib/handlers/Safari13.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Safari13; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ \"./lib/mslib/utils.js\");\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony import */ var _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sdp/unifiedPlanUtils */ \"./lib/mslib/handlers/sdp/unifiedPlanUtils.js\");\n/* harmony import */ var _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sdp/RemoteUnifiedPlanSdp */ \"./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js\");\n/* harmony import */ var _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sdp/bandwidthHandler */ \"./lib/mslib/handlers/sdp/bandwidthHandler.js\");\n\n\n\n\n\n\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('Safari13');\n\nclass Handler extends _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n{\n\tconstructor(direction, rtpParametersByKind, settings)\n\t{\n\t\tsuper(logger);\n\n\t\t// RTCPeerConnection instance.\n\t\t// @type {RTCPeerConnection}\n\t\tthis._pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : settings.turnServers || [],\n\t\t\t\ticeTransportPolicy : settings.iceTransportPolicy,\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Remote SDP handler.\n\t\t// @type {RemoteUnifiedPlanSdp}\n\t\tthis._remoteSdp = new _sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_7__[\"default\"](direction, rtpParametersByKind);\n\n\t\t// Handle RTCPeerConnection connection status.\n\t\tthis._pc.addEventListener('iceconnectionstatechange', () =>\n\t\t{\n\t\t\tswitch (this._pc.iceConnectionState)\n\t\t\t{\n\t\t\t\tcase 'checking':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connecting');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'connected':\n\t\t\t\tcase 'completed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'connected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'failed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'failed');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'disconnected':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'disconnected');\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'closed':\n\t\t\t\t\tthis.emit('@connectionstatechange', 'closed');\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\t// Close RTCPeerConnection.\n\t\ttry { this._pc.close(); }\n\t\tcatch (error) {}\n\t}\n\n\tremoteClosed()\n\t{\n\t\tlogger.debug('remoteClosed()');\n\n\t\tthis._transportReady = false;\n\n\t\tif (this._transportUpdated)\n\t\t\tthis._transportUpdated = false;\n\t}\n}\n\nclass SendHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('send', rtpParametersByKind, settings);\n\n\t\t// Got transport local and remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportReady = false;\n\n\t\t// Ids of alive local tracks.\n\t\t// @type {Set<Number>}\n\t\tthis._trackIds = new Set();\n\t}\n\n\taddProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tlogger.debug(\n\t\t\t'addProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tif (this._trackIds.has(track.id))\n\t\t\treturn Promise.reject(new Error('track already added'));\n\n\t\tlet transceiver;\n\t\tlet localSdpObj;\n\n\t\t// Add the track id to the Set.\n\t\tthis._trackIds.add(track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Let's check if there is any inactive transceiver for same kind and\n\t\t\t\t// reuse it if so.\n\t\t\t\ttransceiver = this._pc.getTransceivers()\n\t\t\t\t\t.find((t) => t.receiver.track.kind === track.kind && t.direction === 'inactive');\n\n\t\t\t\tif (transceiver)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | reusing an inactive transceiver');\n\n\t\t\t\t\ttransceiver.direction = 'sendonly';\n\n\t\t\t\t\treturn transceiver.sender.replaceTrack(track);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttransceiver = this._pc.addTransceiver(track, { direction: 'sendonly' });\n\t\t\t\t}\n\t\t\t})\n\t\t\t.then(() => this._pc.createOffer())\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\t// If simulcast is set, mangle the offer.\n\t\t\t\tif (producer.simulcast)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug('addProducer() | enabling simulcast');\n\n\t\t\t\t\tconst sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n\t\t\t\t\t_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"addPlanBSimulcast\"](\n\t\t\t\t\t\tsdpObject, track, { mid: transceiver.mid });\n\n\t\t\t\t\tconst offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n\t\t\t\t\toffer = { type: 'offer', sdp: offerSdp };\n\t\t\t\t}\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportReady)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlocalSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n\n\t\t\t\t_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](\n\t\t\t\t\trtpParameters,\n\t\t\t\t\tlocalSdpObj,\n\t\t\t\t\ttrack,\n\t\t\t\t\t{ mid: transceiver.mid, planBSimulcast: true });\n\n\t\t\t\treturn rtpParameters;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\t// Panic here. Try to undo things.\n\n\t\t\t\ttry { transceiver.direction = 'inactive'; }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthis._trackIds.delete(track.id);\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tremoveProducer(producer)\n\t{\n\t\tconst { track } = producer;\n\n\t\tif (!this._trackIds.has(track.id))\n\t\t\treturn Promise.reject(new Error('track not found'));\n\n\t\tlogger.debug(\n\t\t\t'removeProducer() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === track);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\tthis._pc.removeTrack(rtpSender);\n\n\t\t\t\t// Remove the track id from the Set.\n\t\t\t\tthis._trackIds.delete(track.id);\n\n\t\t\t\treturn this._pc.createOffer();\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\t// for video bitrate - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tlet remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\n\t\t\t\t// for video bitrate - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\t\t\t\t\n\t\t\t\t// for opus profile - jove\n\t\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t\t// \n\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeProducer() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\treplaceProducerTrack(producer, track)\n\t{\n\t\tlogger.debug(\n\t\t\t'replaceProducerTrack() [id:%s, kind:%s, trackId:%s]',\n\t\t\tproducer.id, producer.kind, track.id);\n\n\t\tconst oldTrack = producer.track;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get the associated RTCRtpSender.\n\t\t\t\tconst rtpSender = this._pc.getSenders()\n\t\t\t\t\t.find((s) => s.track === oldTrack);\n\n\t\t\t\tif (!rtpSender)\n\t\t\t\t\tthrow new Error('local track not found');\n\n\t\t\t\treturn rtpSender.replaceTrack(track);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Remove the old track id from the Set.\n\t\t\t\tthis._trackIds.delete(oldTrack.id);\n\n\t\t\t\t// Add the new track id to the Set.\n\t\t\t\tthis._trackIds.add(track.id);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createOffer({ iceRestart: true });\n\t\t\t})\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setLocalDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\t\t\t\tconst remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n\t\t\t\tconst answer = { type: 'answer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// Get our local DTLS parameters.\n\t\t\t\tconst transportLocalParameters = {};\n\t\t\t\tconst sdp = this._pc.localDescription.sdp;\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\t\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\n\t\t\t\t// Let's decide that we'll be DTLS server (because we can).\n\t\t\t\tdtlsParameters.role = 'server';\n\n\t\t\t\ttransportLocalParameters.dtlsParameters = dtlsParameters;\n\n\t\t\t\t// Provide the remote SDP handler with transport local parameters.\n\t\t\t\tthis._remoteSdp.setTransportLocalParameters(transportLocalParameters);\n\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise(\n\t\t\t\t\t'@needcreatetransport', transportLocalParameters);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportReady = true;\n\t\t\t});\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of send', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n\n    updateTrack(producer, track)\n    {\n\n        logger.debug('update Track() [trackId:%s]', track.id);\n        var localSdpObj; // Add the track id to the Set.\n        var transceiver;\n\n        return Promise.resolve().then(() => {\n            // Let's check if there is transceiver for same kind.\n            // One production consists video or (and) audio track(s).\n            transceiver = this._pc.getTransceivers().find((t) => {\n                return t.receiver.track.kind === track.kind;\n            });\n        }).then(() => {\n            return this._pc.createOffer();\n        }).then((offer) => {\n\t\t\t// for video bitrate - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(offer.sdp, producer.videoBitrateOptions);\n\t\t\t\n\t\t\t// for opus profile - jove\n\t\t\toffer.sdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(offer.sdp, producer.audioProfile);\n\t\t\t// \n\n            // If simulcast is set, mangle the offer.\n            // var offerSdp;\n            if (producer.simulcast) {\n                logger.debug('updateTrack() | enabling simulcast');\n\n                var sdpObject = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\n                _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"addPlanBSimulcast\"](sdpObject, track, {\n                    mid: transceiver.mid\n                });\n\n                var offerSdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObject);\n\n                offer = {\n                    type: 'offer',\n                    sdp: offerSdp\n                };\n            }\n\n            logger.debug('updateTrack() | calling pc.setLocalDescription() [offer:%o]', offer);\n            return this._pc.setLocalDescription(offer);\n        }).then(() => {\n            localSdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(this._pc.localDescription.sdp);\n\n            var remoteSdp = this._remoteSdp.createAnswerSdp(localSdpObj);\n            remoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setVideoBitrates(remoteSdp, producer.videoBitrateOptions);\n\n\t\t\t// for opus profile - jove\n\t\t\tremoteSdp = _sdp_bandwidthHandler__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setOpusAttributes(remoteSdp, producer.audioProfile);\n\t\t\t// \n\n            var answer = {\n                type: 'answer',\n                sdp: remoteSdp\n            };\n            logger.debug('updateTrack() | calling pc.setRemoteDescription() [answer:%o]', answer);\n            return this._pc.setRemoteDescription(answer);\n        }).then(() => {\n            var rtpParameters = _utils__WEBPACK_IMPORTED_MODULE_3__[\"clone\"](this._rtpParametersByKind[producer.kind]);\n            _sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_6__[\"fillRtpParametersForTrack\"](rtpParameters, localSdpObj, track, {\n                mid: transceiver.mid,\n                planBSimulcast: true\n            });\n            return rtpParameters;\n        }).catch((error) => {\n            // Panic here. Try to undo things.\n            // failed at here and nothing to do.\n            throw error;\n        });\n    }\n}\n\nclass RecvHandler extends Handler\n{\n\tconstructor(rtpParametersByKind, settings)\n\t{\n\t\tsuper('recv', rtpParametersByKind, settings);\n\n\t\t// Got transport remote parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportCreated = false;\n\n\t\t// Got transport local parameters.\n\t\t// @type {Boolean}\n\t\tthis._transportUpdated = false;\n\n\t\t// Map of Consumers information indexed by consumer.id.\n\t\t// - mid {String}\n\t\t// - kind {String}\n\t\t// - closed {Boolean}\n\t\t// - trackId {String}\n\t\t// - ssrc {Number}\n\t\t// - rtxSsrc {Number}\n\t\t// - cname {String}\n\t\t// @type {Map<Number, Object>}\n\t\tthis._consumerInfos = new Map();\n\t}\n\n\taddConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'addConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tif (this._consumerInfos.has(consumer.id))\n\t\t\treturn Promise.reject(new Error('Consumer already added'));\n\n\t\tconst encoding = consumer.rtpParameters.encodings[0];\n\t\tconst cname = consumer.rtpParameters.rtcp.cname;\n\t\tconst consumerInfo =\n\t\t{\n\t\t\tmid      : `${consumer.kind[0]}${consumer.id}`,\n\t\t\tkind     : consumer.kind,\n\t\t\tclosed   : consumer.closed,\n\t\t\tstreamId : `recv-stream-${consumer.id}`,\n\t\t\ttrackId  : `consumer-${consumer.kind}-${consumer.id}`,\n\t\t\tssrc     : encoding.ssrc,\n\t\t\tcname    : cname\n\t\t};\n\n\t\tif (encoding.rtx && encoding.rtx.ssrc)\n\t\t\tconsumerInfo.rtxSsrc = encoding.rtx.ssrc;\n\n\t\tthis._consumerInfos.set(consumer.id, consumerInfo);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportCreated)\n\t\t\t\t\treturn this._setupTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() => this._pc.createAnswer())\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'addConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tif (!this._transportUpdated)\n\t\t\t\t\treturn this._updateTransport();\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst transceiver = this._pc.getTransceivers()\n\t\t\t\t\t.find((t) => t.mid === consumerInfo.mid);\n\n\t\t\t\tif (!transceiver)\n\t\t\t\t\tthrow new Error('remote track not found');\n\n\t\t\t\treturn transceiver.receiver.track;\n\t\t\t});\n\t}\n\n\tremoveConsumer(consumer)\n\t{\n\t\tlogger.debug(\n\t\t\t'removeConsumer() [id:%s, kind:%s]', consumer.id, consumer.kind);\n\n\t\tconst consumerInfo = this._consumerInfos.get(consumer.id);\n\n\t\tif (!consumerInfo)\n\t\t\treturn Promise.reject(new Error('Consumer not found'));\n\n\t\tconsumerInfo.closed = true;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'removeConsumer() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\trestartIce(remoteIceParameters)\n\t{\n\t\tlogger.debug('restartIce()');\n\n\t\t// Provide the remote SDP handler with new remote ICE parameters.\n\t\tthis._remoteSdp.updateTransportRemoteIceParameters(remoteIceParameters);\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tconst remoteSdp = this._remoteSdp.createOfferSdp(\n\t\t\t\t\tArray.from(this._consumerInfos.values()));\n\t\t\t\tconst offer = { type: 'offer', sdp: remoteSdp };\n\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setRemoteDescription() [offer:%o]',\n\t\t\t\t\toffer);\n\n\t\t\t\treturn this._pc.setRemoteDescription(offer);\n\t\t\t})\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn this._pc.createAnswer();\n\t\t\t})\n\t\t\t.then((answer) =>\n\t\t\t{\n\t\t\t\tlogger.debug(\n\t\t\t\t\t'restartIce() | calling pc.setLocalDescription() [answer:%o]',\n\t\t\t\t\tanswer);\n\n\t\t\t\treturn this._pc.setLocalDescription(answer);\n\t\t\t});\n\t}\n\n\t_setupTransport()\n\t{\n\t\tlogger.debug('_setupTransport()');\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// We need transport remote parameters.\n\t\t\t\treturn this.safeEmitAsPromise('@needcreatetransport', null);\n\t\t\t})\n\t\t\t.then((transportRemoteParameters) =>\n\t\t\t{\n\t\t\t\t// Provide the remote SDP handler with transport remote parameters.\n\t\t\t\tthis._remoteSdp.setTransportRemoteParameters(transportRemoteParameters);\n\n\t\t\t\tthis._transportCreated = true;\n\t\t\t});\n\t}\n\n\t_updateTransport()\n\t{\n\t\tlogger.debug('_updateTransport()');\n\n\t\t// Get our local DTLS parameters.\n\t\tconst sdp = this._pc.localDescription.sdp;\n\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(sdp);\n\t\tconst dtlsParameters = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractDtlsParameters\"](sdpObj);\n\t\tconst transportLocalParameters = { dtlsParameters };\n\n\t\t// We need to provide transport local parameters.\n\t\tthis.safeEmit('@needupdatetransport', transportLocalParameters);\n\n\t\tthis._transportUpdated = true;\n\t}\n\n    getPCStats(selector)\n    {\n        // logger.debug('getPCStats of send', selector);\n        return this._pc.getStats(selector).then((stats) => {\n            return stats;\n        }).catch((e) => {\n            throw e;\n        })\n    }\n}\n\nclass Safari13\n{\n\tstatic get tag()\n\t{\n\t\treturn 'Safari13';\n\t}\n\n\tstatic getNativeRtpCapabilities()\n\t{\n\t\tlogger.debug('getNativeRtpCapabilities()');\n\n\t\tconst pc = new RTCPeerConnection(\n\t\t\t{\n\t\t\t\ticeServers         : [],\n\t\t\t\ticeTransportPolicy : 'all',\n\t\t\t\tbundlePolicy       : 'max-bundle',\n\t\t\t\trtcpMuxPolicy      : 'require'\n\t\t\t});\n\n\t\tpc.addTransceiver('audio');\n\t\tpc.addTransceiver('video');\n\n\t\treturn pc.createOffer()\n\t\t\t.then((offer) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error) {}\n\n\t\t\t\tconst sdpObj = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parse(offer.sdp);\n\t\t\t\tconst nativeRtpCapabilities = _sdp_commonUtils__WEBPACK_IMPORTED_MODULE_5__[\"extractRtpCapabilities\"](sdpObj);\n\n\t\t\t\treturn nativeRtpCapabilities;\n\t\t\t})\n\t\t\t.catch((error) =>\n\t\t\t{\n\t\t\t\ttry { pc.close(); }\n\t\t\t\tcatch (error2) {}\n\n\t\t\t\tthrow error;\n\t\t\t});\n\t}\n\n\tconstructor(direction, extendedRtpCapabilities, settings)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, extendedRtpCapabilities:%o]',\n\t\t\tdirection, extendedRtpCapabilities);\n\n\t\tlet rtpParametersByKind;\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getSendingRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new SendHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t\tcase 'recv':\n\t\t\t{\n\t\t\t\trtpParametersByKind =\n\t\t\t\t{\n\t\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('audio', extendedRtpCapabilities),\n\t\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_4__[\"getReceivingFullRtpParameters\"]('video', extendedRtpCapabilities)\n\t\t\t\t};\n\n\t\t\t\treturn new RecvHandler(rtpParametersByKind, settings);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/Safari13.js?");

/***/ }),

/***/ "./lib/mslib/handlers/ortc/edgeUtils.js":
/*!**********************************************!*\
  !*** ./lib/mslib/handlers/ortc/edgeUtils.js ***!
  \**********************************************/
/*! exports provided: getCapabilities, mangleRtpParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCapabilities\", function() { return getCapabilities; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mangleRtpParameters\", function() { return mangleRtpParameters; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils */ \"./lib/mslib/utils.js\");\n/* global RTCRtpReceiver */\n\n\n\n/**\n * Normalize Edge's RTCRtpReceiver.getCapabilities() to produce a full\n * compliant ORTC RTCRtpCapabilities.\n *\n * @return {RTCRtpCapabilities}\n */\nfunction getCapabilities()\n{\n\tconst nativeCaps = RTCRtpReceiver.getCapabilities();\n\tconst caps = _utils__WEBPACK_IMPORTED_MODULE_0__[\"clone\"](nativeCaps);\n\n\tfor (const codec of caps.codecs)\n\t{\n\t\t// Rename numChannels to channels.\n\t\tcodec.channels = codec.numChannels;\n\t\tdelete codec.numChannels;\n\n\t\t// Normalize channels.\n\t\tif (codec.kind !== 'audio')\n\t\t\tdelete codec.channels;\n\t\telse if (!codec.channels)\n\t\t\tcodec.channels = 1;\n\n\t\t// Add mimeType.\n\t\tcodec.mimeType = `${codec.kind}/${codec.name}`;\n\n\t\t// NOTE: Edge sets some numeric parameters as String rather than Number. Fix them.\n\t\tif (codec.parameters)\n\t\t{\n\t\t\tconst parameters = codec.parameters;\n\n\t\t\tif (parameters.apt)\n\t\t\t\tparameters.apt = Number(parameters.apt);\n\n\t\t\tif (parameters['packetization-mode'])\n\t\t\t\tparameters['packetization-mode'] = Number(parameters['packetization-mode']);\n\t\t}\n\n\t\t// Delete emty parameter String in rtcpFeedback.\n\t\tfor (const feedback of codec.rtcpFeedback || [])\n\t\t{\n\t\t\tif (!feedback.parameter)\n\t\t\t\tdelete feedback.parameter;\n\t\t}\n\t}\n\n\treturn caps;\n}\n\n/**\n * Generate RTCRtpParameters as Edge like them.\n *\n * @param  {RTCRtpParameters} rtpParameters\n * @return {RTCRtpParameters}\n */\nfunction mangleRtpParameters(rtpParameters)\n{\n\tconst params = _utils__WEBPACK_IMPORTED_MODULE_0__[\"clone\"](rtpParameters);\n\n\tfor (const codec of params.codecs)\n\t{\n\t\t// Rename channels to numChannels.\n\t\tif (codec.channels)\n\t\t{\n\t\t\tcodec.numChannels = codec.channels;\n\t\t\tdelete codec.channels;\n\t\t}\n\n\t\t// Remove mimeType.\n\t\tdelete codec.mimeType;\n\t}\n\n\treturn params;\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/ortc/edgeUtils.js?");

/***/ }),

/***/ "./lib/mslib/handlers/sdp/RemotePlainRtpSdp.js":
/*!*****************************************************!*\
  !*** ./lib/mslib/handlers/sdp/RemotePlainRtpSdp.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RemotePlainRtpSdp; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ \"./lib/mslib/utils.js\");\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('RemotePlainRtpSdp');\n\nclass RemoteSdp\n{\n\tconstructor(rtpParametersByKind)\n\t{\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Transport local parameters, including plain RTP parameteres.\n\t\t// @type {Object}\n\t\tthis._transportLocalParameters = null;\n\n\t\t// Transport remote parameters, including plain RTP parameters.\n\t\t// @type {Object}\n\t\tthis._transportRemoteParameters = null;\n\n\t\t// SDP global fields.\n\t\t// @type {Object}\n\t\tthis._sdpGlobalFields =\n\t\t{\n\t\t\tid      : _utils__WEBPACK_IMPORTED_MODULE_2__[\"randomNumber\"](),\n\t\t\tversion : 0\n\t\t};\n\t}\n\n\tsetTransportLocalParameters(transportLocalParameters)\n\t{\n\t\tlogger.debug(\n\t\t\t'setTransportLocalParameters() [transportLocalParameters:%o]',\n\t\t\ttransportLocalParameters);\n\n\t\tthis._transportLocalParameters = transportLocalParameters;\n\t}\n\n\tsetTransportRemoteParameters(transportRemoteParameters)\n\t{\n\t\tlogger.debug(\n\t\t\t'setTransportRemoteParameters() [transportRemoteParameters:%o]',\n\t\t\ttransportRemoteParameters);\n\n\t\tthis._transportRemoteParameters = transportRemoteParameters;\n\t}\n}\n\nclass SendRemoteSdp extends RemoteSdp\n{\n\tconstructor(rtpParametersByKind)\n\t{\n\t\tsuper(rtpParametersByKind);\n\t}\n\n\tcreateAnswerSdp(localSdpObj)\n\t{\n\t\tlogger.debug('createAnswerSdp()');\n\n\t\tif (!this._transportLocalParameters)\n\t\t\tthrow new Error('no transport local parameters');\n\t\telse if (!this._transportRemoteParameters)\n\t\t\tthrow new Error('no transport remote parameters');\n\n\t\tconst remotePlainRtpParameters = this._transportRemoteParameters.plainRtpParameters;\n\t\tconst sdpObj = {};\n\t\tconst mids = (localSdpObj.media || [])\n\t\t\t.filter((m) => m.hasOwnProperty('mid'))\n\t\t\t.map((m) => String(m.mid));\n\n\t\t// Increase our SDP version.\n\t\tthis._sdpGlobalFields.version++;\n\n\t\tsdpObj.version = 0;\n\t\tsdpObj.origin =\n\t\t{\n\t\t\taddress        : remotePlainRtpParameters.ip,\n\t\t\tipVer          : remotePlainRtpParameters.version,\n\t\t\tnetType        : 'IN',\n\t\t\tsessionId      : this._sdpGlobalFields.id,\n\t\t\tsessionVersion : this._sdpGlobalFields.version,\n\t\t\tusername       : 'mediasoup-client'\n\t\t};\n\t\tsdpObj.name = '-';\n\t\tsdpObj.timing = { start: 0, stop: 0 };\n\n\t\tsdpObj.msidSemantic =\n\t\t{\n\t\t\tsemantic : 'WMS',\n\t\t\ttoken    : '*'\n\t\t};\n\n\t\tif (mids.length > 0)\n\t\t{\n\t\t\tsdpObj.groups =\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\ttype : 'BUNDLE',\n\t\t\t\t\tmids : mids.join(' ')\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\n\t\tsdpObj.media = [];\n\n\t\tfor (const localMediaObj of localSdpObj.media || [])\n\t\t{\n\t\t\tconst closed = localMediaObj.direction === 'inactive';\n\t\t\tconst kind = localMediaObj.type;\n\t\t\tconst codecs = this._rtpParametersByKind[kind].codecs;\n\t\t\tconst headerExtensions = this._rtpParametersByKind[kind].headerExtensions;\n\t\t\tconst remoteMediaObj = {};\n\n\t\t\tremoteMediaObj.type = localMediaObj.type;\n\n\t\t\tremoteMediaObj.port = remotePlainRtpParameters.port;\n\t\t\tremoteMediaObj.protocol = 'RTP/AVP';\n\t\t\tremoteMediaObj.connection =\n\t\t\t\t{\n\t\t\t\t\tip      : remotePlainRtpParameters.ip,\n\t\t\t\t\tversion : remotePlainRtpParameters.version\n\t\t\t\t};\n\t\t\tremoteMediaObj.mid = localMediaObj.mid;\n\n\t\t\tswitch (localMediaObj.direction)\n\t\t\t{\n\t\t\t\tcase 'sendrecv':\n\t\t\t\tcase 'sendonly':\n\t\t\t\t\tremoteMediaObj.direction = 'recvonly';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'recvonly':\n\t\t\t\tcase 'inactive':\n\t\t\t\t\tremoteMediaObj.direction = 'inactive';\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tremoteMediaObj.rtp = [];\n\t\t\tremoteMediaObj.rtcpFb = [];\n\t\t\tremoteMediaObj.fmtp = [];\n\n\t\t\tfor (const codec of codecs)\n\t\t\t{\n\t\t\t\tconst rtp =\n\t\t\t\t{\n\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\tcodec   : codec.name,\n\t\t\t\t\trate    : codec.clockRate\n\t\t\t\t};\n\n\t\t\t\tif (codec.channels > 1)\n\t\t\t\t\trtp.encoding = codec.channels;\n\n\t\t\t\tremoteMediaObj.rtp.push(rtp);\n\n\t\t\t\tif (codec.parameters)\n\t\t\t\t{\n\t\t\t\t\tconst paramFmtp =\n\t\t\t\t\t{\n\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\tconfig  : ''\n\t\t\t\t\t};\n\n\t\t\t\t\tfor (const key of Object.keys(codec.parameters))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\t\tparamFmtp.config += ';';\n\n\t\t\t\t\t\tparamFmtp.config += `${key}=${codec.parameters[key]}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\tremoteMediaObj.fmtp.push(paramFmtp);\n\t\t\t\t}\n\n\t\t\t\tif (codec.rtcpFeedback)\n\t\t\t\t{\n\t\t\t\t\tfor (const fb of codec.rtcpFeedback)\n\t\t\t\t\t{\n\t\t\t\t\t\tremoteMediaObj.rtcpFb.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\t\t\ttype    : fb.type,\n\t\t\t\t\t\t\t\tsubtype : fb.parameter || ''\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremoteMediaObj.payloads = codecs\n\t\t\t\t.map((codec) => codec.payloadType)\n\t\t\t\t.join(' ');\n\n\t\t\tif (!closed)\n\t\t\t{\n\t\t\t\tremoteMediaObj.ext = [];\n\n\t\t\t\tfor (const ext of headerExtensions)\n\t\t\t\t{\n\t\t\t\t\t// Don't add a header extension if not present in the offer.\n\t\t\t\t\tconst matchedLocalExt = (localMediaObj.ext || [])\n\t\t\t\t\t\t.find((localExt) => localExt.uri === ext.uri);\n\n\t\t\t\t\tif (!matchedLocalExt)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tremoteMediaObj.ext.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\turi   : ext.uri,\n\t\t\t\t\t\t\tvalue : ext.id\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Simulcast.\n\t\t\tif (localMediaObj.simulcast_03)\n\t\t\t{\n\t\t\t\t// eslint-disable-next-line camelcase\n\t\t\t\tremoteMediaObj.simulcast_03 =\n\t\t\t\t{\n\t\t\t\t\tvalue : localMediaObj.simulcast_03.value.replace(/send/g, 'recv')\n\t\t\t\t};\n\n\t\t\t\tremoteMediaObj.rids = [];\n\n\t\t\t\tfor (const rid of localMediaObj.rids || [])\n\t\t\t\t{\n\t\t\t\t\tif (rid.direction !== 'send')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tremoteMediaObj.rids.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid        : rid.id,\n\t\t\t\t\t\t\tdirection : 'recv'\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremoteMediaObj.rtcpMux = 'rtcp-mux';\n\t\t\tremoteMediaObj.rtcpRsize = 'rtcp-rsize';\n\n\t\t\t// Push it.\n\t\t\tsdpObj.media.push(remoteMediaObj);\n\t\t}\n\n\t\tconst sdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObj);\n\n\t\treturn sdp;\n\t}\n}\n\nclass RecvRemoteSdp extends RemoteSdp\n{\n\tconstructor(rtpParametersByKind)\n\t{\n\t\tsuper(rtpParametersByKind);\n\t}\n\n\t/**\n\t * @param {Array<Object>} consumerInfos - Consumer informations.\n\t * @return {String}\n\t */\n\tcreateOfferSdp(consumerInfos)\n\t{\n\t\tlogger.debug('createOfferSdp()');\n\n\t\tif (!this._transportRemoteParameters)\n\t\t\tthrow new Error('no transport remote parameters');\n\n\t\tconst remotePlainRtpParameters = this._transportRemoteParameters.plainRtpParameters;\n\t\tconst sdpObj = {};\n\t\tconst mids = consumerInfos\n\t\t\t.map((info) => String(info.mid));\n\n\t\t// Increase our SDP version.\n\t\tthis._sdpGlobalFields.version++;\n\n\t\tsdpObj.version = 0;\n\t\tsdpObj.origin =\n\t\t{\n\t\t\taddress        : remotePlainRtpParameters.ip,\n\t\t\tipVer          : remotePlainRtpParameters.version,\n\t\t\tnetType        : 'IN',\n\t\t\tsessionId      : this._sdpGlobalFields.id,\n\t\t\tsessionVersion : this._sdpGlobalFields.version,\n\t\t\tusername       : 'mediasoup-client'\n\t\t};\n\t\tsdpObj.name = '-';\n\t\tsdpObj.timing = { start: 0, stop: 0 };\n\n\t\tsdpObj.msidSemantic =\n\t\t{\n\t\t\tsemantic : 'WMS',\n\t\t\ttoken    : '*'\n\t\t};\n\n\t\tif (mids.length > 0)\n\t\t{\n\t\t\tsdpObj.groups =\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\ttype : 'BUNDLE',\n\t\t\t\t\tmids : mids.join(' ')\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\n\t\tsdpObj.media = [];\n\n\t\tfor (const info of consumerInfos)\n\t\t{\n\t\t\tconst closed = info.closed;\n\t\t\tconst kind = info.kind;\n\t\t\tconst codecs = this._rtpParametersByKind[kind].codecs;\n\t\t\tconst headerExtensions = this._rtpParametersByKind[kind].headerExtensions;\n\t\t\tconst remoteMediaObj = {};\n\n\t\t\tremoteMediaObj.type = kind;\n\t\t\tremoteMediaObj.mid = info.mid;\n\t\t\tremoteMediaObj.msid = `${info.streamId} ${info.trackId}`;\n\t\t\tremoteMediaObj.port = remotePlainRtpParameters.port;\n\t\t\tremoteMediaObj.protocol = 'RTP/AVP';\n\t\t\tremoteMediaObj.connection =\n\t\t\t\t{\n\t\t\t\t\tip      : remotePlainRtpParameters.ip,\n\t\t\t\t\tversion : remotePlainRtpParameters.version\n\t\t\t\t};\n\n\t\t\tif (!closed)\n\t\t\t\tremoteMediaObj.direction = 'sendonly';\n\t\t\telse\n\t\t\t\tremoteMediaObj.direction = 'inactive';\n\n\t\t\tremoteMediaObj.rtp = [];\n\t\t\tremoteMediaObj.rtcpFb = [];\n\t\t\tremoteMediaObj.fmtp = [];\n\n\t\t\tfor (const codec of codecs)\n\t\t\t{\n\t\t\t\tconst rtp =\n\t\t\t\t{\n\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\tcodec   : codec.name,\n\t\t\t\t\trate    : codec.clockRate\n\t\t\t\t};\n\n\t\t\t\tif (codec.channels > 1)\n\t\t\t\t\trtp.encoding = codec.channels;\n\n\t\t\t\tremoteMediaObj.rtp.push(rtp);\n\n\t\t\t\tif (codec.parameters)\n\t\t\t\t{\n\t\t\t\t\tconst paramFmtp =\n\t\t\t\t\t{\n\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\tconfig  : ''\n\t\t\t\t\t};\n\n\t\t\t\t\tfor (const key of Object.keys(codec.parameters))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\t\tparamFmtp.config += ';';\n\n\t\t\t\t\t\tparamFmtp.config += `${key}=${codec.parameters[key]}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\tremoteMediaObj.fmtp.push(paramFmtp);\n\t\t\t\t}\n\n\t\t\t\tif (codec.rtcpFeedback)\n\t\t\t\t{\n\t\t\t\t\tfor (const fb of codec.rtcpFeedback)\n\t\t\t\t\t{\n\t\t\t\t\t\tremoteMediaObj.rtcpFb.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\t\t\ttype    : fb.type,\n\t\t\t\t\t\t\t\tsubtype : fb.parameter || ''\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremoteMediaObj.payloads = codecs\n\t\t\t\t.map((codec) => codec.payloadType)\n\t\t\t\t.join(' ');\n\n\t\t\tif (!closed)\n\t\t\t{\n\t\t\t\tremoteMediaObj.ext = [];\n\n\t\t\t\tfor (const ext of headerExtensions)\n\t\t\t\t{\n\t\t\t\t\t// Ignore MID RTP extension for receiving media.\n\t\t\t\t\tif (ext.uri === 'urn:ietf:params:rtp-hdrext:sdes:mid')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tremoteMediaObj.ext.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\turi   : ext.uri,\n\t\t\t\t\t\t\tvalue : ext.id\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremoteMediaObj.rtcpMux = 'rtcp-mux';\n\t\t\tremoteMediaObj.rtcpRsize = 'rtcp-rsize';\n\n\t\t\tif (!closed)\n\t\t\t{\n\t\t\t\tremoteMediaObj.ssrcs = [];\n\t\t\t\tremoteMediaObj.ssrcGroups = [];\n\n\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tid        : info.ssrc,\n\t\t\t\t\t\tattribute : 'cname',\n\t\t\t\t\t\tvalue     : info.cname\n\t\t\t\t\t});\n\n\t\t\t\tif (info.rtxSsrc)\n\t\t\t\t{\n\t\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid        : info.rtxSsrc,\n\t\t\t\t\t\t\tattribute : 'cname',\n\t\t\t\t\t\t\tvalue     : info.cname\n\t\t\t\t\t\t});\n\n\t\t\t\t\t// Associate original and retransmission SSRC.\n\t\t\t\t\tremoteMediaObj.ssrcGroups.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsemantics : 'FID',\n\t\t\t\t\t\t\tssrcs     : `${info.ssrc} ${info.rtxSsrc}`\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Push it.\n\t\t\tsdpObj.media.push(remoteMediaObj);\n\t\t}\n\n\t\tconst sdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObj);\n\n\t\treturn sdp;\n\t}\n}\n\nclass RemotePlainRtpSdp\n{\n\tconstructor(direction, rtpParametersByKind)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, rtpParametersByKind:%o]',\n\t\t\tdirection, rtpParametersByKind);\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t\treturn new SendRemoteSdp(rtpParametersByKind);\n\t\t\tcase 'recv':\n\t\t\t\treturn new RecvRemoteSdp(rtpParametersByKind);\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/sdp/RemotePlainRtpSdp.js?");

/***/ }),

/***/ "./lib/mslib/handlers/sdp/RemotePlanBSdp.js":
/*!**************************************************!*\
  !*** ./lib/mslib/handlers/sdp/RemotePlanBSdp.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RemotePlanBSdp; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ \"./lib/mslib/utils.js\");\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('RemotePlanBSdp');\n\nclass RemoteSdp\n{\n\tconstructor(rtpParametersByKind)\n\t{\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Transport local parameters, including DTLS parameteres.\n\t\t// @type {Object}\n\t\tthis._transportLocalParameters = null;\n\n\t\t// Transport remote parameters, including ICE parameters, ICE candidates\n\t\t// and DTLS parameteres.\n\t\t// @type {Object}\n\t\tthis._transportRemoteParameters = null;\n\n\t\t// SDP global fields.\n\t\t// @type {Object}\n\t\tthis._sdpGlobalFields =\n\t\t{\n\t\t\tid      : _utils__WEBPACK_IMPORTED_MODULE_2__[\"randomNumber\"](),\n\t\t\tversion : 0\n\t\t};\n\t}\n\n\tsetTransportLocalParameters(transportLocalParameters)\n\t{\n\t\tlogger.debug(\n\t\t\t'setTransportLocalParameters() [transportLocalParameters:%o]',\n\t\t\ttransportLocalParameters);\n\n\t\tthis._transportLocalParameters = transportLocalParameters;\n\t}\n\n\tsetTransportRemoteParameters(transportRemoteParameters)\n\t{\n\t\tlogger.debug(\n\t\t\t'setTransportRemoteParameters() [transportRemoteParameters:%o]',\n\t\t\ttransportRemoteParameters);\n\n\t\tthis._transportRemoteParameters = transportRemoteParameters;\n\t}\n\n\tupdateTransportRemoteIceParameters(remoteIceParameters)\n\t{\n\t\tlogger.debug(\n\t\t\t'updateTransportRemoteIceParameters() [remoteIceParameters:%o]',\n\t\t\tremoteIceParameters);\n\n\t\tthis._transportRemoteParameters.iceParameters = remoteIceParameters;\n\t}\n}\n\nclass SendRemoteSdp extends RemoteSdp\n{\n\tconstructor(rtpParametersByKind)\n\t{\n\t\tsuper(rtpParametersByKind);\n\t}\n\n\tcreateAnswerSdp(localSdpObj)\n\t{\n\t\tlogger.debug('createAnswerSdp()');\n\n\t\tif (!this._transportLocalParameters)\n\t\t\tthrow new Error('no transport local parameters');\n\t\telse if (!this._transportRemoteParameters)\n\t\t\tthrow new Error('no transport remote parameters');\n\n\t\tconst remoteIceParameters = this._transportRemoteParameters.iceParameters;\n\t\tconst remoteIceCandidates = this._transportRemoteParameters.iceCandidates;\n\t\tconst remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;\n\t\tconst sdpObj = {};\n\t\tconst mids = (localSdpObj.media || [])\n\t\t\t.map((m) => String(m.mid));\n\n\t\t// Increase our SDP version.\n\t\tthis._sdpGlobalFields.version++;\n\n\t\tsdpObj.version = 0;\n\t\tsdpObj.origin =\n\t\t{\n\t\t\taddress        : '0.0.0.0',\n\t\t\tipVer          : 4,\n\t\t\tnetType        : 'IN',\n\t\t\tsessionId      : this._sdpGlobalFields.id,\n\t\t\tsessionVersion : this._sdpGlobalFields.version,\n\t\t\tusername       : 'mediasoup-client'\n\t\t};\n\t\tsdpObj.name = '-';\n\t\tsdpObj.timing = { start: 0, stop: 0 };\n\t\tsdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;\n\t\tsdpObj.msidSemantic =\n\t\t{\n\t\t\tsemantic : 'WMS',\n\t\t\ttoken    : '*'\n\t\t};\n\t\tsdpObj.groups =\n\t\t[\n\t\t\t{\n\t\t\t\ttype : 'BUNDLE',\n\t\t\t\tmids : mids.join(' ')\n\t\t\t}\n\t\t];\n\t\tsdpObj.media = [];\n\n\t\t// NOTE: We take the latest fingerprint.\n\t\tconst numFingerprints = remoteDtlsParameters.fingerprints.length;\n\n\t\tsdpObj.fingerprint =\n\t\t{\n\t\t\ttype : remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,\n\t\t\thash : remoteDtlsParameters.fingerprints[numFingerprints - 1].value\n\t\t};\n\n\t\tfor (const localMediaObj of localSdpObj.media || [])\n\t\t{\n\t\t\tconst kind = localMediaObj.type;\n\t\t\tconst codecs = this._rtpParametersByKind[kind].codecs;\n\t\t\tconst headerExtensions = this._rtpParametersByKind[kind].headerExtensions;\n\t\t\tconst remoteMediaObj = {};\n\n\t\t\tremoteMediaObj.type = localMediaObj.type;\n\t\t\tremoteMediaObj.port = 7;\n\t\t\tremoteMediaObj.protocol = 'RTP/SAVPF';\n\t\t\tremoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };\n\t\t\tremoteMediaObj.mid = localMediaObj.mid;\n\n\t\t\tremoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;\n\t\t\tremoteMediaObj.icePwd = remoteIceParameters.password;\n\t\t\tremoteMediaObj.candidates = [];\n\n\t\t\tfor (const candidate of remoteIceCandidates)\n\t\t\t{\n\t\t\t\tconst candidateObj = {};\n\n\t\t\t\t// mediasoup does not support non rtcp-mux so candidates component is\n\t\t\t\t// always RTP (1).\n\t\t\t\tcandidateObj.component = 1;\n\t\t\t\tcandidateObj.foundation = candidate.foundation;\n\t\t\t\tcandidateObj.ip = candidate.ip;\n\t\t\t\tcandidateObj.port = candidate.port;\n\t\t\t\tcandidateObj.priority = candidate.priority;\n\t\t\t\tcandidateObj.transport = candidate.protocol;\n\t\t\t\tcandidateObj.type = candidate.type;\n\t\t\t\tif (candidate.tcpType)\n\t\t\t\t\tcandidateObj.tcptype = candidate.tcpType;\n\n\t\t\t\tremoteMediaObj.candidates.push(candidateObj);\n\t\t\t}\n\n\t\t\tremoteMediaObj.endOfCandidates = 'end-of-candidates';\n\n\t\t\t// Announce support for ICE renomination.\n\t\t\t// https://tools.ietf.org/html/draft-thatcher-ice-renomination\n\t\t\tremoteMediaObj.iceOptions = 'renomination';\n\n\t\t\tswitch (remoteDtlsParameters.role)\n\t\t\t{\n\t\t\t\tcase 'client':\n\t\t\t\t\tremoteMediaObj.setup = 'active';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'server':\n\t\t\t\t\tremoteMediaObj.setup = 'passive';\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (localMediaObj.direction)\n\t\t\t{\n\t\t\t\tcase 'sendrecv':\n\t\t\t\tcase 'sendonly':\n\t\t\t\t\tremoteMediaObj.direction = 'recvonly';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'recvonly':\n\t\t\t\tcase 'inactive':\n\t\t\t\t\tremoteMediaObj.direction = 'inactive';\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// If video, be ready for simulcast.\n\t\t\tif (kind === 'video')\n\t\t\t\tremoteMediaObj.xGoogleFlag = 'conference';\n\n\t\t\tremoteMediaObj.rtp = [];\n\t\t\tremoteMediaObj.rtcpFb = [];\n\t\t\tremoteMediaObj.fmtp = [];\n\n\t\t\tfor (const codec of codecs)\n\t\t\t{\n\t\t\t\tconst rtp =\n\t\t\t\t{\n\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\tcodec   : codec.name,\n\t\t\t\t\trate    : codec.clockRate\n\t\t\t\t};\n\n\t\t\t\tif (codec.channels > 1)\n\t\t\t\t\trtp.encoding = codec.channels;\n\n\t\t\t\tremoteMediaObj.rtp.push(rtp);\n\n\t\t\t\tif (codec.parameters)\n\t\t\t\t{\n\t\t\t\t\tconst paramFmtp =\n\t\t\t\t\t{\n\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\tconfig  : ''\n\t\t\t\t\t};\n\n\t\t\t\t\tfor (const key of Object.keys(codec.parameters))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\t\tparamFmtp.config += ';';\n\n\t\t\t\t\t\tparamFmtp.config += `${key}=${codec.parameters[key]}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\tremoteMediaObj.fmtp.push(paramFmtp);\n\t\t\t\t}\n\n\t\t\t\tif (codec.rtcpFeedback)\n\t\t\t\t{\n\t\t\t\t\tfor (const fb of codec.rtcpFeedback)\n\t\t\t\t\t{\n\t\t\t\t\t\tremoteMediaObj.rtcpFb.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\t\t\ttype    : fb.type,\n\t\t\t\t\t\t\t\tsubtype : fb.parameter || ''\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremoteMediaObj.payloads = codecs\n\t\t\t\t.map((codec) => codec.payloadType)\n\t\t\t\t.join(' ');\n\n\t\t\tremoteMediaObj.ext = [];\n\n\t\t\tfor (const ext of headerExtensions)\n\t\t\t{\n\t\t\t\t// Don't add a header extension if not present in the offer.\n\t\t\t\tconst matchedLocalExt = (localMediaObj.ext || [])\n\t\t\t\t\t.find((localExt) => localExt.uri === ext.uri);\n\n\t\t\t\tif (!matchedLocalExt)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tremoteMediaObj.ext.push(\n\t\t\t\t\t{\n\t\t\t\t\t\turi   : ext.uri,\n\t\t\t\t\t\tvalue : ext.id\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tremoteMediaObj.rtcpMux = 'rtcp-mux';\n\t\t\tremoteMediaObj.rtcpRsize = 'rtcp-rsize';\n\n\t\t\t// Push it.\n\t\t\tsdpObj.media.push(remoteMediaObj);\n\t\t}\n\n\t\tconst sdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObj);\n\n\t\treturn sdp;\n\t}\n}\n\nclass RecvRemoteSdp extends RemoteSdp\n{\n\tconstructor(rtpParametersByKind)\n\t{\n\t\tsuper(rtpParametersByKind);\n\t}\n\n\t/**\n\t * @param {Array<String>} kinds - Media kinds.\n\t * @param {Array<Object>} consumerInfos - Consumer informations.\n\t * @return {String}\n\t */\n\tcreateOfferSdp(kinds, consumerInfos)\n\t{\n\t\tlogger.debug('createOfferSdp()');\n\n\t\tif (!this._transportRemoteParameters)\n\t\t\tthrow new Error('no transport remote parameters');\n\n\t\tconst remoteIceParameters = this._transportRemoteParameters.iceParameters;\n\t\tconst remoteIceCandidates = this._transportRemoteParameters.iceCandidates;\n\t\tconst remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;\n\t\tconst sdpObj = {};\n\t\tconst mids = kinds;\n\n\t\t// Increase our SDP version.\n\t\tthis._sdpGlobalFields.version++;\n\n\t\tsdpObj.version = 0;\n\t\tsdpObj.origin =\n\t\t{\n\t\t\taddress        : '0.0.0.0',\n\t\t\tipVer          : 4,\n\t\t\tnetType        : 'IN',\n\t\t\tsessionId      : this._sdpGlobalFields.id,\n\t\t\tsessionVersion : this._sdpGlobalFields.version,\n\t\t\tusername       : 'mediasoup-client'\n\t\t};\n\t\tsdpObj.name = '-';\n\t\tsdpObj.timing = { start: 0, stop: 0 };\n\t\tsdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;\n\t\tsdpObj.msidSemantic =\n\t\t{\n\t\t\tsemantic : 'WMS',\n\t\t\ttoken    : '*'\n\t\t};\n\t\tsdpObj.groups =\n\t\t[\n\t\t\t{\n\t\t\t\ttype : 'BUNDLE',\n\t\t\t\tmids : mids.join(' ')\n\t\t\t}\n\t\t];\n\t\tsdpObj.media = [];\n\n\t\t// NOTE: We take the latest fingerprint.\n\t\tconst numFingerprints = remoteDtlsParameters.fingerprints.length;\n\n\t\tsdpObj.fingerprint =\n\t\t{\n\t\t\ttype : remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,\n\t\t\thash : remoteDtlsParameters.fingerprints[numFingerprints - 1].value\n\t\t};\n\n\t\tfor (const kind of kinds)\n\t\t{\n\t\t\tconst codecs = this._rtpParametersByKind[kind].codecs;\n\t\t\tconst headerExtensions = this._rtpParametersByKind[kind].headerExtensions;\n\t\t\tconst remoteMediaObj = {};\n\n\t\t\tremoteMediaObj.type = kind;\n\t\t\tremoteMediaObj.port = 7;\n\t\t\tremoteMediaObj.protocol = 'RTP/SAVPF';\n\t\t\tremoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };\n\t\t\tremoteMediaObj.mid = kind;\n\n\t\t\tremoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;\n\t\t\tremoteMediaObj.icePwd = remoteIceParameters.password;\n\t\t\tremoteMediaObj.candidates = [];\n\n\t\t\tfor (const candidate of remoteIceCandidates)\n\t\t\t{\n\t\t\t\tconst candidateObj = {};\n\n\t\t\t\t// mediasoup does not support non rtcp-mux so candidates component is\n\t\t\t\t// always RTP (1).\n\t\t\t\tcandidateObj.component = 1;\n\t\t\t\tcandidateObj.foundation = candidate.foundation;\n\t\t\t\tcandidateObj.ip = candidate.ip;\n\t\t\t\tcandidateObj.port = candidate.port;\n\t\t\t\tcandidateObj.priority = candidate.priority;\n\t\t\t\tcandidateObj.transport = candidate.protocol;\n\t\t\t\tcandidateObj.type = candidate.type;\n\t\t\t\tif (candidate.tcpType)\n\t\t\t\t\tcandidateObj.tcptype = candidate.tcpType;\n\n\t\t\t\tremoteMediaObj.candidates.push(candidateObj);\n\t\t\t}\n\n\t\t\tremoteMediaObj.endOfCandidates = 'end-of-candidates';\n\n\t\t\t// Announce support for ICE renomination.\n\t\t\t// https://tools.ietf.org/html/draft-thatcher-ice-renomination\n\t\t\tremoteMediaObj.iceOptions = 'renomination';\n\n\t\t\tremoteMediaObj.setup = 'actpass';\n\n\t\t\tif (consumerInfos.some((info) => info.kind === kind))\n\t\t\t\tremoteMediaObj.direction = 'sendonly';\n\t\t\telse\n\t\t\t\tremoteMediaObj.direction = 'inactive';\n\n\t\t\tremoteMediaObj.rtp = [];\n\t\t\tremoteMediaObj.rtcpFb = [];\n\t\t\tremoteMediaObj.fmtp = [];\n\n\t\t\tfor (const codec of codecs)\n\t\t\t{\n\t\t\t\tconst rtp =\n\t\t\t\t{\n\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\tcodec   : codec.name,\n\t\t\t\t\trate    : codec.clockRate\n\t\t\t\t};\n\n\t\t\t\tif (codec.channels > 1)\n\t\t\t\t\trtp.encoding = codec.channels;\n\n\t\t\t\tremoteMediaObj.rtp.push(rtp);\n\n\t\t\t\tif (codec.parameters)\n\t\t\t\t{\n\t\t\t\t\tconst paramFmtp =\n\t\t\t\t\t{\n\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\tconfig  : ''\n\t\t\t\t\t};\n\n\t\t\t\t\tfor (const key of Object.keys(codec.parameters))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\t\tparamFmtp.config += ';';\n\n\t\t\t\t\t\tparamFmtp.config += `${key}=${codec.parameters[key]}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\tremoteMediaObj.fmtp.push(paramFmtp);\n\t\t\t\t}\n\n\t\t\t\tif (codec.rtcpFeedback)\n\t\t\t\t{\n\t\t\t\t\tfor (const fb of codec.rtcpFeedback)\n\t\t\t\t\t{\n\t\t\t\t\t\tremoteMediaObj.rtcpFb.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\t\t\ttype    : fb.type,\n\t\t\t\t\t\t\t\tsubtype : fb.parameter || ''\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremoteMediaObj.payloads = codecs\n\t\t\t\t.map((codec) => codec.payloadType)\n\t\t\t\t.join(' ');\n\n\t\t\tremoteMediaObj.ext = [];\n\n\t\t\tfor (const ext of headerExtensions)\n\t\t\t{\n\t\t\t\t// Ignore MID RTP extension for receiving media.\n\t\t\t\tif (ext.uri === 'urn:ietf:params:rtp-hdrext:sdes:mid')\n\t\t\t\t\tcontinue;\n\n\t\t\t\tremoteMediaObj.ext.push(\n\t\t\t\t\t{\n\t\t\t\t\t\turi   : ext.uri,\n\t\t\t\t\t\tvalue : ext.id\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tremoteMediaObj.rtcpMux = 'rtcp-mux';\n\t\t\tremoteMediaObj.rtcpRsize = 'rtcp-rsize';\n\n\t\t\tremoteMediaObj.ssrcs = [];\n\t\t\tremoteMediaObj.ssrcGroups = [];\n\n\t\t\tfor (const info of consumerInfos)\n\t\t\t{\n\t\t\t\tif (info.kind !== kind)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tid        : info.ssrc,\n\t\t\t\t\t\tattribute : 'msid',\n\t\t\t\t\t\tvalue     : `${info.streamId} ${info.trackId}`\n\t\t\t\t\t});\n\n\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tid        : info.ssrc,\n\t\t\t\t\t\tattribute : 'mslabel',\n\t\t\t\t\t\tvalue     : info.streamId\n\t\t\t\t\t});\n\n\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tid        : info.ssrc,\n\t\t\t\t\t\tattribute : 'label',\n\t\t\t\t\t\tvalue     : info.trackId\n\t\t\t\t\t});\n\n\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t{\n\t\t\t\t\t\tid        : info.ssrc,\n\t\t\t\t\t\tattribute : 'cname',\n\t\t\t\t\t\tvalue     : info.cname\n\t\t\t\t\t});\n\n\t\t\t\tif (info.rtxSsrc)\n\t\t\t\t{\n\t\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid        : info.rtxSsrc,\n\t\t\t\t\t\t\tattribute : 'msid',\n\t\t\t\t\t\t\tvalue     : `${info.streamId} ${info.trackId}`\n\t\t\t\t\t\t});\n\n\t\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid        : info.rtxSsrc,\n\t\t\t\t\t\t\tattribute : 'mslabel',\n\t\t\t\t\t\t\tvalue     : info.streamId\n\t\t\t\t\t\t});\n\n\t\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid        : info.rtxSsrc,\n\t\t\t\t\t\t\tattribute : 'label',\n\t\t\t\t\t\t\tvalue     : info.trackId\n\t\t\t\t\t\t});\n\n\t\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid        : info.rtxSsrc,\n\t\t\t\t\t\t\tattribute : 'cname',\n\t\t\t\t\t\t\tvalue     : info.cname\n\t\t\t\t\t\t});\n\n\t\t\t\t\t// Associate original and retransmission SSRC.\n\t\t\t\t\tremoteMediaObj.ssrcGroups.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsemantics : 'FID',\n\t\t\t\t\t\t\tssrcs     : `${info.ssrc} ${info.rtxSsrc}`\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Push it.\n\t\t\tsdpObj.media.push(remoteMediaObj);\n\t\t}\n\n\t\tconst sdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObj);\n\n\t\treturn sdp;\n\t}\n}\n\nclass RemotePlanBSdp\n{\n\tconstructor(direction, rtpParametersByKind)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, rtpParametersByKind:%o]',\n\t\t\tdirection, rtpParametersByKind);\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t\treturn new SendRemoteSdp(rtpParametersByKind);\n\t\t\tcase 'recv':\n\t\t\t\treturn new RecvRemoteSdp(rtpParametersByKind);\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/sdp/RemotePlanBSdp.js?");

/***/ }),

/***/ "./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js":
/*!********************************************************!*\
  !*** ./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RemoteUnifiedPlanSdp; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Logger */ \"./lib/mslib/Logger.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ \"./lib/mslib/utils.js\");\n\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('RemoteUnifiedPlanSdp');\n\nclass RemoteSdp\n{\n\tconstructor(rtpParametersByKind)\n\t{\n\t\t// Generic sending RTP parameters for audio and video.\n\t\t// @type {Object}\n\t\tthis._rtpParametersByKind = rtpParametersByKind;\n\n\t\t// Transport local parameters, including DTLS parameteres.\n\t\t// @type {Object}\n\t\tthis._transportLocalParameters = null;\n\n\t\t// Transport remote parameters, including ICE parameters, ICE candidates\n\t\t// and DTLS parameteres.\n\t\t// @type {Object}\n\t\tthis._transportRemoteParameters = null;\n\n\t\t// SDP global fields.\n\t\t// @type {Object}\n\t\tthis._sdpGlobalFields =\n\t\t{\n\t\t\tid      : _utils__WEBPACK_IMPORTED_MODULE_2__[\"randomNumber\"](),\n\t\t\tversion : 0\n\t\t};\n\t}\n\n\tsetTransportLocalParameters(transportLocalParameters)\n\t{\n\t\tlogger.debug(\n\t\t\t'setTransportLocalParameters() [transportLocalParameters:%o]',\n\t\t\ttransportLocalParameters);\n\n\t\tthis._transportLocalParameters = transportLocalParameters;\n\t}\n\n\tsetTransportRemoteParameters(transportRemoteParameters)\n\t{\n\t\tlogger.debug(\n\t\t\t'setTransportRemoteParameters() [transportRemoteParameters:%o]',\n\t\t\ttransportRemoteParameters);\n\n\t\tthis._transportRemoteParameters = transportRemoteParameters;\n\t}\n\n\tupdateTransportRemoteIceParameters(remoteIceParameters)\n\t{\n\t\tlogger.debug(\n\t\t\t'updateTransportRemoteIceParameters() [remoteIceParameters:%o]',\n\t\t\tremoteIceParameters);\n\n\t\tthis._transportRemoteParameters.iceParameters = remoteIceParameters;\n\t}\n}\n\nclass SendRemoteSdp extends RemoteSdp\n{\n\tconstructor(rtpParametersByKind)\n\t{\n\t\tsuper(rtpParametersByKind);\n\t}\n\n\tcreateAnswerSdp(localSdpObj)\n\t{\n\t\tlogger.debug('createAnswerSdp()');\n\n\t\tif (!this._transportLocalParameters)\n\t\t\tthrow new Error('no transport local parameters');\n\t\telse if (!this._transportRemoteParameters)\n\t\t\tthrow new Error('no transport remote parameters');\n\n\t\tconst remoteIceParameters = this._transportRemoteParameters.iceParameters;\n\t\tconst remoteIceCandidates = this._transportRemoteParameters.iceCandidates;\n\t\tconst remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;\n\t\tconst sdpObj = {};\n\t\tconst bundleMids = (localSdpObj.media || [])\n\t\t\t.filter((m) => m.hasOwnProperty('mid'))\n\t\t\t.map((m) => String(m.mid));\n\n\t\t// Increase our SDP version.\n\t\tthis._sdpGlobalFields.version++;\n\n\t\tsdpObj.version = 0;\n\t\tsdpObj.origin =\n\t\t{\n\t\t\taddress        : '0.0.0.0',\n\t\t\tipVer          : 4,\n\t\t\tnetType        : 'IN',\n\t\t\tsessionId      : this._sdpGlobalFields.id,\n\t\t\tsessionVersion : this._sdpGlobalFields.version,\n\t\t\tusername       : 'mediasoup-client'\n\t\t};\n\t\tsdpObj.name = '-';\n\t\tsdpObj.timing = { start: 0, stop: 0 };\n\t\tsdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;\n\t\tsdpObj.msidSemantic =\n\t\t{\n\t\t\tsemantic : 'WMS',\n\t\t\ttoken    : '*'\n\t\t};\n\n\t\tif (bundleMids.length > 0)\n\t\t{\n\t\t\tsdpObj.groups =\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\ttype : 'BUNDLE',\n\t\t\t\t\tmids : bundleMids.join(' ')\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\n\t\tsdpObj.media = [];\n\n\t\t// NOTE: We take the latest fingerprint.\n\t\tconst numFingerprints = remoteDtlsParameters.fingerprints.length;\n\n\t\tsdpObj.fingerprint =\n\t\t{\n\t\t\ttype : remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,\n\t\t\thash : remoteDtlsParameters.fingerprints[numFingerprints - 1].value\n\t\t};\n\n\t\tfor (const localMediaObj of localSdpObj.media || [])\n\t\t{\n\t\t\tconst closed = localMediaObj.direction === 'inactive';\n\t\t\tconst kind = localMediaObj.type;\n\t\t\tconst codecs = this._rtpParametersByKind[kind].codecs;\n\t\t\tconst headerExtensions = this._rtpParametersByKind[kind].headerExtensions;\n\t\t\tconst remoteMediaObj = {};\n\n\t\t\tremoteMediaObj.type = localMediaObj.type;\n\t\t\tremoteMediaObj.port = 7;\n\t\t\tremoteMediaObj.protocol = 'RTP/SAVPF';\n\t\t\tremoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };\n\t\t\tremoteMediaObj.mid = localMediaObj.mid;\n\n\t\t\tremoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;\n\t\t\tremoteMediaObj.icePwd = remoteIceParameters.password;\n\t\t\tremoteMediaObj.candidates = [];\n\n\t\t\tfor (const candidate of remoteIceCandidates)\n\t\t\t{\n\t\t\t\tconst candidateObj = {};\n\n\t\t\t\t// mediasoup does not support non rtcp-mux so candidates component is\n\t\t\t\t// always RTP (1).\n\t\t\t\tcandidateObj.component = 1;\n\t\t\t\tcandidateObj.foundation = candidate.foundation;\n\t\t\t\tcandidateObj.ip = candidate.ip;\n\t\t\t\tcandidateObj.port = candidate.port;\n\t\t\t\tcandidateObj.priority = candidate.priority;\n\t\t\t\tcandidateObj.transport = candidate.protocol;\n\t\t\t\tcandidateObj.type = candidate.type;\n\t\t\t\tif (candidate.tcpType)\n\t\t\t\t\tcandidateObj.tcptype = candidate.tcpType;\n\n\t\t\t\tremoteMediaObj.candidates.push(candidateObj);\n\t\t\t}\n\n\t\t\tremoteMediaObj.endOfCandidates = 'end-of-candidates';\n\n\t\t\t// Announce support for ICE renomination.\n\t\t\t// https://tools.ietf.org/html/draft-thatcher-ice-renomination\n\t\t\tremoteMediaObj.iceOptions = 'renomination';\n\n\t\t\tswitch (remoteDtlsParameters.role)\n\t\t\t{\n\t\t\t\tcase 'client':\n\t\t\t\t\tremoteMediaObj.setup = 'active';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'server':\n\t\t\t\t\tremoteMediaObj.setup = 'passive';\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (localMediaObj.direction)\n\t\t\t{\n\t\t\t\tcase 'sendrecv':\n\t\t\t\tcase 'sendonly':\n\t\t\t\t\tremoteMediaObj.direction = 'recvonly';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'recvonly':\n\t\t\t\tcase 'inactive':\n\t\t\t\t\tremoteMediaObj.direction = 'inactive';\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tremoteMediaObj.rtp = [];\n\t\t\tremoteMediaObj.rtcpFb = [];\n\t\t\tremoteMediaObj.fmtp = [];\n\n\t\t\tfor (const codec of codecs)\n\t\t\t{\n\t\t\t\tconst rtp =\n\t\t\t\t{\n\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\tcodec   : codec.name,\n\t\t\t\t\trate    : codec.clockRate\n\t\t\t\t};\n\n\t\t\t\tif (codec.channels > 1)\n\t\t\t\t\trtp.encoding = codec.channels;\n\n\t\t\t\tremoteMediaObj.rtp.push(rtp);\n\n\t\t\t\tif (codec.parameters)\n\t\t\t\t{\n\t\t\t\t\tconst paramFmtp =\n\t\t\t\t\t{\n\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\tconfig  : ''\n\t\t\t\t\t};\n\n\t\t\t\t\tfor (const key of Object.keys(codec.parameters))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\t\tparamFmtp.config += ';';\n\n\t\t\t\t\t\tparamFmtp.config += `${key}=${codec.parameters[key]}`;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\tremoteMediaObj.fmtp.push(paramFmtp);\n\t\t\t\t}\n\n\t\t\t\tif (codec.rtcpFeedback)\n\t\t\t\t{\n\t\t\t\t\tfor (const fb of codec.rtcpFeedback)\n\t\t\t\t\t{\n\t\t\t\t\t\tremoteMediaObj.rtcpFb.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\t\t\ttype    : fb.type,\n\t\t\t\t\t\t\t\tsubtype : fb.parameter || ''\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremoteMediaObj.payloads = codecs\n\t\t\t\t.map((codec) => codec.payloadType)\n\t\t\t\t.join(' ');\n\n\t\t\t// NOTE: Firefox does not like a=extmap lines if a=inactive.\n\t\t\tif (!closed)\n\t\t\t{\n\t\t\t\tremoteMediaObj.ext = [];\n\n\t\t\t\tfor (const ext of headerExtensions)\n\t\t\t\t{\n\t\t\t\t\t// Don't add a header extension if not present in the offer.\n\t\t\t\t\tconst matchedLocalExt = (localMediaObj.ext || [])\n\t\t\t\t\t\t.find((localExt) => localExt.uri === ext.uri);\n\n\t\t\t\t\tif (!matchedLocalExt)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tremoteMediaObj.ext.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\turi   : ext.uri,\n\t\t\t\t\t\t\tvalue : ext.id\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Simulcast.\n\t\t\tif (localMediaObj.simulcast_03)\n\t\t\t{\n\t\t\t\t// eslint-disable-next-line camelcase\n\t\t\t\tremoteMediaObj.simulcast_03 =\n\t\t\t\t{\n\t\t\t\t\tvalue : localMediaObj.simulcast_03.value.replace(/send/g, 'recv')\n\t\t\t\t};\n\n\t\t\t\tremoteMediaObj.rids = [];\n\n\t\t\t\tfor (const rid of localMediaObj.rids || [])\n\t\t\t\t{\n\t\t\t\t\tif (rid.direction !== 'send')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tremoteMediaObj.rids.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid        : rid.id,\n\t\t\t\t\t\t\tdirection : 'recv'\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremoteMediaObj.rtcpMux = 'rtcp-mux';\n\t\t\tremoteMediaObj.rtcpRsize = 'rtcp-rsize';\n\n\t\t\t// Push it.\n\t\t\tsdpObj.media.push(remoteMediaObj);\n\t\t}\n\n\t\tconst sdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObj);\n\n\t\treturn sdp;\n\t}\n}\n\nclass RecvRemoteSdp extends RemoteSdp\n{\n\tconstructor(rtpParametersByKind)\n\t{\n\t\tsuper(rtpParametersByKind);\n\t}\n\n\t/**\n\t * @param {Array<Object>} consumerInfos - Consumer informations.\n\t * @return {String}\n\t */\n\tcreateOfferSdp(consumerInfos)\n\t{\n\t\tlogger.debug('createOfferSdp()');\n\n\t\tif (!this._transportRemoteParameters)\n\t\t\tthrow new Error('no transport remote parameters');\n\n\t\tconst remoteIceParameters = this._transportRemoteParameters.iceParameters;\n\t\tconst remoteIceCandidates = this._transportRemoteParameters.iceCandidates;\n\t\tconst remoteDtlsParameters = this._transportRemoteParameters.dtlsParameters;\n\t\tconst sdpObj = {};\n\t\tconst mids = consumerInfos\n\t\t\t.map((info) => String(info.mid));\n\n\t\t// Increase our SDP version.\n\t\tthis._sdpGlobalFields.version++;\n\n\t\tsdpObj.version = 0;\n\t\tsdpObj.origin =\n\t\t{\n\t\t\taddress        : '0.0.0.0',\n\t\t\tipVer          : 4,\n\t\t\tnetType        : 'IN',\n\t\t\tsessionId      : this._sdpGlobalFields.id,\n\t\t\tsessionVersion : this._sdpGlobalFields.version,\n\t\t\tusername       : 'mediasoup-client'\n\t\t};\n\t\tsdpObj.name = '-';\n\t\tsdpObj.timing = { start: 0, stop: 0 };\n\t\tsdpObj.icelite = remoteIceParameters.iceLite ? 'ice-lite' : null;\n\t\tsdpObj.msidSemantic =\n\t\t{\n\t\t\tsemantic : 'WMS',\n\t\t\ttoken    : '*'\n\t\t};\n\n\t\tif (mids.length > 0)\n\t\t{\n\t\t\tsdpObj.groups =\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\ttype : 'BUNDLE',\n\t\t\t\t\tmids : mids.join(' ')\n\t\t\t\t}\n\t\t\t];\n\t\t}\n\n\t\tsdpObj.media = [];\n\n\t\t// NOTE: We take the latest fingerprint.\n\t\tconst numFingerprints = remoteDtlsParameters.fingerprints.length;\n\n\t\tsdpObj.fingerprint =\n\t\t{\n\t\t\ttype : remoteDtlsParameters.fingerprints[numFingerprints - 1].algorithm,\n\t\t\thash : remoteDtlsParameters.fingerprints[numFingerprints - 1].value\n\t\t};\n\n\t\tfor (const info of consumerInfos)\n\t\t{\n\t\t\tconst closed = info.closed;\n\t\t\tconst kind = info.kind;\n\t\t\tlet codecs;\n\t\t\tlet headerExtensions;\n\n\t\t\tif (info.kind !== 'application')\n\t\t\t{\n\t\t\t\tcodecs = this._rtpParametersByKind[kind].codecs;\n\t\t\t\theaderExtensions = this._rtpParametersByKind[kind].headerExtensions;\n\t\t\t}\n\n\t\t\tconst remoteMediaObj = {};\n\n\t\t\tif (info.kind !== 'application')\n\t\t\t{\n\t\t\t\tremoteMediaObj.type = kind;\n\t\t\t\tremoteMediaObj.port = 7;\n\t\t\t\tremoteMediaObj.protocol = 'RTP/SAVPF';\n\t\t\t\tremoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };\n\t\t\t\tremoteMediaObj.mid = info.mid;\n\t\t\t\tremoteMediaObj.msid = `${info.streamId} ${info.trackId}`;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tremoteMediaObj.type = kind;\n\t\t\t\tremoteMediaObj.port = 9;\n\t\t\t\tremoteMediaObj.protocol = 'DTLS/SCTP';\n\t\t\t\tremoteMediaObj.connection = { ip: '127.0.0.1', version: 4 };\n\t\t\t\tremoteMediaObj.mid = info.mid;\n\t\t\t}\n\n\t\t\tremoteMediaObj.iceUfrag = remoteIceParameters.usernameFragment;\n\t\t\tremoteMediaObj.icePwd = remoteIceParameters.password;\n\t\t\tremoteMediaObj.candidates = [];\n\n\t\t\tfor (const candidate of remoteIceCandidates)\n\t\t\t{\n\t\t\t\tconst candidateObj = {};\n\n\t\t\t\t// mediasoup does not support non rtcp-mux so candidates component is\n\t\t\t\t// always RTP (1).\n\t\t\t\tcandidateObj.component = 1;\n\t\t\t\tcandidateObj.foundation = candidate.foundation;\n\t\t\t\tcandidateObj.ip = candidate.ip;\n\t\t\t\tcandidateObj.port = candidate.port;\n\t\t\t\tcandidateObj.priority = candidate.priority;\n\t\t\t\tcandidateObj.transport = candidate.protocol;\n\t\t\t\tcandidateObj.type = candidate.type;\n\t\t\t\tif (candidate.tcpType)\n\t\t\t\t\tcandidateObj.tcptype = candidate.tcpType;\n\n\t\t\t\tremoteMediaObj.candidates.push(candidateObj);\n\t\t\t}\n\n\t\t\tremoteMediaObj.endOfCandidates = 'end-of-candidates';\n\n\t\t\t// Announce support for ICE renomination.\n\t\t\t// https://tools.ietf.org/html/draft-thatcher-ice-renomination\n\t\t\tremoteMediaObj.iceOptions = 'renomination';\n\n\t\t\tremoteMediaObj.setup = 'actpass';\n\n\t\t\tif (info.kind !== 'application')\n\t\t\t{\n\t\t\t\tif (!closed)\n\t\t\t\t\tremoteMediaObj.direction = 'sendonly';\n\t\t\t\telse\n\t\t\t\t\tremoteMediaObj.direction = 'inactive';\n\n\t\t\t\tremoteMediaObj.rtp = [];\n\t\t\t\tremoteMediaObj.rtcpFb = [];\n\t\t\t\tremoteMediaObj.fmtp = [];\n\n\t\t\t\tfor (const codec of codecs)\n\t\t\t\t{\n\t\t\t\t\tconst rtp =\n\t\t\t\t\t{\n\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\tcodec   : codec.name,\n\t\t\t\t\t\trate    : codec.clockRate\n\t\t\t\t\t};\n\n\t\t\t\t\tif (codec.channels > 1)\n\t\t\t\t\t\trtp.encoding = codec.channels;\n\n\t\t\t\t\tremoteMediaObj.rtp.push(rtp);\n\n\t\t\t\t\tif (codec.parameters)\n\t\t\t\t\t{\n\t\t\t\t\t\tconst paramFmtp =\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\t\tconfig  : ''\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tfor (const key of Object.keys(codec.parameters))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\t\t\tparamFmtp.config += ';';\n\n\t\t\t\t\t\t\tparamFmtp.config += `${key}=${codec.parameters[key]}`;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (paramFmtp.config)\n\t\t\t\t\t\t\tremoteMediaObj.fmtp.push(paramFmtp);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (codec.rtcpFeedback)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (const fb of codec.rtcpFeedback)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tremoteMediaObj.rtcpFb.push(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpayload : codec.payloadType,\n\t\t\t\t\t\t\t\t\ttype    : fb.type,\n\t\t\t\t\t\t\t\t\tsubtype : fb.parameter || ''\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tremoteMediaObj.payloads = codecs\n\t\t\t\t\t.map((codec) => codec.payloadType)\n\t\t\t\t\t.join(' ');\n\n\t\t\t\t// NOTE: Firefox does not like a=extmap lines if a=inactive.\n\t\t\t\tif (!closed)\n\t\t\t\t{\n\t\t\t\t\tremoteMediaObj.ext = [];\n\n\t\t\t\t\tfor (const ext of headerExtensions)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Ignore MID RTP extension for receiving media.\n\t\t\t\t\t\tif (ext.uri === 'urn:ietf:params:rtp-hdrext:sdes:mid')\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tremoteMediaObj.ext.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\turi   : ext.uri,\n\t\t\t\t\t\t\t\tvalue : ext.id\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tremoteMediaObj.rtcpMux = 'rtcp-mux';\n\t\t\t\tremoteMediaObj.rtcpRsize = 'rtcp-rsize';\n\n\t\t\t\tif (!closed)\n\t\t\t\t{\n\t\t\t\t\tremoteMediaObj.ssrcs = [];\n\t\t\t\t\tremoteMediaObj.ssrcGroups = [];\n\n\t\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tid        : info.ssrc,\n\t\t\t\t\t\t\tattribute : 'cname',\n\t\t\t\t\t\t\tvalue     : info.cname\n\t\t\t\t\t\t});\n\n\t\t\t\t\tif (info.rtxSsrc)\n\t\t\t\t\t{\n\t\t\t\t\t\tremoteMediaObj.ssrcs.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tid        : info.rtxSsrc,\n\t\t\t\t\t\t\t\tattribute : 'cname',\n\t\t\t\t\t\t\t\tvalue     : info.cname\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Associate original and retransmission SSRC.\n\t\t\t\t\t\tremoteMediaObj.ssrcGroups.push(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsemantics : 'FID',\n\t\t\t\t\t\t\t\tssrcs     : `${info.ssrc} ${info.rtxSsrc}`\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tremoteMediaObj.payloads = 5000;\n\t\t\t\tremoteMediaObj.sctpmap =\n\t\t\t\t{\n\t\t\t\t\tapp            : 'webrtc-datachannel',\n\t\t\t\t\tmaxMessageSize : 256,\n\t\t\t\t\tsctpmapNumber  : 5000\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Push it.\n\t\t\tsdpObj.media.push(remoteMediaObj);\n\t\t}\n\n\t\tconst sdp = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.write(sdpObj);\n\n\t\treturn sdp;\n\t}\n}\n\nclass RemoteUnifiedPlanSdp\n{\n\tconstructor(direction, rtpParametersByKind)\n\t{\n\t\tlogger.debug(\n\t\t\t'constructor() [direction:%s, rtpParametersByKind:%o]',\n\t\t\tdirection, rtpParametersByKind);\n\n\t\tswitch (direction)\n\t\t{\n\t\t\tcase 'send':\n\t\t\t\treturn new SendRemoteSdp(rtpParametersByKind);\n\t\t\tcase 'recv':\n\t\t\t\treturn new RecvRemoteSdp(rtpParametersByKind);\n\t\t}\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js?");

/***/ }),

/***/ "./lib/mslib/handlers/sdp/bandwidthHandler.js":
/*!****************************************************!*\
  !*** ./lib/mslib/handlers/sdp/bandwidthHandler.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Logger */ \"./lib/mslib/Logger.js\");\n\n\n\nconst logger = new _Logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('BandwidthHandler');\n\nfunction setBAS(sdp, bandwidth, isScreen)\n{\n\tif (!!navigator.mozGetUserMedia || !bandwidth)\n\t{\n\t\treturn sdp;\n\t}\n\n\t// logger.debug(`setBAS() bandwidth: ${JSON.stringify(bandwidth)}`);\n\n\tif (isScreen)\n\t{\n\t\tif (!bandwidth.screen)\n\t\t{\n\t\t\tconsole.warn('It seems that you are not using bandwidth for screen. Screen sharing is expected to fail.');\n\t\t} else if (bandwidth.screen < 300)\n\t\t{\n\t\t\tconsole.warn('It seems that you are using wrong bandwidth value for screen. Screen sharing is expected to fail.');\n\t\t}\n\t}\n\n\t// if screen; must use at least 300kbs\n\tif (bandwidth.screen && isScreen)\n\t{\n\t\tsdp = sdp.replace(/b=AS([^\\r\\n]+\\r\\n)/g, '');\n\t\tsdp = sdp.replace(/a=mid:video\\r\\n/g, 'a=mid:video\\r\\nb=AS:' + bandwidth.screen + '\\r\\n');\n\t}\n\n\t// remove existing bandwidth lines\n\tif (bandwidth.audio || bandwidth.video || bandwidth.data)\n\t{\n\t\tsdp = sdp.replace(/b=AS([^\\r\\n]+\\r\\n)/g, '');\n\t}\n\n\tif (bandwidth.audio)\n\t{\n\t\tsdp = sdp.replace(/a=mid:audio\\r\\n/g, 'a=mid:audio\\r\\nb=AS:' + bandwidth.audio + '\\r\\n');\n\t}\n\n\tif (bandwidth.video)\n\t{\n\t\tsdp = sdp.replace(/a=mid:video\\r\\n/g, 'a=mid:video\\r\\nb=AS:' + (isScreen ? bandwidth.screen : bandwidth.video) + '\\r\\n');\n\t}\n\n\treturn sdp;\n}\n\n// Find the line in sdpLines that starts with |prefix|, and, if specified,\n// contains |substr| (case-insensitive search).\nfunction findLine(sdpLines, prefix, substr)\n{\n\treturn findLineInRange(sdpLines, 0, -1, prefix, substr);\n}\n\n// Find the line in sdpLines[startLine...endLine - 1] that starts with |prefix|\n// and, if specified, contains |substr| (case-insensitive search).\nfunction findLineInRange(sdpLines, startLine, endLine, prefix, substr)\n{\n\tvar realEndLine = endLine !== -1 ? endLine : sdpLines.length;\n\tfor (var i = startLine; i < realEndLine; ++i)\n\t{\n\t\tif (sdpLines[i].indexOf(prefix) === 0)\n\t\t{\n\t\t\tif (!substr ||\n\t\t\t\tsdpLines[i].toLowerCase().indexOf(substr.toLowerCase()) !== -1)\n\t\t\t{\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\n// Gets the codec payload type from an a=rtpmap:X line.\nfunction getCodecPayloadType(sdpLine)\n{\n\tvar pattern = new RegExp('a=rtpmap:(\\\\d+) \\\\w+\\\\/\\\\d+');\n\tvar result = sdpLine.match(pattern);\n\treturn (result && result.length === 2) ? result[1] : null;\n}\n\nfunction setVideoBitrates(sdp, params)\n{\n\tif (typeof params === 'undefined' || params === null)\n\t\treturn sdp;\n\n\tif (typeof params.videoGoogleMinBitrate === 'undefined' || typeof params.videoGoogleMaxBitrate === 'undefined')\n\t\treturn sdp;\n\n\t// logger.debug(`setVideoBitrates() params: ${JSON.stringify(params)}`);\n\n\tparams = params || {};\n\tvar xgoogle_min_bitrate = params.videoGoogleMinBitrate;\n\tvar xgoogle_max_bitrate = params.videoGoogleMaxBitrate;\n\tvar xgoogle_start_bitrate = params.videoGoogleStartBitrate;\n\n\tvar sdpLines = sdp.split('\\r\\n');\n\n\t// H264\n\tvar h264Index = findLine(sdpLines, 'a=rtpmap', 'H264/90000');\n\tvar h264Payload;\n\tif (h264Index)\n\t{\n\t\th264Payload = getCodecPayloadType(sdpLines[h264Index]);\n\t}\n\n\tif (!h264Payload)\n\t{\n\t\treturn sdp;\n\t}\n\n\tvar rtxIndex = findLine(sdpLines, 'a=rtpmap', 'rtx/90000');\n\tvar rtxPayload;\n\tif (rtxIndex)\n\t{\n\t\trtxPayload = getCodecPayloadType(sdpLines[rtxIndex]);\n\t}\n\n\tif (!rtxIndex)\n\t{\n\t\treturn sdp;\n\t}\n\n\t// var rtxFmtpLineIndex = findLine(sdpLines, 'a=fmtp:' + rtxPayload.toString());\n\t// if (rtxFmtpLineIndex !== null) {\n\t//     var appendrtxNext = '\\r\\n';\n\t//     appendrtxNext += 'a=fmtp:' + h264Payload + ' x-google-min-bitrate=' + (xgoogle_min_bitrate || '228') + ';x-google-max-bitrate=' + (xgoogle_max_bitrate || '228') + ';x-google-start-bitrate=' + (xgoogle_start_bitrate || '228');\n\t//     sdpLines[rtxFmtpLineIndex] = sdpLines[rtxFmtpLineIndex].concat(appendrtxNext);\n\t//     // sdp = sdpLines.join('\\r\\n');\n\t// }\n\n\tvar rtxFmtpLineIndex = 0;\n\twhile (rtxFmtpLineIndex !== null)\n\t{\n\t\trtxFmtpLineIndex = findLineInRange(sdpLines, rtxFmtpLineIndex, -1, 'a=fmtp', 'profile-level-id=42001f');\n\t\tif (rtxFmtpLineIndex !== null)\n\t\t{\n\t\t\tsdpLines[rtxFmtpLineIndex] += ';x-google-min-bitrate=' + (xgoogle_min_bitrate || '228') + ';x-google-max-bitrate=' + (xgoogle_max_bitrate || '228') + ';x-google-start-bitrate=' + (xgoogle_start_bitrate || '228');\n\t\t\tsdp = sdpLines.join('\\r\\n');\n\t\t}\n\n\t\tif (rtxFmtpLineIndex === null) break;\n\t\trtxFmtpLineIndex += 1;\n\t}\n\n\trtxFmtpLineIndex = 0;\n\twhile (rtxFmtpLineIndex !== null)\n\t{\n\t\trtxFmtpLineIndex = findLineInRange(sdpLines, rtxFmtpLineIndex, -1, 'a=fmtp', 'profile-level-id=42e01f');\n\t\tif (rtxFmtpLineIndex !== null)\n\t\t{\n\t\t\tsdpLines[rtxFmtpLineIndex] += ';x-google-min-bitrate=' + (xgoogle_min_bitrate || '228') + ';x-google-max-bitrate=' + (xgoogle_max_bitrate || '228') + ';x-google-start-bitrate=' + (xgoogle_start_bitrate || '228');\n\t\t\tsdp = sdpLines.join('\\r\\n');\n\t\t}\n\n\t\tif (rtxFmtpLineIndex === null)\n\t\t\tbreak;\n\t\trtxFmtpLineIndex += 1;\n\t}\n\n\t// logger.debug(`setVideoBitrates() OK - sdp: ${sdp}`);\n\n\treturn sdp;\n}\n\n// a=fmtp:111 minptime=10;useinbandfec=1;stereo=1;maxaveragebitrate=24000;maxplaybackrate=48000;\n// \n// params:\n// {\n//\tstereo : 1, // 取值 1 / 0\n//\tmaxaveragebitrate : 24 * 1024, // 数值型\n//\tmaxplaybackrate   : 48000, // 数值型\n//\tcbr : 1, // 取值 1 / 0\n//\tuseinbandfec : 1, // 取值 1 / 0\n//\tusedtx : 1, // 取值 1 / 0\n//\tmaxptime : 20, // 最大打包时长\n// }\nfunction setOpusAttributes(sdp, params)\n{\n\tparams = params || {};\n\n\tvar sdpLines = sdp.split('\\r\\n');\n\n\t// logger.debug(`setOpusAttributes() params: ${JSON.stringify(params)}`);\n\n\t// Opus\n\tvar opusIndex = findLine(sdpLines, 'a=rtpmap', 'opus/48000');\n\tvar opusPayload;\n\tif (opusIndex)\n\t{\n\t\topusPayload = getCodecPayloadType(sdpLines[opusIndex]);\n\t}\n\n\tif (!opusPayload)\n\t{\n\t\treturn sdp;\n\t}\n\n\tvar opusFmtpLineIndex = findLine(sdpLines, 'a=fmtp:' + opusPayload.toString());\n\tif (opusFmtpLineIndex === null)\n\t{\n\t\treturn sdp;\n\t}\n\n\tvar appendOpusNext = '';\n\t// \n\n\tlet pattern;\n\tlet idx = 0;\n\n\tif (typeof params.stereo != 'undefined')\n\t{\n\t\tidx = sdpLines[opusFmtpLineIndex].indexOf('stereo=');\n\t\tif (idx === -1)\n\t\t{\n\t\t\tappendOpusNext += ';stereo=' + params.stereo;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpattern = new RegExp('stereo=(\\\\d)');\n\t\t\tappendOpusNext = appendOpusNext.replace(pattern, 'stereo=' + params.stereo);\n\t\t}\n\t}\n\n\tif (typeof params['sprop-stereo'] != 'undefined')\n\t{\n\t\tidx = sdpLines[opusFmtpLineIndex].indexOf('sprop-stereo=');\n\t\tif (idx === -1)\n\t\t{\n\t\t\tappendOpusNext += ';sprop-stereo=' + (params['sprop-stereo']);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpattern = new RegExp('sprop-stereo=(\\\\d)');\n\t\t\tappendOpusNext = appendOpusNext.replace(pattern, 'sprop-stereo=' + params['sprop-stereo']);\n\t\t}\n\t}\n\n\tif (typeof params.maxaveragebitrate != 'undefined')\n\t{\n\t\tidx = sdpLines[opusFmtpLineIndex].indexOf('maxaveragebitrate=');\n\t\tif (idx == -1)\n\t\t{\n\t\t\tappendOpusNext += ';maxaveragebitrate=' + (params.maxaveragebitrate || 128 * 1024 * 8);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpattern = new RegExp('maxaveragebitrate=(\\\\d+)');\n\t\t\tappendOpusNext = appendOpusNext.replace(pattern, 'maxaveragebitrate=' + (params.maxaveragebitrate || 128 * 1024 * 8));\n\t\t}\n\t}\n\n\tif (typeof params.maxplaybackrate != 'undefined')\n\t{\n\t\tidx = sdpLines[opusFmtpLineIndex].indexOf('maxplaybackrate=');\n\t\tif (idx === -1)\n\t\t{\n\t\t\tappendOpusNext += ';maxplaybackrate=' + (params.maxplaybackrate || 48000);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpattern = new RegExp('maxplaybackrate=(\\\\d+)');\n\t\t\tappendOpusNext = appendOpusNext.replace(pattern, 'maxplaybackrate=' + (params.maxplaybackrate || 48000));\n\t\t}\n\t}\n\n\tif (typeof params.cbr != 'undefined')\n\t{\n\t\tappendOpusNext += ';cbr=' + (typeof params.cbr != 'undefined' ? params.cbr : '1');\n\t}\n\n\tif (typeof params.useinbandfec != 'undefined')\n\t{\n\t\tappendOpusNext += ';useinbandfec=' + params.useinbandfec;\n\t}\n\n\tif (typeof params.usedtx != 'undefined')\n\t{\n\t\tappendOpusNext += ';usedtx=' + params.usedtx;\n\t}\n\n\tif (typeof params.maxptime != 'undefined')\n\t{\n\t\tappendOpusNext += '\\r\\na=maxptime:' + params.maxptime;\n\t}\n\n\tsdpLines[opusFmtpLineIndex] = sdpLines[opusFmtpLineIndex].concat(appendOpusNext);\n\n\tsdp = sdpLines.join('\\r\\n');\n\n\tlogger.debug(`setOpusAttributes() OK - sdp: ${sdp}`);\n\n\treturn sdp;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({ setBAS, setVideoBitrates, setOpusAttributes });\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/sdp/bandwidthHandler.js?");

/***/ }),

/***/ "./lib/mslib/handlers/sdp/commonUtils.js":
/*!***********************************************!*\
  !*** ./lib/mslib/handlers/sdp/commonUtils.js ***!
  \***********************************************/
/*! exports provided: extractRtpCapabilities, extractDtlsParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extractRtpCapabilities\", function() { return extractRtpCapabilities; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extractDtlsParameters\", function() { return extractDtlsParameters; });\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../sdpform */ \"./lib/sdpform/index.js\");\n/* harmony import */ var _sdpform__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdpform__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n * Extract RTP capabilities from a SDP.\n *\n * @param {Object} sdpObj - SDP Object generated by sdpform.\n * @return {RTCRtpCapabilities}\n */\nfunction extractRtpCapabilities(sdpObj)\n{\n\t// Map of RtpCodecParameters indexed by payload type.\n\tconst codecsMap = new Map();\n\n\t// Array of RtpHeaderExtensions.\n\tconst headerExtensions = [];\n\n\t// Whether a m=audio/video section has been already found.\n\tlet gotAudio = false;\n\tlet gotVideo = false;\n\n\tfor (const m of sdpObj.media)\n\t{\n\t\tconst kind = m.type;\n\n\t\tswitch (kind)\n\t\t{\n\t\t\tcase 'audio':\n\t\t\t{\n\t\t\t\tif (gotAudio)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tgotAudio = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'video':\n\t\t\t{\n\t\t\t\tif (gotVideo)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tgotVideo = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t// Get codecs.\n\t\tfor (const rtp of m.rtp)\n\t\t{\n\t\t\tconst codec =\n\t\t\t{\n\t\t\t\tname                 : rtp.codec,\n\t\t\t\tmimeType             : `${kind}/${rtp.codec}`,\n\t\t\t\tkind                 : kind,\n\t\t\t\tclockRate            : rtp.rate,\n\t\t\t\tpreferredPayloadType : rtp.payload,\n\t\t\t\tchannels             : rtp.encoding,\n\t\t\t\trtcpFeedback         : [],\n\t\t\t\tparameters           : {}\n\t\t\t};\n\n\t\t\tif (codec.kind !== 'audio')\n\t\t\t\tdelete codec.channels;\n\t\t\telse if (!codec.channels)\n\t\t\t\tcodec.channels = 1;\n\n\t\t\tcodecsMap.set(codec.preferredPayloadType, codec);\n\t\t}\n\n\t\t// Get codec parameters.\n\t\tfor (const fmtp of m.fmtp || [])\n\t\t{\n\t\t\tconst parameters = _sdpform__WEBPACK_IMPORTED_MODULE_0___default.a.parseFmtpConfig(fmtp.config);\n\t\t\tconst codec = codecsMap.get(fmtp.payload);\n\n\t\t\tif (!codec)\n\t\t\t\tcontinue;\n\n\t\t\tcodec.parameters = parameters;\n\t\t}\n\n\t\t// Get RTCP feedback for each codec.\n\t\tfor (const fb of m.rtcpFb || [])\n\t\t{\n\t\t\tconst codec = codecsMap.get(fb.payload);\n\n\t\t\tif (!codec)\n\t\t\t\tcontinue;\n\n\t\t\tconst feedback =\n\t\t\t{\n\t\t\t\ttype      : fb.type,\n\t\t\t\tparameter : fb.subtype\n\t\t\t};\n\n\t\t\tif (!feedback.parameter)\n\t\t\t\tdelete feedback.parameter;\n\n\t\t\tcodec.rtcpFeedback.push(feedback);\n\t\t}\n\n\t\t// Get RTP header extensions.\n\t\tfor (const ext of m.ext || [])\n\t\t{\n\t\t\tconst headerExtension =\n\t\t\t{\n\t\t\t\tkind        : kind,\n\t\t\t\turi         : ext.uri,\n\t\t\t\tpreferredId : ext.value\n\t\t\t};\n\n\t\t\theaderExtensions.push(headerExtension);\n\t\t}\n\t}\n\n\tconst rtpCapabilities =\n\t{\n\t\tcodecs           : Array.from(codecsMap.values()),\n\t\theaderExtensions : headerExtensions,\n\t\tfecMechanisms    : [] // TODO\n\t};\n\n\treturn rtpCapabilities;\n}\n\n/**\n * Extract DTLS parameters from a SDP.\n *\n * @param {Object} sdpObj - SDP Object generated by sdpform.\n * @return {RTCDtlsParameters}\n */\nfunction extractDtlsParameters(sdpObj)\n{\n\tconst media = getFirstActiveMediaSection(sdpObj);\n\tconst fingerprint = media.fingerprint || sdpObj.fingerprint;\n\tlet role;\n\n\tswitch (media.setup)\n\t{\n\t\tcase 'active':\n\t\t\trole = 'client';\n\t\t\tbreak;\n\t\tcase 'passive':\n\t\t\trole = 'server';\n\t\t\tbreak;\n\t\tcase 'actpass':\n\t\t\trole = 'auto';\n\t\t\tbreak;\n\t}\n\n\tconst dtlsParameters =\n\t{\n\t\trole         : role,\n\t\tfingerprints :\n\t\t[\n\t\t\t{\n\t\t\t\talgorithm : fingerprint.type,\n\t\t\t\tvalue     : fingerprint.hash\n\t\t\t}\n\t\t]\n\t};\n\n\treturn dtlsParameters;\n}\n\n/**\n * Get the first acive media section.\n *\n * @private\n * @param {Object} sdpObj - SDP Object generated by sdpform.\n * @return {Object} SDP media section as parsed by sdpform.\n */\nfunction getFirstActiveMediaSection(sdpObj)\n{\n\treturn (sdpObj.media || [])\n\t\t.find((m) => m.iceUfrag && m.port !== 0);\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/sdp/commonUtils.js?");

/***/ }),

/***/ "./lib/mslib/handlers/sdp/plainRtpUtils.js":
/*!*************************************************!*\
  !*** ./lib/mslib/handlers/sdp/plainRtpUtils.js ***!
  \*************************************************/
/*! exports provided: extractPlainRtpParametersByKind, fillRtpParametersForKind */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extractPlainRtpParametersByKind\", function() { return extractPlainRtpParametersByKind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fillRtpParametersForKind\", function() { return fillRtpParametersForKind; });\n/**\n * Extract plain RTP parameters from a SDP.\n *\n * @param {Object} sdpObj - SDP Object generated by sdpform.\n * @param {String} kind - media type.\n * @return {PlainRtpParameters}\n */\nfunction extractPlainRtpParametersByKind(sdpObj, kind)\n{\n\tconst mSection = (sdpObj.media || [])\n\t\t.find((m) => m.type === kind);\n\n\tif (!mSection)\n\t\tthrow new Error(`m=${kind} section not found`);\n\n\tconst plainRtpParameters =\n\t{\n\t\tip   : sdpObj.connection.ip,\n\t\tport : mSection.port\n\t};\n\n\treturn plainRtpParameters;\n}\n\n/**\n * Fill the given RTP parameters for the given media type.\n *\n * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.\n * @param {Object} sdpObj - Local SDP Object generated by sdpform.\n * @param {String} kind - media type.\n */\nfunction fillRtpParametersForKind(rtpParameters, sdpObj, kind)\n{\n\tconst rtcp =\n\t{\n\t\tcname       : null,\n\t\treducedSize : true,\n\t\tmux         : true\n\t};\n\n\tconst mSection = (sdpObj.media || [])\n\t\t.find((m) => m.type === kind);\n\n\tif (!mSection)\n\t\tthrow new Error(`m=${kind} section not found`);\n\n\t// Get the SSRC and CNAME.\n\n\tconst ssrcCnameLine = (mSection.ssrcs || [])\n\t\t.find((line) => line.attribute === 'cname');\n\n\tlet ssrc;\n\n\tif (ssrcCnameLine)\n\t{\n\t\tssrc = ssrcCnameLine.id;\n\t\trtcp.cname = ssrcCnameLine.value;\n\t}\n\n\t// Fill RTP parameters.\n\n\trtpParameters.rtcp = rtcp;\n\trtpParameters.encodings = [];\n\n\tconst encoding = { ssrc };\n\n\trtpParameters.encodings.push(encoding);\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/sdp/plainRtpUtils.js?");

/***/ }),

/***/ "./lib/mslib/handlers/sdp/planBUtils.js":
/*!**********************************************!*\
  !*** ./lib/mslib/handlers/sdp/planBUtils.js ***!
  \**********************************************/
/*! exports provided: fillRtpParametersForTrack, addSimulcastForTrack */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fillRtpParametersForTrack\", function() { return fillRtpParametersForTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addSimulcastForTrack\", function() { return addSimulcastForTrack; });\n/**\n * Fill the given RTP parameters for the given track.\n *\n * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.\n * @param {Object} sdpObj - Local SDP Object generated by sdpform.\n * @param {MediaStreamTrack} track\n */\nfunction fillRtpParametersForTrack(rtpParameters, sdpObj, track)\n{\n\tconst kind = track.kind;\n\tconst rtcp =\n\t{\n\t\tcname       : null,\n\t\treducedSize : true,\n\t\tmux         : true\n\t};\n\n\tconst mSection = (sdpObj.media || [])\n\t\t.find((m) => m.type === kind);\n\n\tif (!mSection)\n\t\tthrow new Error(`m=${kind} section not found`);\n\n\t// First media SSRC (or the only one).\n\tlet firstSsrc;\n\n\t// Get all the SSRCs.\n\n\tconst ssrcs = new Set();\n\n\tfor (const line of mSection.ssrcs || [])\n\t{\n\t\tif (line.attribute !== 'msid')\n\t\t\tcontinue;\n\n\t\tconst trackId = line.value.split(' ')[1];\n\n\t\tif (trackId === track.id)\n\t\t{\n\t\t\tconst ssrc = line.id;\n\n\t\t\tssrcs.add(ssrc);\n\n\t\t\tif (!firstSsrc)\n\t\t\t\tfirstSsrc = ssrc;\n\t\t}\n\t}\n\n\tif (ssrcs.size === 0)\n\t\tthrow new Error(`a=ssrc line not found for local track [track.id:${track.id}]`);\n\n\t// Get media and RTX SSRCs.\n\n\tconst ssrcToRtxSsrc = new Map();\n\n\t// First assume RTX is used.\n\tfor (const line of mSection.ssrcGroups || [])\n\t{\n\t\tif (line.semantics !== 'FID')\n\t\t\tcontinue;\n\n\t\tlet [ ssrc, rtxSsrc ] = line.ssrcs.split(/\\s+/);\n\n\t\tssrc = Number(ssrc);\n\t\trtxSsrc = Number(rtxSsrc);\n\n\t\tif (ssrcs.has(ssrc))\n\t\t{\n\t\t\t// Remove both the SSRC and RTX SSRC from the Set so later we know that they\n\t\t\t// are already handled.\n\t\t\tssrcs.delete(ssrc);\n\t\t\tssrcs.delete(rtxSsrc);\n\n\t\t\t// Add to the map.\n\t\t\tssrcToRtxSsrc.set(ssrc, rtxSsrc);\n\t\t}\n\t}\n\n\t// If the Set of SSRCs is not empty it means that RTX is not being used, so take\n\t// media SSRCs from there.\n\tfor (const ssrc of ssrcs)\n\t{\n\t\t// Add to the map.\n\t\tssrcToRtxSsrc.set(ssrc, null);\n\t}\n\n\t// Get RTCP info.\n\n\tconst ssrcCnameLine = mSection.ssrcs\n\t\t.find((line) => line.attribute === 'cname' && line.id === firstSsrc);\n\n\tif (ssrcCnameLine)\n\t\trtcp.cname = ssrcCnameLine.value;\n\n\t// Fill RTP parameters.\n\n\trtpParameters.rtcp = rtcp;\n\trtpParameters.encodings = [];\n\n\tconst simulcast = ssrcToRtxSsrc.size > 1;\n\tconst simulcastProfiles = [ 'low', 'medium', 'high' ];\n\n\tfor (const [ ssrc, rtxSsrc ] of ssrcToRtxSsrc)\n\t{\n\t\tconst encoding = { ssrc };\n\n\t\tif (rtxSsrc)\n\t\t\tencoding.rtx = { ssrc: rtxSsrc };\n\n\t\tif (simulcast)\n\t\t\tencoding.profile = simulcastProfiles.shift();\n\n\t\trtpParameters.encodings.push(encoding);\n\t}\n}\n\n/**\n * Adds simulcast into the given SDP for the given track.\n *\n * @param {Object} sdpObj - Local SDP Object generated by sdpform.\n * @param {MediaStreamTrack} track\n */\nfunction addSimulcastForTrack(sdpObj, track)\n{\n\tconst kind = track.kind;\n\n\tconst mSection = (sdpObj.media || [])\n\t\t.find((m) => m.type === kind);\n\n\tif (!mSection)\n\t\tthrow new Error(`m=${kind} section not found`);\n\n\tlet ssrc;\n\tlet rtxSsrc;\n\tlet msid;\n\n\t// Get the SSRC.\n\n\tconst ssrcMsidLine = (mSection.ssrcs || [])\n\t\t.find((line) =>\n\t\t{\n\t\t\tif (line.attribute !== 'msid')\n\t\t\t\treturn false;\n\n\t\t\tconst trackId = line.value.split(' ')[1];\n\n\t\t\tif (trackId === track.id)\n\t\t\t{\n\t\t\t\tssrc = line.id;\n\t\t\t\tmsid = line.value.split(' ')[0];\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\tif (!ssrcMsidLine)\n\t\tthrow new Error(`a=ssrc line not found for local track [track.id:${track.id}]`);\n\n\t// Get the SSRC for RTX.\n\n\t(mSection.ssrcGroups || [])\n\t\t.some((line) =>\n\t\t{\n\t\t\tif (line.semantics !== 'FID')\n\t\t\t\treturn;\n\n\t\t\tconst ssrcs = line.ssrcs.split(/\\s+/);\n\n\t\t\tif (Number(ssrcs[0]) === ssrc)\n\t\t\t{\n\t\t\t\trtxSsrc = Number(ssrcs[1]);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\tconst ssrcCnameLine = mSection.ssrcs\n\t\t.find((line) => (line.attribute === 'cname' && line.id === ssrc));\n\n\tif (!ssrcCnameLine)\n\t\tthrow new Error(`CNAME line not found for local track [track.id:${track.id}]`);\n\n\tconst cname = ssrcCnameLine.value;\n\tconst ssrc2 = ssrc + 1;\n\tconst ssrc3 = ssrc + 2;\n\n\tmSection.ssrcGroups = mSection.ssrcGroups || [];\n\n\tmSection.ssrcGroups.push(\n\t\t{\n\t\t\tsemantics : 'SIM',\n\t\t\tssrcs     : `${ssrc} ${ssrc2} ${ssrc3}`\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc2,\n\t\t\tattribute : 'cname',\n\t\t\tvalue     : cname\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc2,\n\t\t\tattribute : 'msid',\n\t\t\tvalue     : `${msid} ${track.id}`\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc3,\n\t\t\tattribute : 'cname',\n\t\t\tvalue     : cname\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc3,\n\t\t\tattribute : 'msid',\n\t\t\tvalue     : `${msid} ${track.id}`\n\t\t});\n\n\tif (rtxSsrc)\n\t{\n\t\tconst rtxSsrc2 = rtxSsrc + 1;\n\t\tconst rtxSsrc3 = rtxSsrc + 2;\n\n\t\tmSection.ssrcGroups.push(\n\t\t\t{\n\t\t\t\tsemantics : 'FID',\n\t\t\t\tssrcs     : `${ssrc2} ${rtxSsrc2}`\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc2,\n\t\t\t\tattribute : 'cname',\n\t\t\t\tvalue     : cname\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc2,\n\t\t\t\tattribute : 'msid',\n\t\t\t\tvalue     : `${msid} ${track.id}`\n\t\t\t});\n\n\t\tmSection.ssrcGroups.push(\n\t\t\t{\n\t\t\t\tsemantics : 'FID',\n\t\t\t\tssrcs     : `${ssrc3} ${rtxSsrc3}`\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc3,\n\t\t\t\tattribute : 'cname',\n\t\t\t\tvalue     : cname\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc3,\n\t\t\t\tattribute : 'msid',\n\t\t\t\tvalue     : `${msid} ${track.id}`\n\t\t\t});\n\t}\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/sdp/planBUtils.js?");

/***/ }),

/***/ "./lib/mslib/handlers/sdp/unifiedPlanUtils.js":
/*!****************************************************!*\
  !*** ./lib/mslib/handlers/sdp/unifiedPlanUtils.js ***!
  \****************************************************/
/*! exports provided: fillRtpParametersForTrack, addPlanBSimulcast */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fillRtpParametersForTrack\", function() { return fillRtpParametersForTrack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addPlanBSimulcast\", function() { return addPlanBSimulcast; });\n/**\n * Fill the given RTP parameters for the given mid or sending track.\n *\n * @param {RTCRtpParameters} rtpParameters -  RTP parameters to be filled.\n * @param {Object} sdpObj - Local SDP Object generated by sdpform.\n * @param {MediaStreamTrack} track\n * @param {String} [mid]\n * @param {Boolean} [planBSimulcast]\n */\nfunction fillRtpParametersForTrack(\n\trtpParameters, sdpObj, track, { mid = null, planBSimulcast = false } = {}\n)\n{\n\tconst mSection = findMediaSection(sdpObj, track, mid);\n\n\tif (mid !== null && mid !== undefined)\n\t\trtpParameters.muxId = String(mid);\n\n\trtpParameters.rtcp =\n\t{\n\t\tcname       : null,\n\t\treducedSize : true,\n\t\tmux         : true\n\t};\n\n\t// Get the SSRC and CNAME.\n\n\tconst ssrcCnameLine = (mSection.ssrcs || [])\n\t\t.find((line) => line.attribute === 'cname');\n\n\tif (!ssrcCnameLine)\n\t\tthrow new Error('CNAME value not found');\n\n\trtpParameters.rtcp.cname = ssrcCnameLine.value;\n\n\t// Standard simylcast based on a=simulcast and RID.\n\tif (!planBSimulcast)\n\t{\n\t\t// Get first (and may be the only one) ssrc.\n\t\tconst ssrc = ssrcCnameLine.id;\n\n\t\t// Get a=rid lines.\n\n\t\t// Array of Objects with rid and profile keys.\n\t\tconst simulcastStreams = [];\n\n\t\tfor (const rid of mSection.rids || [])\n\t\t{\n\t\t\tif (rid.direction !== 'send')\n\t\t\t\tcontinue;\n\n\t\t\tif (/^low/.test(rid.id))\n\t\t\t\tsimulcastStreams.push({ rid: rid.id, profile: 'low' });\n\t\t\telse if (/^medium/.test(rid.id))\n\t\t\t\tsimulcastStreams.push({ rid: rid.id, profile: 'medium' });\n\t\t\tif (/^high/.test(rid.id))\n\t\t\t\tsimulcastStreams.push({ rid: rid.id, profile: 'high' });\n\t\t}\n\n\t\t// Fill RTP parameters.\n\n\t\trtpParameters.encodings = [];\n\n\t\tif (simulcastStreams.length === 0)\n\t\t{\n\t\t\tconst encoding = { ssrc };\n\n\t\t\trtpParameters.encodings.push(encoding);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (const simulcastStream of simulcastStreams)\n\t\t\t{\n\t\t\t\tconst encoding =\n\t\t\t\t{\n\t\t\t\t\tencodingId : simulcastStream.rid,\n\t\t\t\t\tprofile    : simulcastStream.profile\n\t\t\t\t};\n\n\t\t\t\trtpParameters.encodings.push(encoding);\n\t\t\t}\n\t\t}\n\t}\n\t// Simulcast based on PlanB.\n\telse\n\t{\n\t\t// First media SSRC (or the only one).\n\t\tlet firstSsrc;\n\n\t\t// Get all the SSRCs.\n\n\t\tconst ssrcs = new Set();\n\n\t\tfor (const line of mSection.ssrcs || [])\n\t\t{\n\t\t\tif (line.attribute !== 'msid')\n\t\t\t\tcontinue;\n\n\t\t\tconst ssrc = line.id;\n\n\t\t\tssrcs.add(ssrc);\n\n\t\t\tif (!firstSsrc)\n\t\t\t\tfirstSsrc = ssrc;\n\t\t}\n\n\t\tif (ssrcs.size === 0)\n\t\t\tthrow new Error('no a=ssrc lines found');\n\n\t\t// Get media and RTX SSRCs.\n\n\t\tconst ssrcToRtxSsrc = new Map();\n\n\t\t// First assume RTX is used.\n\t\tfor (const line of mSection.ssrcGroups || [])\n\t\t{\n\t\t\tif (line.semantics !== 'FID')\n\t\t\t\tcontinue;\n\n\t\t\tlet [ ssrc, rtxSsrc ] = line.ssrcs.split(/\\s+/);\n\n\t\t\tssrc = Number(ssrc);\n\t\t\trtxSsrc = Number(rtxSsrc);\n\n\t\t\tif (ssrcs.has(ssrc))\n\t\t\t{\n\t\t\t\t// Remove both the SSRC and RTX SSRC from the Set so later we know that they\n\t\t\t\t// are already handled.\n\t\t\t\tssrcs.delete(ssrc);\n\t\t\t\tssrcs.delete(rtxSsrc);\n\n\t\t\t\t// Add to the map.\n\t\t\t\tssrcToRtxSsrc.set(ssrc, rtxSsrc);\n\t\t\t}\n\t\t}\n\n\t\t// If the Set of SSRCs is not empty it means that RTX is not being used, so take\n\t\t// media SSRCs from there.\n\t\tfor (const ssrc of ssrcs)\n\t\t{\n\t\t\t// Add to the map.\n\t\t\tssrcToRtxSsrc.set(ssrc, null);\n\t\t}\n\n\t\t// Fill RTP parameters.\n\n\t\trtpParameters.encodings = [];\n\n\t\tconst simulcast = ssrcToRtxSsrc.size > 1;\n\t\tconst simulcastProfiles = [ 'low', 'medium', 'high' ];\n\n\t\tfor (const [ ssrc, rtxSsrc ] of ssrcToRtxSsrc)\n\t\t{\n\t\t\tconst encoding = { ssrc };\n\n\t\t\tif (rtxSsrc)\n\t\t\t\tencoding.rtx = { ssrc: rtxSsrc };\n\n\t\t\tif (simulcast)\n\t\t\t\tencoding.profile = simulcastProfiles.shift();\n\n\t\t\trtpParameters.encodings.push(encoding);\n\t\t}\n\t}\n}\n\n/**\n * Adds multi-ssrc based simulcast (PlanB) into the given SDP for the given mid\n * or track.\n * NOTE: This is for Chrome/Safari using Unified-Plan with legacy simulcast.\n *\n * @param {Object} sdpObj - Local SDP Object generated by sdpform.\n * @param {MediaStreamTrack} track\n * @param {String} [mid]\n */\nfunction addPlanBSimulcast(sdpObj, track, { mid = null } = {})\n{\n\tconst mSection = findMediaSection(sdpObj, track, mid);\n\n\t// Get the SSRC.\n\n\tconst ssrcMsidLine = (mSection.ssrcs || [])\n\t\t.find((line) => line.attribute === 'msid');\n\n\tif (!ssrcMsidLine)\n\t\tthrow new Error('a=ssrc line with msid information not found');\n\n\tconst ssrc = ssrcMsidLine.id;\n\tconst msid = ssrcMsidLine.value.split(' ')[0];\n\tlet rtxSsrc;\n\n\t// Get the SSRC for RTX.\n\n\t(mSection.ssrcGroups || [])\n\t\t.some((line) =>\n\t\t{\n\t\t\tif (line.semantics !== 'FID')\n\t\t\t\treturn;\n\n\t\t\tconst ssrcs = line.ssrcs.split(/\\s+/);\n\n\t\t\tif (Number(ssrcs[0]) === ssrc)\n\t\t\t{\n\t\t\t\trtxSsrc = Number(ssrcs[1]);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\tconst ssrcCnameLine = mSection.ssrcs\n\t\t.find((line) => (line.attribute === 'cname' && line.id === ssrc));\n\n\tif (!ssrcCnameLine)\n\t\tthrow new Error('CNAME line not found');\n\n\tconst cname = ssrcCnameLine.value;\n\tconst ssrc2 = ssrc + 1;\n\tconst ssrc3 = ssrc + 2;\n\n\t// mSection.ssrcGroups = mSection.ssrcGroups || [];\n\tmSection.ssrcGroups = [];\n\tmSection.ssrcs = [];\n\n\tmSection.ssrcGroups.push(\n\t\t{\n\t\t\tsemantics : 'SIM',\n\t\t\tssrcs     : `${ssrc} ${ssrc2} ${ssrc3}`\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc,\n\t\t\tattribute : 'cname',\n\t\t\tvalue     : cname\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc,\n\t\t\tattribute : 'msid',\n\t\t\tvalue     : `${msid} ${track.id}`\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc2,\n\t\t\tattribute : 'cname',\n\t\t\tvalue     : cname\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc2,\n\t\t\tattribute : 'msid',\n\t\t\tvalue     : `${msid} ${track.id}`\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc3,\n\t\t\tattribute : 'cname',\n\t\t\tvalue     : cname\n\t\t});\n\n\tmSection.ssrcs.push(\n\t\t{\n\t\t\tid        : ssrc3,\n\t\t\tattribute : 'msid',\n\t\t\tvalue     : `${msid} ${track.id}`\n\t\t});\n\n\tif (rtxSsrc)\n\t{\n\t\tconst rtxSsrc2 = rtxSsrc + 1;\n\t\tconst rtxSsrc3 = rtxSsrc + 2;\n\n\t\tmSection.ssrcGroups.push(\n\t\t\t{\n\t\t\t\tsemantics : 'FID',\n\t\t\t\tssrcs     : `${ssrc} ${rtxSsrc}`\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc,\n\t\t\t\tattribute : 'cname',\n\t\t\t\tvalue     : cname\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc,\n\t\t\t\tattribute : 'msid',\n\t\t\t\tvalue     : `${msid} ${track.id}`\n\t\t\t});\n\n\t\tmSection.ssrcGroups.push(\n\t\t\t{\n\t\t\t\tsemantics : 'FID',\n\t\t\t\tssrcs     : `${ssrc2} ${rtxSsrc2}`\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc2,\n\t\t\t\tattribute : 'cname',\n\t\t\t\tvalue     : cname\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc2,\n\t\t\t\tattribute : 'msid',\n\t\t\t\tvalue     : `${msid} ${track.id}`\n\t\t\t});\n\n\t\tmSection.ssrcGroups.push(\n\t\t\t{\n\t\t\t\tsemantics : 'FID',\n\t\t\t\tssrcs     : `${ssrc3} ${rtxSsrc3}`\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc3,\n\t\t\t\tattribute : 'cname',\n\t\t\t\tvalue     : cname\n\t\t\t});\n\n\t\tmSection.ssrcs.push(\n\t\t\t{\n\t\t\t\tid        : rtxSsrc3,\n\t\t\t\tattribute : 'msid',\n\t\t\t\tvalue     : `${msid} ${track.id}`\n\t\t\t});\n\t}\n}\n\nfunction findMediaSection(sdpObj, track, mid)\n{\n\tlet mSection;\n\n\tif (mid !== null && mid !== undefined)\n\t{\n\t\tmid = String(mid);\n\n\t\tmSection = (sdpObj.media || [])\n\t\t\t.find((m) => String(m.mid) === mid);\n\n\t\tif (!mSection)\n\t\t\tthrow new Error(`SDP section with mid=${mid} not found`);\n\t}\n\telse\n\t{\n\t\tmSection = (sdpObj.media || [])\n\t\t\t.find((m) => (\n\t\t\t\tm.type === track.kind &&\n\t\t\t\tm.msid &&\n\t\t\t\tm.msid.split(' ')[1] === track.id\n\t\t\t));\n\n\t\tif (!mSection)\n\t\t\tthrow new Error(`SDP section with a=msid containing track.id=${track.id} not found`);\n\t}\n\n\treturn mSection;\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/handlers/sdp/unifiedPlanUtils.js?");

/***/ }),

/***/ "./lib/mslib/index.js":
/*!****************************!*\
  !*** ./lib/mslib/index.js ***!
  \****************************/
/*! exports provided: setDeviceHandler, isDeviceSupported, getDeviceInfo, checkCapabilitiesForRoom, Room, internals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDeviceHandler\", function() { return setDeviceHandler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDeviceSupported\", function() { return isDeviceSupported; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDeviceInfo\", function() { return getDeviceInfo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkCapabilitiesForRoom\", function() { return checkCapabilitiesForRoom; });\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ortc */ \"./lib/mslib/ortc.js\");\n/* harmony import */ var _Device__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Device */ \"./lib/mslib/Device.js\");\n/* harmony import */ var _Room__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Room */ \"./lib/mslib/Room.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Room\", function() { return _Room__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _internals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internals */ \"./lib/mslib/internals.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"internals\", function() { return _internals__WEBPACK_IMPORTED_MODULE_3__; });\n\n\n\n\n\n/**\n * mediasoup-client v2.4.9.\n *\n * Provides a custom RTC handler class and avoid auto-detection. Useful\n * for making mediasoup-client work with custom devices.\n *\n * NOTE: This function must be called upon library load.\n *\n * @param {Class} handler - A handler class.\n * @param {Object} [metadata] - Handler metadata.\n * @param {String} [metadata.flag] - Handler flag.\n * @param {String} [metadata.name] - Handler name.\n * @param {String} [metadata.version] - Handler version.\n * @param {Object} [metadata.bowser] - Handler bowser Object.\n */\nfunction setDeviceHandler(handler, metadata)\n{\n\t_Device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].setHandler(handler, metadata);\n}\n\n/**\n * Whether the current browser or device is supported.\n *\n * @return {Boolean}\n *\n * @example\n * isDeviceSupported()\n * // => true\n */\nfunction isDeviceSupported()\n{\n\treturn _Device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isSupported();\n}\n\n/**\n * Get information regarding the current browser or device.\n *\n * @return {Object} - Object with `name` (String) and version {String}.\n *\n * @example\n * getDeviceInfo()\n * // => { flag: 'chrome', name: 'Chrome', version: '59.0', bowser: {} }\n */\nfunction getDeviceInfo()\n{\n\treturn {\n\t\tflag    : _Device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getFlag(),\n\t\tname    : _Device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getName(),\n\t\tversion : _Device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getVersion(),\n\t\tbowser  : _Device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getBowser()\n\t};\n}\n\n/**\n * Check whether this device/browser can send/receive audio/video in a room\n * whose RTP capabilities are given.\n *\n * @param {Object} Room RTP capabilities.\n *\n * @return {Promise} Resolves to an Object with 'audio' and 'video' Booleans.\n */\nfunction checkCapabilitiesForRoom(roomRtpCapabilities)\n{\n\tif (!_Device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isSupported())\n\t\treturn Promise.reject(new Error('current browser/device not supported'));\n\n\treturn _Device__WEBPACK_IMPORTED_MODULE_1__[\"default\"].Handler.getNativeRtpCapabilities()\n\t\t.then((nativeRtpCapabilities) =>\n\t\t{\n\t\t\tconst extendedRtpCapabilities = _ortc__WEBPACK_IMPORTED_MODULE_0__[\"getExtendedRtpCapabilities\"](\n\t\t\t\tnativeRtpCapabilities, roomRtpCapabilities);\n\n\t\t\treturn {\n\t\t\t\taudio : _ortc__WEBPACK_IMPORTED_MODULE_0__[\"canSend\"]('audio', extendedRtpCapabilities),\n\t\t\t\tvideo : _ortc__WEBPACK_IMPORTED_MODULE_0__[\"canSend\"]('video', extendedRtpCapabilities)\n\t\t\t};\n\t\t});\n}\n\n/**\n * Expose the Room class.\n *\n * @example\n * const room = new Room();`\n */\n\n\n/**\n * Expose internals.\n */\n\n\n/**\n * REF: Base upon the stabile release es5-lib's version of mediasoup-client 2.4.9.\n * NOTE: Carefully modify there folder files especially in heandlers/ for Full Compatibility broswers\n * Changelogs:\n * Get peerconnect sates. date:\n * Get sender. date: 8/20/2019\n * Remove Sender. date: 8/20/2019\n * Use ES6. date: 10/10/2019\n */\n\n\n//# sourceURL=webpack:///./lib/mslib/index.js?");

/***/ }),

/***/ "./lib/mslib/internals.js":
/*!********************************!*\
  !*** ./lib/mslib/internals.js ***!
  \********************************/
/*! exports provided: Logger, EnhancedEventEmitter, utils, ortc, sdpCommonUtils, sdpUnifiedPlanUtils, sdpPlanBUtils, sdpPlainRtpUtils, RemoteUnifiedPlanSdp, RemotePlanBSdp, RemotePlainRtpSdp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Logger */ \"./lib/mslib/Logger.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Logger\", function() { return _Logger__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EnhancedEventEmitter */ \"./lib/mslib/EnhancedEventEmitter.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EnhancedEventEmitter\", function() { return _EnhancedEventEmitter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./lib/mslib/utils.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"utils\", function() { return _utils__WEBPACK_IMPORTED_MODULE_2__; });\n/* harmony import */ var _ortc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ortc */ \"./lib/mslib/ortc.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"ortc\", function() { return _ortc__WEBPACK_IMPORTED_MODULE_3__; });\n/* harmony import */ var _handlers_sdp_commonUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./handlers/sdp/commonUtils */ \"./lib/mslib/handlers/sdp/commonUtils.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"sdpCommonUtils\", function() { return _handlers_sdp_commonUtils__WEBPACK_IMPORTED_MODULE_4__; });\n/* harmony import */ var _handlers_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./handlers/sdp/unifiedPlanUtils */ \"./lib/mslib/handlers/sdp/unifiedPlanUtils.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"sdpUnifiedPlanUtils\", function() { return _handlers_sdp_unifiedPlanUtils__WEBPACK_IMPORTED_MODULE_5__; });\n/* harmony import */ var _handlers_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./handlers/sdp/planBUtils */ \"./lib/mslib/handlers/sdp/planBUtils.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"sdpPlanBUtils\", function() { return _handlers_sdp_planBUtils__WEBPACK_IMPORTED_MODULE_6__; });\n/* harmony import */ var _handlers_sdp_plainRtpUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./handlers/sdp/plainRtpUtils */ \"./lib/mslib/handlers/sdp/plainRtpUtils.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"sdpPlainRtpUtils\", function() { return _handlers_sdp_plainRtpUtils__WEBPACK_IMPORTED_MODULE_7__; });\n/* harmony import */ var _handlers_sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./handlers/sdp/RemoteUnifiedPlanSdp */ \"./lib/mslib/handlers/sdp/RemoteUnifiedPlanSdp.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RemoteUnifiedPlanSdp\", function() { return _handlers_sdp_RemoteUnifiedPlanSdp__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n/* harmony import */ var _handlers_sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./handlers/sdp/RemotePlanBSdp */ \"./lib/mslib/handlers/sdp/RemotePlanBSdp.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RemotePlanBSdp\", function() { return _handlers_sdp_RemotePlanBSdp__WEBPACK_IMPORTED_MODULE_9__[\"default\"]; });\n\n/* harmony import */ var _handlers_sdp_RemotePlainRtpSdp__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./handlers/sdp/RemotePlainRtpSdp */ \"./lib/mslib/handlers/sdp/RemotePlainRtpSdp.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RemotePlainRtpSdp\", function() { return _handlers_sdp_RemotePlainRtpSdp__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; });\n\n/**\n * This module is intended for custom handler developers and exposes internal\n * API and utilities. No public documentation is provided.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./lib/mslib/internals.js?");

/***/ }),

/***/ "./lib/mslib/ortc.js":
/*!***************************!*\
  !*** ./lib/mslib/ortc.js ***!
  \***************************/
/*! exports provided: getExtendedRtpCapabilities, getRtpCapabilities, getUnsupportedCodecs, canSend, canReceive, getSendingRtpParameters, getReceivingFullRtpParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getExtendedRtpCapabilities\", function() { return getExtendedRtpCapabilities; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRtpCapabilities\", function() { return getRtpCapabilities; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUnsupportedCodecs\", function() { return getUnsupportedCodecs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canSend\", function() { return canSend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canReceive\", function() { return canReceive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSendingRtpParameters\", function() { return getSendingRtpParameters; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getReceivingFullRtpParameters\", function() { return getReceivingFullRtpParameters; });\n/**\n * Generate extended RTP capabilities for sending and receiving.\n *\n * @param {RTCRtpCapabilities} localCaps - Local capabilities.\n * @param {RTCRtpCapabilities} remoteCaps - Remote capabilities.\n *\n * @return {RTCExtendedRtpCapabilities}\n */\nfunction getExtendedRtpCapabilities(localCaps, remoteCaps)\n{\n\tconst extendedCaps =\n\t{\n\t\tcodecs           : [],\n\t\theaderExtensions : [],\n\t\tfecMechanisms    : []\n\t};\n\n\t// Match media codecs and keep the order preferred by remoteCaps.\n\tfor (const remoteCodec of remoteCaps.codecs || [])\n\t{\n\t\t// TODO: Ignore pseudo-codecs and feature codecs.\n\t\tif (remoteCodec.name === 'rtx')\n\t\t\tcontinue;\n\n\t\tconst matchingLocalCodec = (localCaps.codecs || [])\n\t\t\t.find((localCodec) => matchCapCodecs(localCodec, remoteCodec));\n\n\t\tif (matchingLocalCodec)\n\t\t{\n\t\t\tconst extendedCodec =\n\t\t\t{\n\t\t\t\tname               : remoteCodec.name,\n\t\t\t\tmimeType           : remoteCodec.mimeType,\n\t\t\t\tkind               : remoteCodec.kind,\n\t\t\t\tclockRate          : remoteCodec.clockRate,\n\t\t\t\tsendPayloadType    : matchingLocalCodec.preferredPayloadType,\n\t\t\t\tsendRtxPayloadType : null,\n\t\t\t\trecvPayloadType    : remoteCodec.preferredPayloadType,\n\t\t\t\trecvRtxPayloadType : null,\n\t\t\t\tchannels           : remoteCodec.channels,\n\t\t\t\trtcpFeedback       : reduceRtcpFeedback(matchingLocalCodec, remoteCodec),\n\t\t\t\tparameters         : remoteCodec.parameters\n\t\t\t};\n\n\t\t\tif (!extendedCodec.channels)\n\t\t\t\tdelete extendedCodec.channels;\n\n\t\t\textendedCaps.codecs.push(extendedCodec);\n\t\t}\n\t}\n\n\t// Match RTX codecs.\n\tfor (const extendedCodec of extendedCaps.codecs || [])\n\t{\n\t\tconst matchingLocalRtxCodec = (localCaps.codecs || [])\n\t\t\t.find((localCodec) => (\n\t\t\t\tlocalCodec.name === 'rtx' &&\n\t\t\t\tlocalCodec.parameters.apt === extendedCodec.sendPayloadType\n\t\t\t));\n\n\t\tconst matchingRemoteRtxCodec = (remoteCaps.codecs || [])\n\t\t\t.find((remoteCodec) => (\n\t\t\t\tremoteCodec.name === 'rtx' &&\n\t\t\t\tremoteCodec.parameters.apt === extendedCodec.recvPayloadType\n\t\t\t));\n\n\t\tif (matchingLocalRtxCodec && matchingRemoteRtxCodec)\n\t\t{\n\t\t\textendedCodec.sendRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;\n\t\t\textendedCodec.recvRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;\n\t\t}\n\t}\n\n\t// Match header extensions.\n\tfor (const remoteExt of remoteCaps.headerExtensions || [])\n\t{\n\t\tconst matchingLocalExt = (localCaps.headerExtensions || [])\n\t\t\t.find((localExt) => matchCapHeaderExtensions(localExt, remoteExt));\n\n\t\tif (matchingLocalExt)\n\t\t{\n\t\t\tconst extendedExt =\n\t\t\t{\n\t\t\t\tkind   : remoteExt.kind,\n\t\t\t\turi    : remoteExt.uri,\n\t\t\t\tsendId : matchingLocalExt.preferredId,\n\t\t\t\trecvId : remoteExt.preferredId\n\t\t\t};\n\n\t\t\textendedCaps.headerExtensions.push(extendedExt);\n\t\t}\n\t}\n\n\treturn extendedCaps;\n}\n\n/**\n * Generate RTP capabilities for receiving media based on the given extended\n * RTP capabilities.\n *\n * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities\n *\n * @return {RTCRtpCapabilities}\n */\nfunction getRtpCapabilities(extendedRtpCapabilities)\n{\n\tconst caps =\n\t{\n\t\tcodecs           : [],\n\t\theaderExtensions : [],\n\t\tfecMechanisms    : []\n\t};\n\n\tfor (const capCodec of extendedRtpCapabilities.codecs)\n\t{\n\t\tconst codec =\n\t\t{\n\t\t\tname                 : capCodec.name,\n\t\t\tmimeType             : capCodec.mimeType,\n\t\t\tkind                 : capCodec.kind,\n\t\t\tclockRate            : capCodec.clockRate,\n\t\t\tpreferredPayloadType : capCodec.recvPayloadType,\n\t\t\tchannels             : capCodec.channels,\n\t\t\trtcpFeedback         : capCodec.rtcpFeedback,\n\t\t\tparameters           : capCodec.parameters\n\t\t};\n\n\t\tif (!codec.channels)\n\t\t\tdelete codec.channels;\n\n\t\tcaps.codecs.push(codec);\n\n\t\t// Add RTX codec.\n\t\tif (capCodec.recvRtxPayloadType)\n\t\t{\n\t\t\tconst rtxCapCodec =\n\t\t\t{\n\t\t\t\tname                 : 'rtx',\n\t\t\t\tmimeType             : `${capCodec.kind}/rtx`,\n\t\t\t\tkind                 : capCodec.kind,\n\t\t\t\tclockRate            : capCodec.clockRate,\n\t\t\t\tpreferredPayloadType : capCodec.recvRtxPayloadType,\n\t\t\t\tparameters           :\n\t\t\t\t{\n\t\t\t\t\tapt : capCodec.recvPayloadType\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcaps.codecs.push(rtxCapCodec);\n\t\t}\n\n\t\t// TODO: In the future, we need to add FEC, CN, etc, codecs.\n\t}\n\n\tfor (const capExt of extendedRtpCapabilities.headerExtensions)\n\t{\n\t\tconst ext =\n\t\t{\n\t\t\tkind        : capExt.kind,\n\t\t\turi         : capExt.uri,\n\t\t\tpreferredId : capExt.recvId\n\t\t};\n\n\t\tcaps.headerExtensions.push(ext);\n\t}\n\n\tcaps.fecMechanisms = extendedRtpCapabilities.fecMechanisms;\n\n\treturn caps;\n}\n\n/**\n * Get unsupported remote codecs.\n *\n * @param {RTCRtpCapabilities} remoteCaps - Remote capabilities.\n * @param {Array<Number>} mandatoryCodecPayloadTypes - List of codec PT values.\n * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities\n *\n * @return {Boolean}\n */\nfunction getUnsupportedCodecs(\n\tremoteCaps, mandatoryCodecPayloadTypes, extendedRtpCapabilities)\n{\n\t// If not given just ignore.\n\tif (!Array.isArray(mandatoryCodecPayloadTypes))\n\t\treturn [];\n\n\tconst unsupportedCodecs = [];\n\tconst remoteCodecs = remoteCaps.codecs;\n\tconst supportedCodecs = extendedRtpCapabilities.codecs;\n\n\tfor (const pt of mandatoryCodecPayloadTypes)\n\t{\n\t\tif (!supportedCodecs.some((codec) => codec.recvPayloadType === pt))\n\t\t{\n\t\t\tconst unsupportedCodec = remoteCodecs\n\t\t\t\t.find((codec) => codec.preferredPayloadType === pt);\n\n\t\t\tif (!unsupportedCodec)\n\t\t\t\tthrow new Error(`mandatory codec PT ${pt} not found in remote codecs`);\n\n\t\t\tunsupportedCodecs.push(unsupportedCodec);\n\t\t}\n\t}\n\n\treturn unsupportedCodecs;\n}\n\n/**\n * Whether media can be sent based on the given RTP capabilities.\n *\n * @param {String} kind\n * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities\n *\n * @return {Boolean}\n */\nfunction canSend(kind, extendedRtpCapabilities)\n{\n\treturn extendedRtpCapabilities.codecs.\n\t\tsome((codec) => codec.kind === kind);\n}\n\n/**\n * Whether the given RTP parameters can be received with the given RTP\n * capabilities.\n *\n * @param {RTCRtpParameters} rtpParameters\n * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities\n *\n * @return {Boolean}\n */\nfunction canReceive(rtpParameters, extendedRtpCapabilities)\n{\n\tif (rtpParameters.codecs.length === 0)\n\t\treturn false;\n\n\tconst firstMediaCodec = rtpParameters.codecs[0];\n\n\treturn extendedRtpCapabilities.codecs\n\t\t.some((codec) => codec.recvPayloadType === firstMediaCodec.payloadType);\n}\n\n/**\n * Generate RTP parameters of the given kind for sending media.\n * Just the first media codec per kind is considered.\n * NOTE: muxId, encodings and rtcp fields are left empty.\n *\n * @param {kind} kind\n * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities\n *\n * @return {RTCRtpParameters}\n */\nfunction getSendingRtpParameters(kind, extendedRtpCapabilities)\n{\n\tconst params =\n\t{\n\t\tmuxId            : null,\n\t\tcodecs           : [],\n\t\theaderExtensions : [],\n\t\tencodings        : [],\n\t\trtcp             : {}\n\t};\n\n\tfor (const capCodec of extendedRtpCapabilities.codecs)\n\t{\n\t\tif (capCodec.kind !== kind)\n\t\t\tcontinue;\n\n\t\tconst codec =\n\t\t{\n\t\t\tname         : capCodec.name,\n\t\t\tmimeType     : capCodec.mimeType,\n\t\t\tclockRate    : capCodec.clockRate,\n\t\t\tpayloadType  : capCodec.sendPayloadType,\n\t\t\tchannels     : capCodec.channels,\n\t\t\trtcpFeedback : capCodec.rtcpFeedback,\n\t\t\tparameters   : capCodec.parameters\n\t\t};\n\n\t\tif (!codec.channels)\n\t\t\tdelete codec.channels;\n\n\t\tparams.codecs.push(codec);\n\n\t\t// Add RTX codec.\n\t\tif (capCodec.sendRtxPayloadType)\n\t\t{\n\t\t\tconst rtxCodec =\n\t\t\t{\n\t\t\t\tname        : 'rtx',\n\t\t\t\tmimeType    : `${capCodec.kind}/rtx`,\n\t\t\t\tclockRate   : capCodec.clockRate,\n\t\t\t\tpayloadType : capCodec.sendRtxPayloadType,\n\t\t\t\tparameters  :\n\t\t\t\t{\n\t\t\t\t\tapt : capCodec.sendPayloadType\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tparams.codecs.push(rtxCodec);\n\t\t}\n\n\t\t// NOTE: We assume a single media codec plus an optional RTX codec for now.\n\t\t// TODO: In the future, we need to add FEC, CN, etc, codecs.\n\t\tbreak;\n\t}\n\n\tfor (const capExt of extendedRtpCapabilities.headerExtensions)\n\t{\n\t\tif (capExt.kind && capExt.kind !== kind)\n\t\t\tcontinue;\n\n\t\tconst ext =\n\t\t{\n\t\t\turi : capExt.uri,\n\t\t\tid  : capExt.sendId\n\t\t};\n\n\t\tparams.headerExtensions.push(ext);\n\t}\n\n\treturn params;\n}\n\n/**\n * Generate RTP parameters of the given kind for receiving media.\n * All the media codecs per kind are considered. This is useful for generating\n * a SDP remote offer.\n * NOTE: muxId, encodings and rtcp fields are left empty.\n *\n * @param {String} kind\n * @param {RTCExtendedRtpCapabilities} extendedRtpCapabilities\n *\n * @return {RTCRtpParameters}\n */\nfunction getReceivingFullRtpParameters(kind, extendedRtpCapabilities)\n{\n\tconst params =\n\t{\n\t\tmuxId            : null,\n\t\tcodecs           : [],\n\t\theaderExtensions : [],\n\t\tencodings        : [],\n\t\trtcp             : {}\n\t};\n\n\tfor (const capCodec of extendedRtpCapabilities.codecs)\n\t{\n\t\tif (capCodec.kind !== kind)\n\t\t\tcontinue;\n\n\t\tconst codec =\n\t\t{\n\t\t\tname         : capCodec.name,\n\t\t\tmimeType     : capCodec.mimeType,\n\t\t\tclockRate    : capCodec.clockRate,\n\t\t\tpayloadType  : capCodec.recvPayloadType,\n\t\t\tchannels     : capCodec.channels,\n\t\t\trtcpFeedback : capCodec.rtcpFeedback,\n\t\t\tparameters   : capCodec.parameters\n\t\t};\n\n\t\tif (!codec.channels)\n\t\t\tdelete codec.channels;\n\n\t\tparams.codecs.push(codec);\n\n\t\t// Add RTX codec.\n\t\tif (capCodec.recvRtxPayloadType)\n\t\t{\n\t\t\tconst rtxCodec =\n\t\t\t{\n\t\t\t\tname        : 'rtx',\n\t\t\t\tmimeType    : `${capCodec.kind}/rtx`,\n\t\t\t\tclockRate   : capCodec.clockRate,\n\t\t\t\tpayloadType : capCodec.recvRtxPayloadType,\n\t\t\t\tparameters  :\n\t\t\t\t{\n\t\t\t\t\tapt : capCodec.recvPayloadType\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tparams.codecs.push(rtxCodec);\n\t\t}\n\n\t\t// TODO: In the future, we need to add FEC, CN, etc, codecs.\n\t}\n\n\tfor (const capExt of extendedRtpCapabilities.headerExtensions)\n\t{\n\t\tif (capExt.kind && capExt.kind !== kind)\n\t\t\tcontinue;\n\n\t\tconst ext =\n\t\t{\n\t\t\turi : capExt.uri,\n\t\t\tid  : capExt.recvId\n\t\t};\n\n\t\tparams.headerExtensions.push(ext);\n\t}\n\n\treturn params;\n}\n\nfunction matchCapCodecs(aCodec, bCodec)\n{\n\tconst aMimeType = aCodec.mimeType.toLowerCase();\n\tconst bMimeType = bCodec.mimeType.toLowerCase();\n\n\tif (aMimeType !== bMimeType)\n\t\treturn false;\n\n\tif (aCodec.clockRate !== bCodec.clockRate)\n\t\treturn false;\n\n\tif (aCodec.channels !== bCodec.channels)\n\t\treturn false;\n\n\t// Match H264 parameters.\n\tif (aMimeType === 'video/h264')\n\t{\n\t\tconst aPacketizationMode = (aCodec.parameters || {})['packetization-mode'] || 0;\n\t\tconst bPacketizationMode = (bCodec.parameters || {})['packetization-mode'] || 0;\n\n\t\tif (aPacketizationMode !== bPacketizationMode)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction matchCapHeaderExtensions(aExt, bExt)\n{\n\tif (aExt.kind && bExt.kind && aExt.kind !== bExt.kind)\n\t\treturn false;\n\n\tif (aExt.uri !== bExt.uri)\n\t\treturn false;\n\n\treturn true;\n}\n\nfunction reduceRtcpFeedback(codecA, codecB)\n{\n\tconst reducedRtcpFeedback = [];\n\n\tfor (const aFb of codecA.rtcpFeedback || [])\n\t{\n\t\tconst matchingBFb = (codecB.rtcpFeedback || [])\n\t\t\t.find((bFb) => (\n\t\t\t\tbFb.type === aFb.type &&\n\t\t\t\tbFb.parameter === aFb.parameter\n\t\t\t));\n\n\t\tif (matchingBFb)\n\t\t\treducedRtcpFeedback.push(matchingBFb);\n\t}\n\n\treturn reducedRtcpFeedback;\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/ortc.js?");

/***/ }),

/***/ "./lib/mslib/utils.js":
/*!****************************!*\
  !*** ./lib/mslib/utils.js ***!
  \****************************/
/*! exports provided: randomNumber, clone */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomNumber\", function() { return randomNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony import */ var random_number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! random-number */ \"./node_modules/random-number/index.js\");\n/* harmony import */ var random_number__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(random_number__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst randomNumberGenerator = random_number__WEBPACK_IMPORTED_MODULE_0___default.a.generator(\n\t{\n\t\tmin     : 10000000,\n\t\tmax     : 99999999,\n\t\tinteger : true\n\t});\n\n/**\n * Generates a random positive number between 10000000 and 99999999.\n *\n * @return {Number}\n */\nfunction randomNumber()\n{\n\treturn randomNumberGenerator();\n}\n\n/**\n * Clones the given Object/Array.\n *\n * @param {Object|Array} obj\n *\n * @return {Object|Array}\n */\nfunction clone(obj)\n{\n\treturn JSON.parse(JSON.stringify(obj));\n}\n\n\n//# sourceURL=webpack:///./lib/mslib/utils.js?");

/***/ }),

/***/ "./lib/protoo/Message.js":
/*!*******************************!*\
  !*** ./lib/protoo/Message.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const logger = __webpack_require__(/*! ../logger */ \"./lib/logger.js\")('protooMessage');\nconst utils = __webpack_require__(/*! ./utils */ \"./lib/protoo/utils.js\");\n\nclass Message\n{\n\tstatic parse(raw)\n\t{\n\t\tlet object;\n\t\tconst message = {};\n\n\t\ttry\n\t\t{\n\t\t\tobject = JSON.parse(raw);\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.error('parse() | invalid JSON: %s', error);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (typeof object !== 'object' || Array.isArray(object))\n\t\t{\n\t\t\tlogger.error('parse() | not an object');\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Request.\n\t\tif (object.request)\n\t\t{\n\t\t\tmessage.request = true;\n\n\t\t\tif (typeof object.method !== 'string')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid method field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof object.id !== 'number')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid id field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.id = object.id;\n\n\t\t\tmessage.method = object.method;\n\t\t\tmessage.data = object.data || {};\n\t\t}\n\t\t// Response.\n\t\telse if (object.response)\n\t\t{\n\t\t\tmessage.response = true;\n\n\t\t\tif (typeof object.id !== 'number')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid id field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.id = object.id;\n\n\t\t\t// Success.\n\t\t\tif (object.ok)\n\t\t\t{\n\t\t\t\tmessage.ok = true;\n\t\t\t\tmessage.data = object.data || {};\n\t\t\t}\n\t\t\t// Error.\n\t\t\telse\n\t\t\t{\n\t\t\t\tmessage.errorCode = object.errorCode;\n\t\t\t\tmessage.errorReason = object.errorReason;\n\t\t\t}\n\t\t}\n\t\t// Notification.\n\t\telse if (object.notification)\n\t\t{\n\t\t\tmessage.notification = true;\n\n\t\t\tif (typeof object.method !== 'string')\n\t\t\t{\n\t\t\t\tlogger.error('parse() | missing/invalid method field');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmessage.method = object.method;\n\t\t\tmessage.data = object.data || {};\n\t\t}\n\t\t// Invalid.\n\t\telse\n\t\t{\n\t\t\tlogger.error('parse() | missing request/response field');\n\n\t\t\treturn;\n\t\t}\n\n\t\treturn message;\n\t}\n\n\tstatic requestFactory(method, data)\n\t{\n\t\tconst request =\n\t\t{\n\t\t\trequest : true,\n\t\t\tid      : utils.randomNumber(),\n\t\t\tmethod  : method,\n\t\t\tdata    : data || {}\n\t\t};\n\n\t\treturn request;\n\t}\n\n\tstatic successResponseFactory(request, data)\n\t{\n\t\tconst response =\n\t\t{\n\t\t\tresponse : true,\n\t\t\tid       : request.id,\n\t\t\tok       : true,\n\t\t\tdata     : data || {}\n\t\t};\n\n\t\treturn response;\n\t}\n\n\tstatic errorResponseFactory(request, errorCode, errorReason)\n\t{\n\t\tconst response =\n\t\t{\n\t\t\tresponse    : true,\n\t\t\tid          : request.id,\n\t\t\terrorCode   : errorCode,\n\t\t\terrorReason : errorReason\n\t\t};\n\n\t\treturn response;\n\t}\n\n\tstatic notificationFactory(method, data)\n\t{\n\t\tconst notification =\n\t\t{\n\t\t\tnotification : true,\n\t\t\tmethod       : method,\n\t\t\tdata         : data || {}\n\t\t};\n\n\t\treturn notification;\n\t}\n}\n\nmodule.exports = Message;\n\n\n//# sourceURL=webpack:///./lib/protoo/Message.js?");

/***/ }),

/***/ "./lib/protoo/Peer.js":
/*!****************************!*\
  !*** ./lib/protoo/Peer.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst logger = __webpack_require__(/*! ../logger */ \"./lib/logger.js\")('protooPeer');\nconst Message = __webpack_require__(/*! ./Message */ \"./lib/protoo/Message.js\");\nconst transports = __webpack_require__(/*! ./transports */ \"./lib/protoo/transports/index.js\");\n\n// Max time waiting for a response.\nconst REQUEST_TIMEOUT = 20000;\n\nclass Peer extends EventEmitter\n{\n\tconstructor(protooUrl)\n\t{\n\t\tlogger.debug(`constructor() protooUrl: ${protooUrl}`);\n\n\t\tsuper();\n\t\t\n\t\tthis.setMaxListeners(Infinity);\n\n\t\tthis._protooUrl = protooUrl;\n\n\t\t// Transport.\n\t\tthis._transport = new transports.WebSocketTransport(protooUrl);\n\n\t\t// Closed flag.\n\t\tthis._closed = false;\n\n\t\t// Connected flag.\n\t\t// @type {Boolean}\n\t\tthis._connected = false;\n\n\t\t// Custom data object.\n\t\tthis._data = {};\n\n\t\t// Map of sent requests' handlers indexed by request.id.\n\t\tthis._requestHandlers = new Map();\n\n\t\t// Handle transport.\n\t\tthis._handleTransport();\n\t}\n\n\tget data()\n\t{\n\t\treturn this._data;\n\t}\n\n\tset data(obj)\n\t{\n\t\tthis._data = obj || {};\n\t}\n\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\t/**\n\t * Whether the Peer is connected.\n\t *\n\t * @returns {Boolean}\n\t */\n\tget connected()\n\t{\n\t\treturn this._connected;\n\t}\n\n\tsend(method, data)\n\t{\n\t\tif (!this.connected)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// \n\t\tconst request = Message.requestFactory(method, data);\n\n\t\treturn this._transport.send(request)\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\treturn new Promise((pResolve, pReject) =>\n\t\t\t\t{\n\t\t\t\t\tconst handler =\n\t\t\t\t\t{\n\t\t\t\t\t\tresolve : (data2) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!this._requestHandlers.delete(request.id))\n\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\tclearTimeout(handler.timer);\n\t\t\t\t\t\t\tpResolve(data2);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\treject : (error) =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!this._requestHandlers.delete(request.id))\n\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\tclearTimeout(handler.timer);\n\t\t\t\t\t\t\tpReject(error);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\ttimer : setTimeout(() =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!this._requestHandlers.delete(request.id))\n\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\tpReject(new Error('request timeout'));\n\t\t\t\t\t\t}, REQUEST_TIMEOUT),\n\n\t\t\t\t\t\tclose : () =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclearTimeout(handler.timer);\n\t\t\t\t\t\t\tpReject(new Error('peer closed'));\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Add handler stuff to the Map.\n\t\t\t\t\tthis._requestHandlers.set(request.id, handler);\n\t\t\t\t});\n\t\t\t});\n\t}\n\n\tnotify(method, data)\n\t{\n\t\tconst notification = Message.notificationFactory(method, data);\n\n\t\treturn this._transport.send(notification);\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._closed = true;\n\n\t\t// Close transport.\n\t\tthis._transport.close();\n\n\t\t// Close every pending request handler.\n\t\tthis._requestHandlers.forEach((handler) => handler.close());\n\n\t\t// Emit 'close' event.\n\t\tthis.emit('close');\n\t}\n\n\t_handleTransport()\n\t{\n\t\tif (this._transport.closed)\n\t\t{\n\t\t\tthis._closed = true;\n\t\t\tsetTimeout(() => this.emit('close'));\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis._transport.on('connecting', (currentAttempt) =>\n\t\t{\n\t\t\tlogger.debug(`_handleTransport() _transport event [connecting] - [currentAttempt: ${currentAttempt}]`);\n\n\t\t\tthis.emit('connecting', currentAttempt);\n\t\t});\n\n\t\tthis._transport.on('open', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('_handleTransport() _transport event [open]');\n\t\t\t\n\t\t\tthis._connected = true;\n\n\t\t\t// Emit 'open' event.\n\t\t\tthis.emit('open');\n\t\t});\n\n\t\tthis._transport.on('conn-interrupt', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('_handleTransport() _transport event [conn-interrupt]');\n\n\t\t\tthis._connected = false;\n\n\t\t\t// Emit 'conn-interrupt' event.\n\t\t\tthis.emit('conn-interrupt');\n\t\t});\n\n\t\tthis._transport.on('reinit', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('_handleTransport(0 _transport event [reinit]');\n\n\t\t\tthis._connected = true;\n\n\t\t\t// Emit 'reinit' event.\n\t\t\tthis.emit('reinit');\n\t\t});\n\n\t\tthis._transport.on('conn-reconn', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tlogger.debug('_handleTransport() _transport event [conn-reconn]');\n\t\t\t\n\t\t\tthis._connected = true;\n\n\t\t\t// Emit 'conn-reconn' event.\n\t\t\tthis.emit('conn-reconn');\n\t\t});\n\n\t\t// 从 WebSocketTransport 层上报的 disconnected 事件，表示当前已彻底断链（已经过多次重试，最终失败）\n\t\tthis._transport.on('disconnected', () =>\n\t\t{\n\t\t\tlogger.debug('_handleTransport() _transport [disconnected]');\n\n\t\t\tthis._connected = false;\n\n\t\t\tthis.emit('disconnected');\n\t\t});\n\n\t\tthis._transport.on('failed', (currentAttempt) =>\n\t\t{\n\t\t\tlogger.debug(`_handleTransport() _transport event [failed] - [currentAttempt: ${currentAttempt}]`);\n\n\t\t\tthis._connected = false;\n\n\t\t\tthis.emit('failed', currentAttempt);\n\t\t});\n\n\t\tthis._transport.on('close', () =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t\treturn;\n\n\t\t\tthis._closed = true;\n\n\t\t\tthis._connected = false;\n\n\t\t\tlogger.debug('_handleTransport() _transport event [close]');\n\n\t\t\t// Emit 'close' event.\n\t\t\tthis.emit('close');\n\t\t});\n\n\t\tthis._transport.on('message', (message) =>\n\t\t{\n\t\t\tif (message.request)\n\t\t\t{\n\t\t\t\tthis._handleRequest(message);\n\t\t\t}\n\t\t\telse if (message.response)\n\t\t\t{\n\t\t\t\tthis._handleResponse(message);\n\t\t\t}\n\t\t\telse if (message.notification)\n\t\t\t{\n\t\t\t\tthis._handleNotification(message);\n\t\t\t}\n\t\t});\n\t}\n\n\t_handleRequest(request)\n\t{\n\t\tthis.emit('request',\n\t\t\t// Request.\n\t\t\trequest,\n\t\t\t// accept() function.\n\t\t\t(data) =>\n\t\t\t{\n\t\t\t\tconst response = Message.successResponseFactory(request, data);\n\n\t\t\t\tthis._transport.send(response)\n\t\t\t\t\t.catch((error) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.warn(`_handleRequest() accept() _transport.send error - ${JSON.stringify(error)}`);\n\t\t\t\t\t});\n\t\t\t},\n\t\t\t// reject() function.\n\t\t\t(errorCode, errorReason) =>\n\t\t\t{\n\t\t\t\tif (errorCode instanceof Error)\n\t\t\t\t{\n\t\t\t\t\terrorReason = errorCode.toString();\n\t\t\t\t\terrorCode = 500;\n\t\t\t\t}\n\t\t\t\telse if (typeof errorCode === 'number' && errorReason instanceof Error)\n\t\t\t\t{\n\t\t\t\t\terrorReason = errorReason.toString();\n\t\t\t\t}\n\n\t\t\t\tconst response =\n\t\t\t\t\tMessage.errorResponseFactory(request, errorCode, errorReason);\n\n\t\t\t\tthis._transport.send(response)\n\t\t\t\t\t.catch((error) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.warn(`_handleRequest() reject() error - ${JSON.stringify(error)}`);\n\t\t\t\t\t});\n\t\t\t});\n\t}\n\n\t_handleResponse(response)\n\t{\n\t\tconst handler = this._requestHandlers.get(response.id);\n\n\t\tif (!handler)\n\t\t{\n\t\t\tlogger.error('_handleResponse() received response does not match any sent request');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (response.ok)\n\t\t{\n\t\t\thandler.resolve(response.data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst error = new Error(response.errorReason);\n\n\t\t\terror.code = response.errorCode;\n\t\t\thandler.reject(error);\n\t\t}\n\t}\n\n\t_handleNotification(notification)\n\t{\n\t\tthis.emit('notification', notification);\n\t}\n}\n\nmodule.exports = Peer;\n\n\n//# sourceURL=webpack:///./lib/protoo/Peer.js?");

/***/ }),

/***/ "./lib/protoo/index.js":
/*!*****************************!*\
  !*** ./lib/protoo/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Peer = __webpack_require__(/*! ./Peer */ \"./lib/protoo/Peer.js\");\nconst transports = __webpack_require__(/*! ./transports */ \"./lib/protoo/transports/index.js\");\n\nmodule.exports =\n{\n\t/**\n\t * Expose Peer.\n\t */\n\tPeer : Peer,\n\n\t/**\n\t * Expose the built-in WebSocketTransport.\n\t */\n\tWebSocketTransport : transports.WebSocketTransport\n};\n/**\n * REF: Base upon Protoo-client 3.0.0.\n * Changelogs:\n */\n\n//# sourceURL=webpack:///./lib/protoo/index.js?");

/***/ }),

/***/ "./lib/protoo/transports/WebSocketTransport.js":
/*!*****************************************************!*\
  !*** ./lib/protoo/transports/WebSocketTransport.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nconst W3CWebSocket = __webpack_require__(/*! websocket */ \"./node_modules/websocket/lib/browser.js\").w3cwebsocket;\nconst retry = __webpack_require__(/*! retry */ \"./node_modules/retry/index.js\");\nconst logger = __webpack_require__(/*! ../../logger */ \"./lib/logger.js\")('protooWebSocketTransport');\nconst Message = __webpack_require__(/*! ../Message */ \"./lib/protoo/Message.js\");\n\nconst WS_SUBPROTOCOL = 'protoo';\nconst DEFAULT_RETRY_OPTIONS =\n{\n\tretries: 10,\n\tfactor: 2,\n\tminTimeout: 1 * 1000,\n\tmaxTimeout: 4 * 1000\n};\n\nclass WebSocketTransport extends EventEmitter\n{\n\tconstructor(url, options)\n\t{\n\t\tlogger.debug(`constructor() - url: ${url} options: ${JSON.stringify(options)}`);\n\n\t\tsuper();\n\t\tthis.setMaxListeners(Infinity);\n\n\t\t// Save URL and options.\n\t\t// 在 url 后追加 sid，用于 服务器端标识本客户端的该会话 （主要用于本客户端断网重连时标识用）\n\t\tconst timestamp = Date.parse(new Date());\n\t\tconst randNum = Math.round(Math.random() * 1000000000);\n\n\t\tthis._origUrl = `${url}&sid=${timestamp}-${randNum}`;\n\t\tthis._url = this._origUrl;\n\t\t// \n\t\tthis._options = options || {};\n\n\t\t// WebSocket instance.\n\t\tthis._ws = null;\n\n\t\t// \n\t\tthis._xNeedReInit = false;\n\n\t\t// Closed flag.\n\t\tthis._closed = false;\n\n\t\t// 当前的连接状态\n\t\tthis._connected = false;\n\n\t\t// Set WebSocket\n\t\tthis._setWebSocket();\n\t}\n\n\tget connected()\n\t{\n\t\treturn this._connected;\n\t}\n\n\tget closed()\n\t{\n\t\treturn this._closed;\n\t}\n\n\tsend(message)\n\t{\n\t\tif (this._closed)\n\t\t\treturn Promise.reject(new Error('transport closed'));\n\n\t\ttry\n\t\t{\n\t\t\tthis._ws.send(JSON.stringify(message));\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.warn(`send() messge: ${JSON.stringify(message)} error - ${error.toString()}`);\n\n\t\t\treturn Promise.reject(error);\n\t\t}\n\t}\n\n\tclose()\n\t{\n\t\tlogger.debug('close()');\n\n\t\tif (this._closed)\n\t\t\treturn;\n\n\t\tthis._xNeedReInit = false;\n\n\t\t// Don't wait for the WebSocket 'close' event, do it now.\n\t\tthis._closed = true;\n\t\tthis.emit('close', { code: 3000, reason: 'active close' });\n\n\t\ttry\n\t\t{\n\t\t\tthis._ws.onopen = null;\n\t\t\tthis._ws.onclose = null;\n\t\t\tthis._ws.onerror = null;\n\t\t\tthis._ws.onmessage = null;\n\t\t\tthis._ws.close();\n\t\t}\n\t\tcatch (error)\n\t\t{\n\t\t\tlogger.error(`close() error - closing the WebSocket: ${error.toString()}`);\n\t\t}\n\t}\n\n\t_setWebSocket()\n\t{\n\t\tconst options = this._options;\n\t\tconst operation = retry.operation(this._options.retry || DEFAULT_RETRY_OPTIONS);\n\t\tthis._connected = false;\n\n\t\toperation.attempt((currentAttempt) =>\n\t\t{\n\t\t\tif (this._closed)\n\t\t\t{\n\t\t\t\toperation.stop();\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// \n\t\t\tif (this._ws != null)\n\t\t\t{\n\t\t\t\tthis._ws.close();\n\t\t\t\tthis._ws = null;\n\t\t\t}\n\n\t\t\tlogger.debug(`_setWebSocket() - currentAttempt: ${currentAttempt}`);\n\n\t\t\tthis._ws = new W3CWebSocket(\n\t\t\t\tthis._url,\n\t\t\t\tWS_SUBPROTOCOL,\n\t\t\t\toptions.origin,\n\t\t\t\toptions.headers,\n\t\t\t\toptions.requestOptions,\n\t\t\t\toptions.clientConfig\n\t\t\t);\n\n\t\t\tthis.emit('connecting', currentAttempt);\n\n\t\t\tthis._ws.onopen = (e) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tthis._connected = true;\n\n\t\t\t\t// Emit 'open' event.\n\t\t\t\tconst suffix = 'retry=true';\n\t\t\t\tif (this._url.indexOf(suffix, this._url.length - suffix.length) !== -1)\n\t\t\t\t{\n\t\t\t\t\tlogger.debug(`WebSocket event - [conn-reconn] - this._url: ${this._url}`);\n\n\t\t\t\t\tthis.emit('conn-reconn');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tconst evt = this._xNeedReInit ? 'reinit' : 'open';\n\n\t\t\t\t\tlogger.debug(`WebSocket event - [${evt}] - this._url: ${this._url}`);\n\n\t\t\t\t\t// 将 _xNeedReInit 复位\n\t\t\t\t\tthis._xNeedReInit = false;\n\n\t\t\t\t\tthis.emit(evt);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._ws.onclose = (event) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\t// Emit 'conn-interrupt' event.\n\t\t\t\tthis.emit('conn-interrupt', event);\n\n\t\t\t\tlogger.warn(`WebSocket event - [close] wasClean: ${event.wasClean} code: ${event.code} reason: ${event.reason}`);\n\n\t\t\t\t// Don't retry if code is 4000 (closed by the server).\n\t\t\t\tif (event.code !== 4000)\n\t\t\t\t{\n\t\t\t\t\t// TODO : 未来再考虑对 3003 这种情况的重连恢复 -- 目前仅仅是彻底close\n\t\t\t\t\tthis._xNeedReInit = (event.code === 3003); // 如果关闭码为 3003 ，则要求客户端完全重新开始（设置retry）\n\n\t\t\t\t\t// If it was not connected, try again.\n\t\t\t\t\tif (!this._connected && !this._xNeedReInit)\n\t\t\t\t\t{\n\t\t\t\t\t\t// this.emit('failed', currentAttempt);\n\n\t\t\t\t\t\tif (this._closed)\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tif (operation.retry(true))\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// If it was connected, start from scratch.\n\t\t\t\t\t\toperation.stop();\n\n\t\t\t\t\t\tif (this._closed)\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t// 由于本次是 retry ，则在 url 后追加 retry=true\n\t\t\t\t\t\t// There have some issues on server then comments it now.\n\t\t\t\t\t\tthis._url = this._xNeedReInit ? `${this._origUrl}&timestamp=${+new Date()}` : `${this._origUrl}&timestamp=${+new Date()}&retry=true`;\n\n\t\t\t\t\t\tlogger.debug(`WebSocket event - [close] event.code !== 4000 - retry websocket transport: ${this._url}`);\n\n\t\t\t\t\t\tthis._setWebSocket();\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis._xNeedReInit = false;\n\n\t\t\t\t\t// 消除 url 中的 retry=true\n\t\t\t\t\tthis._url = `${this._origUrl}&timestamp=${+new Date()}`;\n\n\t\t\t\t\t// 不再尝试重试，当前已进入最终断开状态，向上层抛出 [close] 事件\n\t\t\t\t\tthis._closed = true;\n\n\t\t\t\t\tlogger.debug('WebSocket event - [close] event.code === 4000 - Emit [close]');\n\t\t\t\t\t// Emit 'close' event.\n\t\t\t\t\tthis.emit('close', event);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis._ws.onerror = (e) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tlogger.error(`WebSocket event [error] - ${e.toString()} - nothing todo.`);\n\t\t\t};\n\n\t\t\tthis._ws.onmessage = (event) =>\n\t\t\t{\n\t\t\t\tif (this._closed)\n\t\t\t\t\treturn;\n\n\t\t\t\tconst message = Message.parse(event.data);\n\n\t\t\t\tif (!message)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (this.listenerCount('message') === 0)\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('no listeners for WebSocket event [message] - ignoring received message');\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Emit 'message' event.\n\t\t\t\tthis.emit('message', message);\n\t\t\t};\n\t\t});\n\t}\n}\n\nmodule.exports = WebSocketTransport;\n\n\n//# sourceURL=webpack:///./lib/protoo/transports/WebSocketTransport.js?");

/***/ }),

/***/ "./lib/protoo/transports/index.js":
/*!****************************************!*\
  !*** ./lib/protoo/transports/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const WebSocketTransport = __webpack_require__(/*! ./WebSocketTransport */ \"./lib/protoo/transports/WebSocketTransport.js\");\n\nmodule.exports =\n{\n\tWebSocketTransport : WebSocketTransport\n};\n\n\n//# sourceURL=webpack:///./lib/protoo/transports/index.js?");

/***/ }),

/***/ "./lib/protoo/utils.js":
/*!*****************************!*\
  !*** ./lib/protoo/utils.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const randomNumber = __webpack_require__(/*! random-number */ \"./node_modules/random-number/index.js\");\n\nconst randomNumberGenerator = randomNumber.generator(\n\t{\n\t\tmin     : 1000000,\n\t\tmax     : 9999999,\n\t\tinteger : true\n\t});\n\nmodule.exports =\n{\n\trandomNumber : randomNumberGenerator\n};\n\n\n//# sourceURL=webpack:///./lib/protoo/utils.js?");

/***/ }),

/***/ "./lib/sdpform/grammar.js":
/*!********************************!*\
  !*** ./lib/sdpform/grammar.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  //k: [{}], // outdated thing ignored\n  t: [{ //t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{ //c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{ //b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    { //a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-\\.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding) ?\n          'rtpmap:%d %s/%s/%s':\n          o.rate ?\n          'rtpmap:%d %s/%s':\n          'rtpmap:%d %s';\n      }\n    },\n    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      //a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    { //a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    { //a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null) ?\n          'rtcp:%d %s IP%d %s':\n          'rtcp:%d';\n      }\n    },\n    { //a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%d trr-int %d'\n    },\n    { //a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null) ?\n          'rtcp-fb:%s %s %s':\n          'rtcp-fb:%s %s';\n      }\n    },\n    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      //a=extmap:1/recvonly URI-gps-string\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'uri', 'config'],\n      format: function (o) {\n        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n      }\n    },\n    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null) ?\n          'crypto:%d %s %s %s':\n          'crypto:%d %s %s';\n      }\n    },\n    { //a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    { //a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    { //a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*)/,\n      format: 'ptime:%d'\n    },\n    { //a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*)/,\n      format: 'maxptime:%d'\n    },\n    { //a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    { //a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    { //a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    { //a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    { //a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    { //a=ssrc-group:FEC 1 2\n      //a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    { //a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    { //a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    { //a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    { //a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null) ?\n          'sctpmap:%s %s %s' :\n          'sctpmap:%s %s';\n      }\n    },\n    { //a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      //a=imageattr:* send [x=800,y=640] recv *\n      //a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        //a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        //recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      //a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        //a=simulcast:\n        '^simulcast:' +\n        //send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        //space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        //end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    { //Old simulcast draft 03 (implemented by Firefox)\n      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      //a=simulcast: recv pt=97;98 send pt=97\n      //a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      //a=framerate:25\n      //a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    { // RFC4570\n      //a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    },\n    { //a=bundle-only\n      name: 'bundleOnly',\n      reg: /^(bundle-only)/\n    },\n    { //a=label:1\n      name: 'label',\n      reg: /^label:(.+)/,\n      format: 'label:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n      name:'sctpPort',\n      reg: /^sctp-port:(\\d+)$/,\n      format: 'sctp-port:%s'\n    },\n    {\n      // RFC version 26 for SCTP over DTLS\n      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n      name:'maxMessageSize',\n      reg: /^max-message-size:(\\d+)$/,\n      format: 'max-message-size:%s'\n    },\n    { // any a= that we don't understand is kepts verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n\n\n//# sourceURL=webpack:///./lib/sdpform/grammar.js?");

/***/ }),

/***/ "./lib/sdpform/index.js":
/*!******************************!*\
  !*** ./lib/sdpform/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parser = __webpack_require__(/*! ./parser */ \"./lib/sdpform/parser.js\");\nvar writer = __webpack_require__(/*! ./writer */ \"./lib/sdpform/writer.js\");\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseFmtpConfig = parser.parseFmtpConfig;\nexports.parseParams = parser.parseParams;\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n/**\n * REF: Base upon sdp-transform 2.7.0\n */\n\n//# sourceURL=webpack:///./lib/sdpform/index.js?");

/***/ }),

/***/ "./lib/sdpform/parser.js":
/*!*******************************!*\
  !*** ./lib/sdpform/parser.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./lib/sdpform/grammar.js\");\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  } else if (s.length === 1 && expr.length > 1) {\n    acc[s[0]] = undefined;\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/\\;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n\n\n//# sourceURL=webpack:///./lib/sdpform/parser.js?");

/***/ }),

/***/ "./lib/sdpform/writer.js":
/*!*******************************!*\
  !*** ./lib/sdpform/writer.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var grammar = __webpack_require__(/*! ./grammar */ \"./lib/sdpform/grammar.js\");\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n\n//# sourceURL=webpack:///./lib/sdpform/writer.js?");

/***/ }),

/***/ "./lib/stats.js":
/*!**********************!*\
  !*** ./lib/stats.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const logger = __webpack_require__(/*! ./logger */ \"./lib/logger.js\")('Stats');\nconst config = __webpack_require__(/*! ./config */ \"./lib/config.js\");\nconst pkg = __webpack_require__(/*! ../package.json */ \"./package.json\");\nconst { uuid } = __webpack_require__(/*! ./utils */ \"./lib/utils.js\")\n\nconst EventType = Object.freeze({\n\tHEART_BEAT: 'event=sdkHeartbeat',\n\tENTER_FAIL: 'event=ENTER_FAIL',\n\tENTER_TIMEOUT: 'event=ENTER_TIMEOUT'\n});\n\nconst STAT_REPORT_INTERVAL = 10 * 1000;\n\nclass Stats\n{\n\tconstructor()\n\t{\n\t\tthis._appId = '';\n\t\tthis._roomId = '';\n\t\tthis._sessionId = '';\n\t\tthis._userId = '';\n\t\tthis._connectionId = '';\n\t\tthis._roleType = '';\n\t\tthis._logType = '';\n\t\tthis._domain = '';\n\n\t\tthis._netType = '';\n\n\t\tthis._isMobile = /mobile/i.test(navigator.userAgent);\n\n\t\t// \n\t\tthis._isAudioOpen = false;\n\t\tthis._isVideoOpen = false;\n\n\t\t// 保存 webrtc internal stats -- 用于上报时集合\n\t\tthis._webrtcInternalSendStats = new Array();\n\t\tthis._webrtcInternalRecvStats = new Array();\n\n\t\tthis._reportInterval = null;\n\n\t\t// \n\t\tthis._webrtcStats = [];\n\n\t\t/*\n\t\tthis.stats = [{\n\t\t\tappId: '',\n\t\t\troomId: '',\n\t\t\tsessionId: '',\n\t\t\tuserId: '',\n\t\t\tlogtype: '1',\n\t\t\tconnectionId: '',\n\t\t\troleType: '',\n\t\t\tlogTime: '',\n\t\t\tequipInfo: {\n\t\t\t\tsdkVersion: 'ver3.7.3_Sep_28_2019',\n\t\t\t\tnetType: '0',\n\t\t\t\tequipModel: 'web',\n\t\t\t\tpublicVersion: pkg.version\n\t\t\t},\n\t\t\tvideoInfo: {\n\t\t\t\tV_SENT: [\n\t\t\t\t\t{\n\t\t\t\t\t\tDEVID: '',\n\t\t\t\t\t\tV_SSRC: 0,\n\t\t\t\t\t\tV_VBR: 0,\n\t\t\t\t\t\tV_RBR: 0,\n\t\t\t\t\t\tV_FPS: 0,\n\t\t\t\t\t\tV_SENDBYTES: 0,\n\t\t\t\t\t\tV_SENDCOUNT: 0,\n\t\t\t\t\t\tV_SENDFRACTIONLOST: 0,\n\t\t\t\t\t\tV_RTT: 0,\n\t\t\t\t\t\tV_BUF: 0,\n\t\t\t\t\t\tV_RECV: 0,\n\t\t\t\t\t\tV_ENCERROR: 0,\n\t\t\t\t\t\tV_ENC: 0,\n\t\t\t\t\t\tV_RECONNECT: 0,\n\t\t\t\t\t\tV_MUTED: 0,\n\t\t\t\t\t\tV_DYNAMICS: 0,\n\t\t\t\t\t\tV_QP: 0,\n\t\t\t\t\t\tV_SFPS: 0\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\tV_RECV: [\n\t\t\t\t\t{\n\t\t\t\t\t\tRECVUID: '',\n\t\t\t\t\t\tRECVID: '',\n\t\t\t\t\t\tSSRC: 0,\n\t\t\t\t\t\tV_FPS: 0,\n\t\t\t\t\t\tV_WIDTH: 0,\n\t\t\t\t\t\tV_HEIGHT: 0,\n\t\t\t\t\t\tV_RECVBR: 0,\n\t\t\t\t\t\tV_RECVBYTES: 0,\n\t\t\t\t\t\tV_RECVCOUNT: 0,\n\t\t\t\t\t\tV_LOSTRATE: 0,\n\t\t\t\t\t\tV_RTT: 0,\n\t\t\t\t\t\tV_JITTER: 0,\n\t\t\t\t\t\tV_RDELAY: 0,\n\t\t\t\t\t\tV_LOSTDELAY: 0,\n\t\t\t\t\t\tV_CARTON: 0,\n\t\t\t\t\t\tV_RECVFRAMECOUNT: 0,\n\t\t\t\t\t\tV_LOSTFRAMECOUNT: 0,\n\t\t\t\t\t\tV_DELAY: 0,\n\t\t\t\t\t\tV_BUF: 0,\n\t\t\t\t\t\tV_FRACTIONLOST: 0,\n\t\t\t\t\t\tV_MUTED: 0\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\taudioInfo: {\n\t\t\t\tA_SENT: {\n\t\t\t\t\tA_BR: 0,\n\t\t\t\t\tA_SSRC: 0,\n\t\t\t\t\tA_RBR: 0,\n\t\t\t\t\tA_RTT: 0,\n\t\t\t\t\tA_MUTED: 0,\n\t\t\t\t\tA_CAP: 0,\n\t\t\t\t\tA_ENC: 0,\n\t\t\t\t\tA_LOSTRATE: 0,\n\t\t\t\t\tA_RECV: 0,\n\t\t\t\t\tA_SENT: 0,\n\t\t\t\t\tA_RECONNECT: 0,\n\t\t\t\t\tA_RECVERROR: 0\n\t\t\t\t},\n\t\t\t\tA_RECV: [\n\t\t\t\t\t{\n\t\t\t\t\t\tRECVUID: '',\n\t\t\t\t\t\tA_DEVID: '',\n\t\t\t\t\t\tA_RECVBR: 0,\n\t\t\t\t\t\tA_SSRC: 0,\n\t\t\t\t\t\tA_RECVBYTES: 0,\n\t\t\t\t\t\tA_LOSTRATE: 0,\n\t\t\t\t\t\tA_BUFFERDURATION: 0,\n\t\t\t\t\t\tA_RCARTON: 0,\n\t\t\t\t\t\tA_RECVFRACTIONLOST: 0,\n\t\t\t\t\t\tA_RTT: 0,\n\t\t\t\t\t\tA_DELAY: 0,\n\t\t\t\t\t\tA_DECODELENGTH: 0,\n\t\t\t\t\t\tA_AVJMS: 0,\n\t\t\t\t\t\tA_MAXJMS: 0\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\tsystemEnvironments: {\n\t\t\t\tsysCpu: 2,\n\t\t\t\tappCpu: 1,\n\t\t\t\tsysRam: 1024,\n\t\t\t\tappRam: 1024\n\t\t\t}\n\t\t}];\n\t\t*/\n\n\t\t// key : streamId\n\t\t// value : stat infos\n\t\tthis._audioRecvStats = new Map();\n\t\tthis._videoRecvStats = new Map();\n\n\t\t// key : streamId\n\t\t// value : stat infos\n\t\tthis._audioSendStats = new Map();\n\t\tthis._videoSendStats = new Map();\n\n\t\t// \n\t\tthis._netstat = {\n\t\t\tfractionLost: 0,\n\t\t\troundTripTime: 0,\n\t\t\tquality: 0,\n\t\t\twsState: '',\n\t\t\tsendIceState: '',\n\t\t\trecvIceState: '',\n\t\t\taudioUp: {\n\t\t\t\ttimestamp: 0,\n\t\t\t\tbitrate: 0,\n\t\t\t\tpacketCount: 0,\n\t\t\t\tpacketsLost: 0,\n\t\t\t\tnackCount: 0,\n\t\t\t\tjitter: 0,\n\t\t\t\tpliCount: 0,\n\t\t\t\tsliCount: 0,\n\t\t\t\tfractionLost: 0,\n\t\t\t\troundTripTime: 0\n\t\t\t},\n\t\t\taudioDown: {\n\t\t\t\ttimestamp: 0,\n\t\t\t\tbitrate: 0,\n\t\t\t\tpacketCount: 0,\n\t\t\t\tpacketsLost: 0,\n\t\t\t\tnackCount: 0,\n\t\t\t\tpliCount: 0,\n\t\t\t\tsliCount: 0,\n\t\t\t\tfractionLost: 0,\n\t\t\t\troundTripTime: 0\n\t\t\t},\n\t\t\tvideoUp: {\n\t\t\t\ttimestamp: 0,\n\t\t\t\tbitrate: 0,\n\t\t\t\tpacketCount: 0,\n\t\t\t\tpacketsLost: 0,\n\t\t\t\tnackCount: 0,\n\t\t\t\tjitter: 0,\n\t\t\t\tpliCount: 0,\n\t\t\t\tsliCount: 0,\n\t\t\t\tfractionLost: 0,\n\t\t\t\troundTripTime: 0\n\t\t\t},\n\t\t\tvideoDown: {\n\t\t\t\ttimestamp: 0,\n\t\t\t\tbitrate: 0,\n\t\t\t\tpacketCount: 0,\n\t\t\t\tpacketsLost: 0,\n\t\t\t\tnackCount: 0,\n\t\t\t\tpliCount: 0,\n\t\t\t\tsliCount: 0,\n\t\t\t\tfractionLost: 0,\n\t\t\t\troundTripTime: 0\n\t\t\t}\n\t\t};\n\n\t\tthis._cstat = {\n\t\t\tpeerId: '',\n\t\t\tappId: '',\n\t\t\tconnectionId: '',\n\t\t\troomId: '',\n\t\t\tconsumer: '',\n\t\t\tstat: []\n\t\t}\n\n\t\tthis.streamSsrcPairs = new Map();\n\n\t\tthis.STATS_INTERVAL = 4000;\n\t\tthis.STATS_INTERVAL_S = 2000;\n\t\tthis._gwInfo = {};\n\t\tthis._iplocationInfo = {};\n\t\tthis.setNetworkType();\n\t}\n\n\tstop()\n\t{\n\t\tif (!!this._reportInterval)\n\t\t{\n\t\t\tclearInterval(this._reportInterval);\n\t\t\tthis._reportInterval = null;\n\t\t}\n\n\t\tthis._webrtcInternalSendStats.clear();\n\t\tthis._webrtcInternalRecvStats.clear();\n\t}\n\n\t// \n\tget audioUpStat()\n\t{\n\t\t// \n\t\tconst d = new Date();\n\t\tconst curTS = d.getTime();\n\n\t\tthis._audioSendStats.forEach((value, index) => {\n\t\t\tif (curTS - value.statTS > 3000) // 超过3s未更新，则失效删除\n\t\t\t{\n\t\t\t\tthis._audioSendStats.delete(index);\n\t\t\t}\n\t\t});\n\n\t\t// \n\t\treturn this._audioSendStats;\n\t}\n\n\tgetAudioUpStat(streamId)\n\t{\n\t\tif (!!this._audioSendStats)\n\t\t{\n\t\t\treturn this._audioSendStats.get(streamId);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tget videoUpStat()\n\t{\n\t\t// \n\t\tconst d = new Date();\n\t\tconst curTS = d.getTime();\n\n\t\tthis._videoSendStats.forEach((value, index) => {\n\t\t\tif (curTS - value.statTS > 3000) // 超过3s未更新，则失效删除\n\t\t\t{\n\t\t\t\tthis._videoSendStats.delete(index);\n\t\t\t}\n\t\t});\n\n\t\t// \n\t\treturn this._videoSendStats;\n\t}\n\n\tgetVideoUpStat(streamId)\n\t{\n\t\tif (!!this._videoSendStats)\n\t\t{\n\t\t\treturn this._videoSendStats.get(streamId);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tget audioDownStat()\n\t{\n\t\t// \n\t\tconst d = new Date();\n\t\tconst curTS = d.getTime();\n\n\t\tthis._audioRecvStats.forEach((value, index) => {\n\t\t\tif (curTS - value.statTS > 3000) // 超过3s未更新，则失效删除\n\t\t\t{\n\t\t\t\tthis._audioRecvStats.delete(index);\n\t\t\t}\n\t\t});\n\n\t\t// \n\t\treturn this._audioRecvStats;\n\t}\n\n\tgetAudioDownStat(streamId)\n\t{\n\t\tif (!!this._audioRecvStats)\n\t\t{\n\t\t\treturn this._audioRecvStats.get(streamId);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tget videoDownStat()\n\t{\n\t\t// \n\t\tconst d = new Date();\n\t\tconst curTS = d.getTime();\n\n\t\tthis._videoRecvStats.forEach((value, index) => {\n\t\t\tif (curTS - value.statTS > 3000) // 超过3s未更新，则失效删除\n\t\t\t{\n\t\t\t\tthis._videoRecvStats.delete(index);\n\t\t\t}\n\t\t});\n\n\t\t// \n\t\treturn this._videoRecvStats;\n\t}\n\n\tgetVideoDownStat(streamId)\n\t{\n\t\tif (!!this._videoRecvStats)\n\t\t{\n\t\t\treturn this._videoRecvStats.get(streamId);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t//\n\tget netState()\n\t{\n\t\treturn this._netstat;\n\t}\n\n\tset audioOpen(isOpen)\n\t{\n\t\tthis._isAudioOpen = isOpen;\n\t}\n\n\tset videoOpen(isOpen)\n\t{\n\t\tthis._isVideoOpen = isOpen;\n\t}\n\n\tstatic get LOGGER_SERVER_URL()\n\t{\n\t\treturn 'https://log.wushuangtech.com:15100';\n\t}\n\n\tsetStreamSSRCPairs(id, ssrc, stream, act)\n\t{\n\t\tconst item = {\n\t\t\tssrc,\n\t\t\tactive: act,\n\t\t\tstream\n\t\t};\n\t\tthis.streamSsrcPairs.set(id, item);\n\t}\n\n\tactStreamSSRCPairs(id, act)\n\t{\n\t\tconst item = this.streamSsrcPairs.get(id);\n\n\t\tif (item)\n\t\t{\n\t\t\titem.active = act;\n\t\t}\n\t}\n\n\tisActStreamSSRCPairs(id)\n\t{\n\t\tconst item = this.streamSsrcPairs.get(id);\n\n\t\tif (item)\n\t\t{\n\t\t\treturn item.active;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetStreamPropertyBySSRC(ssrc, property)\n\t{\n\t\tlet id = '';\n\t\tlet found = false;\n\t\tlet value = '';\n\n\t\tthis.streamSsrcPairs.forEach((item, key) =>\n\t\t{\n\t\t\tif (!found && item && `${item.ssrc}` === `${ssrc}`)\n\t\t\t{\n\t\t\t\tid = key;\n\t\t\t\tvalue = item.stream[property];\n\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tid,\n\t\t\tvalue\n\t\t};\n\t}\n\n\tremoveStreamById(id)\n\t{\n\t\tthis.streamSsrcPairs.delete(id);\n\t}\n\n    /**\n     * CONNECTING, OPEN, CLOSING, disconnected, CLOSED.\n     * @param {string} state \n     */\n\tsetWsState(state)\n\t{\n\t\tthis._netstat.wsState = state;\n\t}\n\n    /**\n     * new, checking, connected, completed, disconnected, failed, closed\n     * @param {string} state\n     */\n\tsetSendIceState(state)\n\t{\n\t\tthis._netstat.sendIceState = state;\n\t}\n\n    /**\n     * new, checking, connected, completed, disconnected, failed, closed\n     * @param {string} state\n     */\n\tsetRecvIceState(state)\n\t{\n\t\tthis._netstat.recvIceState = state;\n\t}\n\n\tsetAppid(appId)\n\t{\n\t\tthis._appId = appId;\n\n\t\t// this.stats[0].appId = `${appId}`;\n\t\tthis._cstat.appId = appId;\n\t}\n\n\tsetRoomId(roomId)\n\t{\n\t\tthis._roomId = roomId;\n\n\t\t// this.stats[0].roomId = `${roomId}`;\n\t\tthis._cstat.roomId = roomId;\n\t}\n\n\tsetSessionId(sessionId)\n\t{\n\t\tthis._sessionId = sessionId;\n\n\t\t// this.stats[0].sessionId = `${sessionId}`;\n\t}\n\n\tsetUserId(userId)\n\t{\n\t\tthis._userId = userId;\n\n\t\t// this.stats[0].userId = `${userId}`;\n\t\tthis._cstat.peerId = userId;\n\t}\n\n\tsetLogType(logType)\n\t{\n\t\tthis._logType = logType;\n\n\t\t// this.stats[0].logtype = `${logType}`;\n\t}\n\n\tsetConnectionId(connectionId)\n\t{\n\t\tthis._connectionId = connectionId;\n\n\t\t// this.stats[0].connectionId = `${connectionId}`;\n\t\tthis._cstat.connectionId = connectionId;\n\t}\n\n\tsetRoleType(roleType)\n\t{\n\t\tthis._roleType = `${roleType}`;\n\n\t\t// this.stats[0].roleType = `${roleType}`;\n\t}\n\n\tsetDeviceInfo(info)\n\t{\n\t\t// logger.debug({ 'clientInfo': info });\n\n\t\t// Comment this line for attend to logger server's issue.\n\t\t// this.stats[0].equipInfo.equipModel = `{'Web': ${JSON.stringify(info)}}`;\n\n\t\t// Comment this line for attend to logger server's issue. \n\t\t// this.stats[0].equipInfo.equipModel = `Web: ${info.name}-${info.version}-${info.bowser.osname}-${info.bowser.osversion}`;\n\t}\n\n\tsetDomain(domain)\n\t{\n\t\tthis._domain = domain;\n\t}\n\n\tsetGWInfo(gwInfo)\n\t{\n\t\tthis._gwInfo = gwInfo[0];\n\t}\n\n\tsetIPlocationInfo(info)\n\t{\n\t\tthis._iplocationInfo = info;\n\t}\n\n\tsetNetworkType()\n\t{\n\t\ttry\n\t\t{\n\t\t\tvar connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;\n\t\t\tswitch (connection.type)\n\t\t\t{\n\t\t\t\tcase 'wifi':\n\t\t\t\t\tthis._netType = '0';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ethernet':\n\t\t\t\t\tthis._netType = '4';\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis._netType = '4';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (e) { }\n\t}\n\n\t// \n\t// 向日志服务器上报 stat 信息 （HeartBeat）\n\t_reportWebrtcStats()\n\t{\n\t\t// \n\t\tif (!this._webrtcInternalSendStats && !this._webrtcInternalRecvStats)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tconst sendStatLen = this._webrtcInternalSendStats.length;\n\t\tconst recvStatLen = this._webrtcInternalRecvStats.length;\n\n\t\t// logger.debug(`_reportWebrtcStats -- sendStatLen: ${sendStatLen} recvStatLen: ${recvStatLen}`);\n\n\t\tconst cnt = Math.min(Math.max(sendStatLen, recvStatLen), 10);\n\t\tthis._webrtcStats = [];\n\n\t\tfor (let i = 0; i < cnt; i++)\n\t\t{\n\t\t\t// \n\t\t\tlet oStat = {};\n\n\t\t\t// \n\t\t\toStat.appId = this._appId;\n\t\t\toStat.roomId = this._roomId;\n\t\t\toStat.sessionId = this._sessionId;\n\t\t\toStat.userId = this._userId;\n\t\t\toStat.connectionId = this._connectionId;\n\t\t\t// oStat.logTime = `${Math.floor(Date.now())}`;\n\t\t\toStat.roleType = this._roleType;\n\t\t\toStat.equipInfo = {\n\t\t\t\tsdkVersion: `${pkg.version}_${pkg.buildDate}`, // 'ver3.7.3_Sep_28_2019',\n\t\t\t\tnetType: this._netType,\n\t\t\t\tequipModel: this._isMobile ? 'web_mobile' : 'web',\n\t\t\t\tinBackground: 0,\n\t\t\t\tsystemVersion: 'web',\n\t\t\t\tpublicVersion: pkg.version\n\t\t\t};\n\n\t\t\t// \n\t\t\toStat.audioInfo = {};\n\t\t\toStat.audioInfo.A_SENT = [];\n\t\t\toStat.audioInfo.A_RECV = [];\n\n\t\t\toStat.videoInfo = {};\n\t\t\toStat.videoInfo.V_SENT = [];\n\t\t\toStat.videoInfo.V_RECV = [];\n\n\t\t\t// \n\t\t\t// for recv stat\n\t\t\tconst recvStat = this._webrtcInternalRecvStats.shift();\n\n\t\t\tif (recvStat)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\toStat.logTime = recvStat.statTimeTick;\n\n\t\t\t\t// \n\t\t\t\tlet recvVideoCnt = 0;\n\t\t\t\tlet recvAudioCnt = 0;\n\n\t\t\t\t// rtt from stat\n\t\t\t\tlet rtt = 0;\n\n\t\t\t\t// \n\t\t\t\trecvStat.results.forEach(v =>\n\t\t\t\t{\n\t\t\t\t\tif (v.type === 'VideoBwe')\n\t\t\t\t\t{\n\t\t\t\t\t\t;\n\t\t\t\t\t}\n\t\t\t\t\telse if (v.type === 'googCandidatePair')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (v.googActiveConnection === 'true')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trtt = parseInt(v.googRtt, 10);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (v.type === 'ssrc')\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ssrc = parseInt(v.ssrc, 10);\n\t\t\t\t\t\tif (v.mediaType === 'audio')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\tlet { id, value } = this.getStreamPropertyBySSRC(ssrc, \"userID\");\n\n\t\t\t\t\t\t\tif (!this.isActStreamSSRCPairs(id))\n\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\tlet uid = value;\n\t\t\t\t\t\t\tif (uid === '') //\n\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt] = {};\n\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].RECVUID = uid;\n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].A_SSRC = ssrc;\n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].A_RECVBR = parseInt(!(recvStat.audio[ssrc].bytesReceived) ? 0 : recvStat.audio[ssrc].bytesReceived, 10);\n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].A_RECVBYTES = parseInt(v.bytesReceived, 10);\n\n\t\t\t\t\t\t\tvar audioLost = parseInt(!(recvStat.audio[ssrc].packetsLost) ? 0 : recvStat.audio[ssrc].packetsLost, 10);\n\t\t\t\t\t\t\tvar audioPkts = parseInt(!(recvStat.audio[ssrc].packetsReceived) ? 0 : recvStat.audio[ssrc].packetsReceived, 10);\n\t\t\t\t\t\t\tvar audioPacketsLost = audioPkts > 0 ? audioLost / audioPkts : 0;\n\n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].A_LOSTRATE = parseFloat(audioPacketsLost.toFixed(1));\n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].A_BUFFERDURATION = parseInt(v.googJitterBufferMs, 10);\n\t\t\t\t\t\t\t// oStat.audioInfo.A_RECV[recvAudioCnt].A_RCARTON = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_RECV[recvAudioCnt].A_RCARTON_DIFF = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_RECV[recvAudioCnt].A_RCARTONCOUNT = ;\n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].A_RECVFRACTIONLOST = parseFloat(audioPacketsLost.toFixed(1));\n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].A_RTT = rtt;\n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].A_DELAY = parseInt(!(recvStat.audio[ssrc].latency) ? 0 : recvStat.audio[ssrc].latency, 10);\n\t\t\t\t\t\t\t// oStat.audioInfo.A_RECV[recvAudioCnt].A_DECODELENGTH = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_RECV[recvAudioCnt].A_AVJMS = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_RECV[recvAudioCnt].A_MAXJMS = ; \n\t\t\t\t\t\t\toStat.audioInfo.A_RECV[recvAudioCnt].A_DISCARDEDPKTS = parseInt(v.packetsLost, 10);\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\trecvAudioCnt++;\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (v.mediaType === 'video')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\tlet uid = '';\n\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlet { id, value } = this.getStreamPropertyBySSRC(ssrc, \"userID\");\n\n\t\t\t\t\t\t\t\tif (!this.isActStreamSSRCPairs(id))\n\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\tuid = value;\n\n\t\t\t\t\t\t\t\tif (uid === '')\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet sid = '';\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlet { id, value } = this.getStreamPropertyBySSRC(ssrc, \"streamID\");\n\n\t\t\t\t\t\t\t\tsid = value;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt] = {};\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].RECVUID = uid;\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].RECVID = sid;\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_SSRC = ssrc;\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_RECVBR = parseInt(!(recvStat.video[ssrc].bytesReceived) ? 0 : recvStat.video[ssrc].bytesReceived, 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_FPS = parseInt(v.googFrameRateOutput, 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_WIDTH = parseInt(v.googFrameWidthReceived, 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_HEIGHT = parseInt(v.googFrameHeightReceived, 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_RECVBYTES = parseInt(v.bytesReceived, 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_RECVCOUNT = parseInt(v.packetsReceived, 10);\n\n\t\t\t\t\t\t\tvar videoLost = parseInt(!(recvStat.video[ssrc].packetsLost) ? 0 : recvStat.video[ssrc].packetsLost, 10);\n\t\t\t\t\t\t\tvar videoPkts = parseInt(!(recvStat.video[ssrc].packetsReceived) ? 0 : recvStat.video[ssrc].packetsReceived, 10);\n\t\t\t\t\t\t\tvar videoPacketsLost = videoPkts > 0 ? videoLost / videoPkts : 0;\n\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_LOSTRATE = parseFloat(videoPacketsLost.toFixed(1));\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_RTT = rtt;\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_JITTER = parseInt(v.googJitterBufferMs, 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_RECV[recvVideoCnt].V_RDELAY = parseInt(v., 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_RECV[recvVideoCnt].V_LOSTDELAY = parseInt(v., 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_RECV[recvVideoCnt].V_CARTON = parseInt(v., 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_RECVFRAMECOUNT = parseInt(v.framesDecoded, 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_RECV[recvVideoCnt].V_LOSTFRAMECOUNT = parseInt(v., 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_DELAY = parseInt(!(recvStat.video[ssrc].latency) ? 0 : recvStat.video[ssrc].latency, 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_RECV[recvVideoCnt].V_BUF = parseInt(v., 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_RECV[recvVideoCnt].V_FRACTIONLOST = parseFloat(videoPacketsLost.toFixed(1));\n\t\t\t\t\t\t\t// oStat.videoInfo.V_RECV[recvVideoCnt].V_MUTED = ;\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\trecvVideoCnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// for send stat\n\t\t\tconst sendStat = this._webrtcInternalSendStats.shift();\n\n\t\t\tif (sendStat)\n\t\t\t{\n\t\t\t\t// \n\t\t\t\toStat.logTime = sendStat.statTimeTick;\n\n\t\t\t\t// \n\t\t\t\tlet sendVideoCnt = 0;\n\t\t\t\tlet sendAudioCnt = 0;\n\n\t\t\t\t// rtt from stat\n\t\t\t\tlet rtt = 0;\n\n\t\t\t\tsendStat.results.forEach(v =>\n\t\t\t\t{\n\t\t\t\t\tif (v.type === 'VideoBwe')\n\t\t\t\t\t{\n\t\t\t\t\t\t;\n\t\t\t\t\t}\n\t\t\t\t\telse if (v.type === 'googCandidatePair')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (v.googActiveConnection === 'true')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trtt = parseInt(v.googRtt, 10);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (v.type === 'ssrc')\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ssrc = parseInt(v.ssrc, 10);\n\t\t\t\t\t\tif (v.mediaType === 'audio')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toStat.audioInfo.A_SENT[sendAudioCnt] = {};\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\toStat.audioInfo.A_SENT[sendAudioCnt].A_SSRC = ssrc;\n\t\t\t\t\t\t\toStat.audioInfo.A_SENT[sendAudioCnt].A_BR = parseInt(!(sendStat.audio[ssrc].bytesSent) ? 0 : sendStat.audio[ssrc].bytesSent, 10);\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_RBR = ;\n\t\t\t\t\t\t\toStat.audioInfo.A_SENT[sendAudioCnt].A_RTT = parseInt(v.googRtt, 10);\n\t\t\t\t\t\t\toStat.audioInfo.A_SENT[sendAudioCnt].A_MUTED = this._isAudioOpen ? 0 : 1;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_CAP = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_ENC = ;\n\n\t\t\t\t\t\t\tvar audioLost = parseInt(!(sendStat.audio[ssrc].packetsLost) ? 0 : sendStat.audio[ssrc].packetsLost, 10);\n\t\t\t\t\t\t\tvar audioPkts = parseInt(!(sendStat.audio[ssrc].packetsSent) ? 0 : sendStat.audio[ssrc].packetsSent, 10);\n\t\t\t\t\t\t\tvar audioPacketsLost = audioPkts > 0 ? audioLost / audioPkts : 0;\n\n\t\t\t\t\t\t\toStat.audioInfo.A_SENT[sendAudioCnt].A_FRACTIONLOST = parseFloat(audioPacketsLost.toFixed(1));\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_RECV = audioBytesReceivedTotal; // TODO : \n\t\t\t\t\t\t\toStat.audioInfo.A_SENT[sendAudioCnt].A_SENT = parseInt(v.bytesSent, 10);\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_RECONNECT = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_RECVERROR = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_MAXERRORUID = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_RECVERRORTIME = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_MUTEFRAME = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_MUTEALL = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_LEVELSUM = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_PRELEVELSUM = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_MIC_VOL = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_CAP_STAT = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_SPEAKING = ;\n\t\t\t\t\t\t\t// oStat.audioInfo.A_SENT[sendAudioCnt].A_BITRATE = ;\n\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\tsendAudioCnt++;\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (v.mediaType === 'video')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet sid = '';\n\n\t\t\t\t\t\t\tlet { id, value } = this.getStreamPropertyBySSRC(ssrc, \"innerStreamID\");\n\n\t\t\t\t\t\t\tif (!this.isActStreamSSRCPairs(id))\n\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\tsid = value;\n\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt] = {};\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].DEVID = sid;\n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_SSRC = ssrc;\n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_VBR = parseInt(!(sendStat.video[ssrc].bytesSent) ? 0 : sendStat.video[ssrc].bytesSent, 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_SENT[sendVideoCnt].V_RBR = ;\n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_FPS = parseInt(v.googFrameRateInput, 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_SENDBYTES = parseInt(v.bytesSent, 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_SENDCOUNT = parseInt(v.packetsSent, 10);\n\n\t\t\t\t\t\t\tvar videoLost = parseInt(!(sendStat.video[ssrc].packetsLost) ? 0 : sendStat.video[ssrc].packetsLost, 10);\n\t\t\t\t\t\t\tvar videoPkts = parseInt(!(sendStat.video[ssrc].packetsSent) ? 0 : sendStat.video[ssrc].packetsSent, 10);\n\t\t\t\t\t\t\tvar videoPacketsLost = videoPkts > 0 ? videoLost / videoPkts : 0;\n\n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_SENDFRACTIONLOST = parseFloat(videoPacketsLost.toFixed(1));\n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_RTT = parseInt(v.googRtt, 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_SENT[sendVideoCnt].V_BUF = ;\n\t\t\t\t\t\t\t// oStat.videoInfo.V_SENT[sendVideoCnt].V_RECV = videoBytesReceivedTotal; // TODO : \n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_SEND = parseInt(v.bytesSent, 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_SENT[sendVideoCnt].V_LOSS = ;\n\t\t\t\t\t\t\t// oStat.videoInfo.V_SENT[sendVideoCnt].V_ENCERROR = ;\n\t\t\t\t\t\t\t// oStat.videoInfo.V_SENT[sendVideoCnt].V_ENC = parseInt(v., 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_SENT[sendVideoCnt].V_RECONNECT = parseInt(v., 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_MUTED = this._isVideoOpen ? 0 : 1;\n\t\t\t\t\t\t\t// oStat.videoInfo.V_SENT[sendVideoCnt].V_DYNAMICS = parseInt(v., 10);\n\t\t\t\t\t\t\t// oStat.videoInfo.V_SENT[sendVideoCnt].V_QP = parseInt(v., 10);\n\t\t\t\t\t\t\toStat.videoInfo.V_SENT[sendVideoCnt].V_SFPS = parseInt(v.googFrameRateSent, 10);\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\tsendVideoCnt++;\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// \n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// \n\t\t\tthis._webrtcStats.push(oStat);\n\t\t}\n\t\t// \n\t\tif (cnt > 0)\n\t\t{\n\t\t\t//... web api send stats to log server.\n\t\t\tthis.pushLoggerToServer(EventType.HEART_BEAT, this._webrtcStats);\n\t\t}\n\n\t\tif (Math.max(sendStatLen, recvStatLen) > 10)\n\t\t{\n\t\t\tthis._reportWebrtcStats();\n\t\t}\n\t}\n\n\t// stat info 入队，用于后续定时上报 HeartBeat 信息\n\tsetWebrtcInternalSendStats(statInfo)\n\t{\n\t\t// TODO : \n\t\t/*\n\t\tstatInfo.bandwidth.rtt;\n\t\tstatInfo.bandwidth.googAvailableReceiveBandwidth;\n\t\tstatInfo.bandwidth.googAvailableSendBandwidth;\n\t\tstatInfo.connectionType.local.networkType;\n\t\t*/\n\n\t\t// \n\t\tif (!this._webrtcInternalSendStats)\n\t\t\treturn;\n\n\t\t// logger.debug(`setWebrtcInternalSendStats -- this._webrtcInternalSendStats.length: ${this._webrtcInternalSendStats.length}`);\n\n\t\tconst d = new Date();\n\t\tconst curTS = d.getTime();\n\n\t\tstatInfo.statTimeTick = curTS;\n\n\t\tthis._webrtcInternalSendStats.push(statInfo);\n\t}\n\n\t// stat info 入队，用于后续定时上报 HeartBeat 信息\n\tsetWebrtcInternalRecvStats(statInfo)\n\t{\n\t\tif (!this._webrtcInternalRecvStats)\n\t\t\treturn;\n\n\t\t// logger.debug(`setWebrtcInternalRecvStats -- this._webrtcInternalRecvStats.length: ${this._webrtcInternalRecvStats.length}`);\n\n\t\tconst d = new Date();\n\t\tconst curTS = d.getTime();\n\n\t\tstatInfo.statTimeTick = curTS;\n\n\t\tthis._webrtcInternalRecvStats.push(statInfo);\n\t}\n\n\t// stats : 从 mediasoup 得到的 consumer stat 信息\n\tsetConsumeStats(stats, resolution, peerId, consumerId, streamId)\n\t{\n\t\t// logger.debug(`<STAT> setConsumeStats streamId: ${streamId} ${JSON.stringify(stats)}`);\n\n\t\tthis._cstat.consumer = consumerId;\n\t\tthis._cstat.stat = stats;\n\n\t\t// \n\t\tconst d = new Date();\n\t\tconst curTS = d.getTime();\n\n\t\t// \n\t\tlet isVideoDownStat = false;\n\t\tlet videoDownStat = {};\n\t\tlet isAudioDownStat = false;\n\t\tlet audioDownStat = {};\n\n\t\tstats.forEach(element =>\n\t\t{\n\t\t\t// NOTE: only care outbound-rtp.\n\t\t\tif (element.type !== 'outbound-rtp')\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// this.stats[0].videoInfo.V_RECV[0].RECVUID = `${peerId}`;\n\n\t\t\tif (element.kind === 'video')\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\tthis.stats[0].videoInfo.V_RECV[0].RECVUID = `${peerId}`;\n\t\t\t\tthis.stats[0].videoInfo.V_RECV[0].RECVID = `${element.inboundRtpId}`;\n\t\t\t\tthis.stats[0].videoInfo.V_RECV[0].V_RECVBR = parseInt(element.bitrate / 1000.0, 10);\n\t\t\t\tthis.stats[0].videoInfo.V_RECV[0].V_LOSTRATE = element.fractionLost;\n\t\t\t\tthis.stats[0].videoInfo.V_RECV[0].V_RTT = parseInt(element.roundTripTime, 10);\n\t\t\t\tthis.stats[0].videoInfo.V_RECV[0].V_RECVBYTES = parseInt(element.byteCount, 10);\n\t\t\t\tthis.stats[0].videoInfo.V_RECV[0].V_RECVCOUNT = parseInt(element.packetCount, 10);\n\t\t\t\tthis.stats[0].videoInfo.V_RECV[0].V_WIDTH = parseInt(resolution.frameWidth, 10);\n\t\t\t\tthis.stats[0].videoInfo.V_RECV[0].V_HEIGHT = parseInt(resolution.frameHeight, 10);\n\t\t\t\t*/\n\n\t\t\t\tvideoDownStat.statTS = curTS; // 记录 统计时的时戳，用于失效清理（超时3s，认为失效）\n\t\t\t\tvideoDownStat.ssrc = element.ssrc;\n\n\t\t\t\tvideoDownStat.timestamp = element.timestamp;\n\t\t\t\tthis._netstat.videoDown.timestamp = element.timestamp;\n\t\t\t\tvideoDownStat.bitrate = element.bitrate;\n\t\t\t\tthis._netstat.videoDown.bitrate = element.bitrate;\n\t\t\t\tvideoDownStat.packetCount = element.packetCount;\n\t\t\t\tthis._netstat.videoDown.packetCount = element.packetCount;\n\t\t\t\tvideoDownStat.packageLost = element.packetsLost;\n\t\t\t\tthis._netstat.videoDown.packageLost = element.packetsLost;\n\t\t\t\tvideoDownStat.nackCount = element.nackCount;\n\t\t\t\tthis._netstat.videoDown.nackCount = element.nackCount;\n\t\t\t\tvideoDownStat.pliCount = element.pliCount;\n\t\t\t\tthis._netstat.videoDown.pliCount = element.pliCount;\n\t\t\t\tvideoDownStat.sliCount = element.sliCount;\n\t\t\t\tthis._netstat.videoDown.sliCount = element.sliCount;\n\t\t\t\tvideoDownStat.sliCount = element.sliCount;\n\t\t\t\tthis._netstat.videoDown.fractionLost = element.fractionLost;\n\t\t\t\tvideoDownStat.fractionLost = element.fractionLost;\n\t\t\t\tif (element.roundTripTime)\n\t\t\t\t{\n\t\t\t\t\tthis._netstat.videoDown.roundTripTime = element.roundTripTime;\n\t\t\t\t\tvideoDownStat.roundTripTime = element.roundTripTime;\n\t\t\t\t}\n\n\t\t\t\tisVideoDownStat = true;\n\t\t\t}\n\t\t\telse if (element.kind === 'audio')\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\tthis.stats[0].audioInfo.A_RECV[0].RECVUID = `${peerId}`;\n\t\t\t\tthis.stats[0].audioInfo.A_RECV[0].A_DEVID = element.inboundRtpId;\n\t\t\t\tthis.stats[0].audioInfo.A_RECV[0].A_RECVBR = parseInt(element.bitrate / 1000.0, 10);\n\t\t\t\tthis.stats[0].audioInfo.A_RECV[0].A_LOSTRATE = element.fractionLost;\n\t\t\t\tthis.stats[0].audioInfo.A_RECV[0].A_RTT = parseInt(element.roundTripTime, 10);\n\t\t\t\tthis.stats[0].audioInfo.A_RECV[0].A_RECVBYTES = parseInt(element.byteCount, 10);\n\t\t\t\tthis.stats[0].audioInfo.A_RECV[0].A_RECVCOUNT = parseInt(element.packetCount, 10);\n\t\t\t\t*/\n\n\t\t\t\taudioDownStat.statTS = curTS; // 记录 统计时的时戳，用于失效清理（超时3s，认为失效）\n\t\t\t\taudioDownStat.ssrc = element.ssrc;\n\n\t\t\t\tthis._netstat.audioDown.timestamp = element.timestamp;\n\t\t\t\taudioDownStat.timestamp = element.timestamp;\n\t\t\t\tthis._netstat.audioDown.bitrate = element.bitrate;\n\t\t\t\taudioDownStat.bitrate = element.bitrate;\n\t\t\t\tthis._netstat.audioDown.packetCount = element.packetCount;\n\t\t\t\taudioDownStat.packetCount = element.packetCount;\n\t\t\t\tthis._netstat.audioDown.packetsLost = element.packetsLost;\n\t\t\t\taudioDownStat.packetsLost = element.packetsLost;\n\t\t\t\tthis._netstat.audioDown.nackCount = element.nackCount;\n\t\t\t\taudioDownStat.nackCount = element.nackCount;\n\t\t\t\tthis._netstat.audioDown.pliCount = element.pliCount;\n\t\t\t\taudioDownStat.pliCount = element.pliCount;\n\t\t\t\tthis._netstat.audioDown.sliCount = element.sliCount;\n\t\t\t\taudioDownStat.sliCount = element.sliCount;\n\t\t\t\tthis._netstat.audioDown.fractionLost = element.fractionLost;\n\t\t\t\taudioDownStat.fractionLost = element.fractionLost;\n\t\t\t\tif (element.roundTripTime)\n\t\t\t\t{\n\t\t\t\t\tthis._netstat.audioDown.roundTripTime = element.roundTripTime;\n\t\t\t\t\taudioDownStat.roundTripTime = element.roundTripTime;\n\t\t\t\t}\n\n\t\t\t\tisAudioDownStat = true;\n\t\t\t}\n\t\t});\n\n\t\tthis._setNetQulity();\n\n\t\t// 将统计数据暂存 _audioRecvStats 中，以备上层get\n\t\tif (isAudioDownStat)\n\t\t{\n\t\t\tthis._audioRecvStats.set(streamId, audioDownStat);\n\t\t}\n\n\t\t// 将统计数据暂存 _videoRecvStats 中，以备上层get\n\t\tif (isVideoDownStat)\n\t\t{\n\t\t\tthis._videoRecvStats.set(streamId, videoDownStat);\n\t\t}\n\n\t\t/*\n\t\tthis.pushLoggerToServer(null,\n\t\t\t{\n\t\t\t\tappId: this._appId,\n\t\t\t\troomId: this.stats[0].roomId,\n\t\t\t\tuserId: this.stats[0].userId,\n\t\t\t\ttype: 'netStats',\n\t\t\t\tconsumerPeerId: peerId,\n\t\t\t\tstats: stats,\n\t\t\t\tconsumer: consumerId\n\t\t\t}\n\t\t);\n\t\t*/\n\n\t\tthis._cstat.stat.forEach(element =>\n\t\t{\n\t\t\t// received video. NOTE: only care outbound-rtp.\n\t\t\tif (element.kind === 'video' && element.type === 'outbound-rtp')\n\t\t\t{\n\t\t\t\telement.resolution = resolution;\n\t\t\t}\n\t\t})\n\n\t\tthis.consumerState(this._cstat);\n\t}\n\n\t// stats : 从 mediasoup 得到的 mic producer stat 信息\n\tsetMicStats(stats, streamId)\n\t{\n\t\t// logger.debug(`<STAT> setMicStats streamId: ${streamId} ${JSON.stringify(stats)}`);\n\n\t\tlet isAudioUpStat = false;\n\t\tlet audioUpStat = {};\n\n\t\t// \n\t\tconst d = new Date();\n\t\tconst curTS = d.getTime();\n\n\t\tstats.forEach(element =>\n\t\t{\n\t\t\t// NOTE: only care inbound-rtp.\n\t\t\tif (element.type !== 'inbound-rtp')\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tthis.stats[0].audioInfo.A_SENT.A_BR = parseInt(element.bitrate / 1000.0, 10);\n\t\t\tthis.stats[0].audioInfo.A_SENT.A_ENC = parseInt(element.packetCount, 10);\n\t\t\tthis.stats[0].audioInfo.A_SENT.A_LOSTRATE = element.packetsLost;\n\t\t\t*/\n\n\t\t\taudioUpStat.statTS = curTS; // 记录 统计时的时戳，用于失效清理（超时3s，认为失效）\n\t\t\taudioUpStat.ssrc = element.ssrc;\n\n\t\t\tthis._netstat.audioUp.timestamp = element.timestamp;\n\t\t\taudioUpStat.timestamp = element.timestamp;\n\t\t\tthis._netstat.audioUp.bitrate = element.bitrate;\n\t\t\taudioUpStat.bitrate = element.bitrate;\n\t\t\tthis._netstat.audioUp.packetCount = element.packetCount;\n\t\t\taudioUpStat.packetCount = element.packetCount;\n\t\t\tthis._netstat.audioUp.packetsLost = element.packetsLost;\n\t\t\taudioUpStat.packetsLost = element.packetsLost;\n\t\t\tthis._netstat.audioUp.nackCount = element.nackCount;\n\t\t\taudioUpStat.nackCount = element.nackCount;\n\t\t\tthis._netstat.audioUp.jitter = element.jitter;\n\t\t\taudioUpStat.jitter = element.jitter;\n\t\t\tthis._netstat.audioUp.pliCount = element.pliCount;\n\t\t\taudioUpStat.pliCount = element.pliCount;\n\t\t\tthis._netstat.audioUp.fractionLost = element.fractionLost;\n\t\t\taudioUpStat.fractionLost = element.fractionLost;\n\t\t\tif (element.roundTripTime)\n\t\t\t{\n\t\t\t\tthis._netstat.audioUp.roundTripTime = element.roundTripTime;\n\t\t\t\taudioUpStat.roundTripTime = element.roundTripTime;\n\t\t\t}\n\n\t\t\tisAudioUpStat = true;\n\t\t});\n\n\t\tthis._setNetQulity();\n\n\t\t// 将统计数据暂存 _audioSendStats 中，以备上层get\n\t\tif (isAudioUpStat)\n\t\t{\n\t\t\tthis._audioSendStats.set(streamId, audioUpStat);\n\t\t}\n\n\t\t/*\n\t\tthis.pushLoggerToServer(null,\n\t\t\t{\n\t\t\t\ttype: 'netStats',\n\t\t\t\tappId: this._appId,\n\t\t\t\troomId: this.stats[0].roomId,\n\t\t\t\tuserId: this.stats[0].userId,\n\t\t\t\tproducer: 'mic',\n\t\t\t\tstats: stats\n\t\t\t}\n\t\t);\n\t\t*/\n\t}\n\n\t// stats : 从 mediasoup 得到的 webcam producer stat 信息\n\tsetWebcamStats(stats, streamId)\n\t{\n\t\t// logger.debug(`<STAT> setWebcamStats streamId: ${streamId} ${JSON.stringify(stats)}`);\n\n\t\tlet isVideoUpStat = false;\n\t\tlet videoUpStat = {};\n\n\t\t// \n\t\tconst d = new Date();\n\t\tconst curTS = d.getTime();\n\n\t\tstats.forEach(element =>\n\t\t{\n\t\t\t// NOTE: only care inbound-rtp.\n\t\t\tif (element.type !== 'inbound-rtp')\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\tthis.stats[0].videoInfo.V_SENT[0].DEVID = `${element.id}`;\n\t\t\tthis.stats[0].videoInfo.V_SENT[0].V_VBR = parseInt(element.bitrate / 1000.0, 10);\n\t\t\tthis.stats[0].videoInfo.V_SENT[0].V_SENDCOUNT = parseInt(element.packetCount, 10);\n\t\t\tthis.stats[0].videoInfo.V_SENT[0].V_SENDFRACTIONLOST = element.packetsLost;\n\t\t\t*/\n\n\t\t\tvideoUpStat.statTS = curTS; // 记录 统计时的时戳，用于失效清理（超时3s，认为失效）\n\t\t\tvideoUpStat.ssrc = element.ssrc;\n\n\t\t\tthis._netstat.videoUp.timestamp = element.timestamp;\n\t\t\tvideoUpStat.timestamp = element.timestamp;\n\t\t\tthis._netstat.videoUp.bitrate = element.bitrate;\n\t\t\tvideoUpStat.bitrate = element.bitrate;\n\t\t\tthis._netstat.videoUp.packetCount = element.packetCount;\n\t\t\tvideoUpStat.packetCount = element.packetCount;\n\t\t\tthis._netstat.videoUp.packetsLost = element.packetsLost;\n\t\t\tvideoUpStat.packetsLost = element.packetsLost;\n\t\t\tthis._netstat.videoUp.nackCount = element.nackCount;\n\t\t\tvideoUpStat.nackCount = element.nackCount;\n\t\t\tthis._netstat.videoUp.jitter = element.jitter;\n\t\t\tvideoUpStat.jitter = element.jitter;\n\t\t\tthis._netstat.videoUp.pliCount = element.pliCount;\n\t\t\tvideoUpStat.pliCount = element.pliCount;\n\t\t\tthis._netstat.videoUp.fractionLost = element.fractionLost;\n\t\t\tvideoUpStat.fractionLost = element.fractionLost;\n\t\t\tif (element.roundTripTime)\n\t\t\t{\n\t\t\t\tthis._netstat.videoUp.roundTripTime = element.roundTripTime;\n\t\t\t\tvideoUpStat.roundTripTime = element.roundTripTime;\n\t\t\t}\n\n\t\t\tisVideoUpStat = true;\n\t\t});\n\n\t\tthis._setNetQulity();\n\n\t\t// 将统计数据暂存 _videoSendStats 中，以备上层get\n\t\tif (isVideoUpStat)\n\t\t{\n\t\t\tthis._videoSendStats.set(streamId, videoUpStat);\n\t\t}\n\n\t\t/*\n\t\tthis.pushLoggerToServer(null,\n\t\t\t{\n\t\t\t\ttype: 'netStats',\n\t\t\t\tappId: this._appId,\n\t\t\t\troomId: this.stats[0].roomId,\n\t\t\t\tuserId: this.stats[0].userId,\n\t\t\t\tproducer: 'webcam',\n\t\t\t\tstats: stats\n\t\t\t}\n\t\t);\n\t\t*/\n\t}\n\n\tstartHeartBeat()\n\t{\n\t\tif (!!this._reportInterval)\n\t\t{\n\t\t\tclearInterval(this._reportInterval);\n\t\t\tthis._reportInterval = null;\n\t\t}\n\n\t\tlogger.debug('startHeartBeat -- ');\n\t\tthis._reportInterval = setInterval(() =>\n\t\t{\n\t\t\tthis._reportWebrtcStats();\n\t\t}, STAT_REPORT_INTERVAL);\n\t}\n\n\tstopHeartBeat()\n\t{\n\t\tif (!!this._reportInterval)\n\t\t{\n\t\t\tclearInterval(this._reportInterval);\n\t\t\tthis._reportInterval = null;\n\t\t}\n\t}\n\n\tpushLoggerToServer(eventType, data)\n\t{\n\t\t// \n\t\tif (!config.log2Server)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t//... web api send data to log server.\n\t\tlet data_ = '';\n\t\tif (eventType)\n\t\t{\n\t\t\tdata_ = `${eventType} ` + JSON.stringify(data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdata_ = JSON.stringify(data);\n\t\t}\n\n\t\tfetch(Stats.LOGGER_SERVER_URL,\n\t\t\t{\n\t\t\t\tmethod: 'POST',\n\t\t\t\tmode: 'no-cors',\n\t\t\t\tcache: 'no-cache',\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/plain; charset=utf-8',\n\t\t\t\t\t// 'Content-Type': 'application/json; charset=utf-8',\n\t\t\t\t},\n\t\t\t\tredirect: 'follow',\n\t\t\t\treferrer: 'no-referrer',\n\t\t\t\tbody: data_,\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tlogger.error(`pushLoggerToServer() error - ${error.toString()}`);\n\t\t\t})\n\t\t\t.then(response => {\n\t\t\t\t; // JSON.stringify(response);\n\t\t\t});\n\t}\n\n\tconsumerState(stat)\n\t{\n\t\tif (!config.stat2Server)\n\t\t\treturn;\n\n\t\tfetch('https://' + this._domain + '/stats/',\n\t\t\t{\n\t\t\t\tmethod: 'POST',\n\t\t\t\tmode: 'no-cors',\n\t\t\t\tcache: 'no-cache',\n\t\t\t\theaders: {\n\t\t\t\t\t'Accept': 'application/json',\n\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t},\n\t\t\t\tredirect: 'follow',\n\t\t\t\treferrer: 'no-referrer',\n\t\t\t\tbody: JSON.stringify(stat)\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\tlogger.debug(`consumerState() error - ${error.toString()}`);\n\t\t\t})\n\t\t\t.then(response => {\n\t\t\t\t;// JSON.stringify(response);\n\t\t\t});\n\t}\n\n\t_setNetQulity()\n\t{\n\t\tlet fractionLost = 0;\n\t\tlet count = 0;\n\t\tlet roundTripTime = 0;\n\t\tif (this._netstat.audioUp.packetCount !== 0)\n\t\t{\n\t\t\tcount++;\n\t\t\troundTripTime + this._netstat.audioUp.roundTripTime;\n\t\t\t// fractionLost += this._netstat.audioUp.fractionLost;\n\t\t\tfractionLost += this._netstat.audioUp.packetsLost / this._netstat.audioUp.packetCount;\n\t\t}\n\n\t\tif (this._netstat.audioDown.packetCount !== 0)\n\t\t{\n\t\t\tcount++;\n\t\t\troundTripTime + this._netstat.audioDown.roundTripTime;\n\t\t\t// fractionLost += this._netstat.audioDown.fractionLost;\n\t\t\tfractionLost += this._netstat.audioDown.packetsLost / this._netstat.audioDown.packetCount;\n\t\t}\n\n\t\tif (this._netstat.videoUp.packetCount !== 0)\n\t\t{\n\t\t\tcount++;\n\t\t\troundTripTime + this._netstat.videoUp.roundTripTime;\n\t\t\t// fractionLost += this._netstat.videoUp.fractionLost;\n\t\t\tfractionLost += this._netstat.videoUp.packetsLost / this._netstat.videoUp.packetCount;\n\t\t}\n\n\t\tif (this._netstat.videoDown.packetCount !== 0)\n\t\t{\n\t\t\tcount++;\n\t\t\troundTripTime + this._netstat.videoDown.roundTripTime;\n\t\t\t// fractionLost += this._netstat.videoDown.fractionLost;\n\t\t\tfractionLost += this._netstat.videoDown.packetsLost / this._netstat.videoDown.packetCount;\n\t\t}\n\n\t\tif (count !== 0)\n\t\t{\n\t\t\troundTripTime /= count;\n\n\t\t\tthis._netstat.fractionLost = fractionLost / count;\n\t\t\tthis._netstat.roundTripTime = roundTripTime;\n\t\t\tthis._netstat.quality = 1 - this._netstat.fractionLost;\n\t\t}\n\t}\n\n\tsendTimeOutLog({ timesOfLinkGW, linkGWTime, sendGWTime, sendEnterTime })\n\t{\n\t\tlet enter_timeout = {\n\t\t\t\"glbId\": uuid(),\n\t\t\t\"appId\": this._appId,\n\t\t\t\"userId\": this._userId,\n\t\t\t\"roomId\": this._roomId,\n\t\t\t\"connectId\": this._connectionId,\n\t\t\t\"os\": \"WEB\",\n\t\t\t\"logTime\": new Date().toISOString().replace(/a-z/ig, ' '),\n\t\t\t\"timesOfLinkIplocal\": this._iplocationInfo.reconnectTimes,\n\t\t\ttimesOfLinkGW,\n\t\t\t\"linkIplocalTime\": this._iplocationInfo.connectedTime - this._iplocationInfo.firstConnectTime,\n\t\t\t\"sendIplocalTime\": this._iplocationInfo.connectedTime,\n\t\t\tlinkGWTime,\n\t\t\tsendGWTime,\n\t\t\tsendEnterTime,\n\t\t\t\"gwIp\": this._gwInfo.sIp\n\t\t}\n\t\tthis.pushLoggerToServer(EventType.ENTER_TIMEOUT, enter_timeout);\n\t}\n\n\tsendFailLog({ timesOfLinkGW, linkGWTime, sendGWTime, sendEnterTime, role, result })\n\t{\n\t\tlet event_fail = {\n\t\t\t\"glbId\": uuid(),\n\t\t\t\"appId\": this._appId,\n\t\t\t\"userId\": this._userId,\n\t\t\t\"roomId\": this._roomId,\n\t\t\t\"connectId\": this._connectionId,\n\t\t\t\"os\": \"WEB\",\n\t\t\trole,\n\t\t\tresult,\n\t\t\t\"logTime\": new Date().toISOString().replace(/a-z/ig, ' '),\n\t\t\t\"timesOfLinkIplocal\": this._iplocationInfo.reconnectTimes,\n\t\t\ttimesOfLinkGW,\n\t\t\t\"linkIplocalTime\": this._iplocationInfo.connectedTime - this._iplocationInfo.firstConnectTime,\n\t\t\t\"sendIplocalTime\": this._iplocationInfo.connectedTime,\n\t\t\tlinkGWTime,\n\t\t\tsendGWTime,\n\t\t\tsendEnterTime,\n\t\t\t\"innerDiff\": 0,\n\t\t\t\"totalDiff\": 0,\n\t\t\t\"gwIp\": this._gwInfo.sIp\n\t\t}\n\n\t\tthis.pushLoggerToServer(EventType.ENTER_FAIL, event_fail);\n\t}\n}\n\n// eslint-disable-next-line no-undef\nmodule.exports = Stats;\n\n\n//# sourceURL=webpack:///./lib/stats.js?");

/***/ }),

/***/ "./lib/stream.js":
/*!***********************!*\
  !*** ./lib/stream.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {const browser = __webpack_require__(/*! bowser */ \"./node_modules/bowser/src/bowser.js\");\nconst hark = __webpack_require__(/*! hark */ \"./node_modules/hark/hark.js\");\n\nconst config = __webpack_require__(/*! ./config */ \"./lib/config.js\");\nconst logger = __webpack_require__(/*! ./logger */ \"./lib/logger.js\")('<Stream>');\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nlet S_STREAM_MAP = new Map();\n\n// \n// navigator.mediaDevices.getSupportedConstraints();\n/**\n * Stream Object and it's functions.\n */\nclass Stream extends EventEmitter\n{\n\tconstructor(spec)\n\t{\n\t\tsuper();\n\n\t\tif (typeof spec.userID === 'undefined' || spec.userID === null)\n\t\t{\n\t\t\t// throw new TypeError('userID')\n\t\t\tspec.userID = '';\n\t\t}\n\n\t\tspec.userID = spec.userID + '';\n\t\tif (spec.userID.trim() === '')\n\t\t{\n\t\t\t// throw new TypeError('userID is empty')\n\t\t\tspec.userID = '';\n\t\t}\n\n\t\tif (typeof spec.streamID === 'undefined' || spec.streamID === null)\n\t\t{\n\t\t\tspec.streamID = spec.userID;\n\t\t}\n\n\t\tspec.streamID = spec.streamID + '';\n\t\tif (spec.streamID.trim() === '')\n\t\t{\n\t\t\tspec.streamID = spec.userID;\n\t\t}\n\n\t\t// The specific configure of stream.\n\t\t// {\n\t\t//   streamID: '',\n\t\t//   userID: '',\n\t\t//   audio: @type {Boolean},\n\t\t//   video: @type {Boolean},\n\t\t//   screen: @type {Boolean},\n\t\t//   attributes: {\n\t\t//      // resolution was obsolated.\n\t\t//      resolution: 'sif'|'vga'|'hd720p' | { width: @type{number}, height: @type{number} }\n\t\t//      videoProfile: @type {string},\n\t\t//      // Ref: config.js: videoProfile.\n\t\t//      // NOTE: the 'width and height' can concurrent with 'sif|vga|hd720p' setting, but the prority more height of 'width and height'. \n\t\t//      minFrameRate: @type {number},\n\t\t//      maxFrameRate: @type {number},\n\t\t//      idealFrameRate: @type {number} (NOTE: option)\n\t\t//   },\n\t\t//   codecOptions: {\n\t\t//      startBitrate: @type {number},\n\t\t//      maxBitrate: @{number},\n\t\t//      minBitrate: @type {number}\n\t\t//   },\n\t\t//   // NOTE: Unit is bits.\n\t\t//   subStream: true | false\n\t\t// }\n\t\tthis._spec = spec;\n\n\t\tlogger.debug(`constructor() -- spec: ${JSON.stringify(spec)}`);\n\n\t\t// 原始 stream\n\t\tthis._streamObjOrigin = null;\n\t\t// The webrtc stream object.\n\t\tthis._streamObj = null;\n\n\t\t// stream 类型：producer、consumer\n\t\tthis._streamType = '';\n\t\tif (!!spec.streamType)\n\t\t{\n\t\t\tthis._streamType = spec.streamType;\n\t\t}\n\n\t\t//\n\t\tthis._innerStreamID = '';\n\t\t// TODO : use spec.streamID; // 注：当来自远端的 stream 时，以远端 streamID 为 streamID\n\n\t\t// stream identify by consumter layer.\n\t\tthis._customStreamID = spec.streamID;\n\n\t\t// peer idnetify indicate which peer belong to.\n\t\tthis._userId = spec.userID;\n\n\t\t// the audio volume.\n\t\tthis._volume = 0.0;\n\n\t\t// is local stream?\n\t\tthis._isLocalStream = false;\n\n\t\t// \n\t\tthis._audioSource = null;\n\t\tif (!!spec.audioSource)\n\t\t{\n\t\t\tthis._audioSource = spec.audioSource;\n\t\t}\n\t\t\n\t\tthis._videoSource = null;\n\t\tif (!!spec.videoSource)\n\t\t{\n\t\t\tthis._videoSource = spec.videoSource;\n\t\t}\n\n\t\t// specifiy source for producer source.\n\t\tthis._source = spec.source;\n\n\t\t// is this stream subscribed.\n\t\tthis._subscribed = false;\n\n\t\t// is closed\n\t\tthis._closed = false;\n\n\t\t// is sub-stream\n\t\tthis._isSubStream = !spec.subStream ? false : spec.subStream;\n\n\t\t// the resulotion of the 4:3 scales\n\t\tthis._keyResolution = 480;\n\n\t\t// is mobile device\n\t\tthis._isMobile = /mobile/i.test(navigator.userAgent);\n\n\t\t// is this stream published.\n\t\tthis._published = false;\n\n\t\t// video: 0,screen: 1, file: 2, videoMixer: 3, camera: 4\n\t\tthis._videoType = spec.videoType || spec.screen ? 1 : 0;\n\n\t\t// 如果再 未publish 状态下 replayceTrack，则 _needUpdateTrack 为 true，待 该路流 publish 时，执行 updateTrack\n\t\tthis._needUpdateTrack = false; // for replaceTrack\n\n\t\t// webAudio 上下文，操作音频的接口\n\t\tthis._audioCtx = null;\n\n\t\tif (!!spec.openAudioCtx)\n\t\t{\n\t\t\tsetTimeout(() =>\n\t\t\t{\n\t\t\t\tthis.createAudioContext();\n\t\t\t}, 100); // 2s 后再创建，以便发生异常，导致 audioSource 无声音\n\t\t}\n\n\t\t// \n\t\tthis._specialCameraId = '';\n\t\tthis._specialMicId = '';\n\n\t\t// 音频 profile -- 取值自 config.audioProfileSpec\n\t\tthis._audioProfile = null;\n\t}\n\n    /**\n     * Initialize stream for camera(with mic) or screen(with mic).\n     * \n     * @public\n     * @param onSuccess\n     * @param onFailure\n     */\n\tasync init(onSuccess, onFailure)\n\t{\n\t\tlogger.debug(`API init() -- this._userId: ${this._userId} this._spec: ${JSON.stringify(this._spec)}`);\n\n\t\t// TODO : 设备拔插\n\t\tnavigator.mediaDevices.ondevicechange = (e) => {\n\t\t\tlogger.debug('mediaDevices.ondevicechange - ' + e);\n\t\t}\n\n\t\t// \n\t\tthis._streamType = 'producer';\n\n\t\t// constrainable properties comes from this.spec variable.\n\t\tlet constraints = null;\n\n\t\tif (this._spec.video || this._spec.screen)\n\t\t{\n\t\t\tthis._enableVideoTrack = true;\n\t\t}\n\n\t\tlet videoSpec = {\n\t\t\twidth: {\n\t\t\t\tmin: config.videoSpec.width.min,\n\t\t\t\tideal: config.videoSpec.width.ideal,\n\t\t\t\tmax: config.videoSpec.width.max\n\t\t\t},\n\t\t\theight: {\n\t\t\t\tmin: config.videoSpec.height.min,\n\t\t\t\tideal: config.videoSpec.height.ideal,\n\t\t\t\tmax: config.videoSpec.height.max\n\t\t\t},\n\t\t\tframeRate: {\n\t\t\t\tmin: config.videoSpec.frameRate.min,\n\t\t\t\tideal: config.videoSpec.frameRate.ideal,\n\t\t\t\tmax: config.videoSpec.frameRate.max\n\t\t\t},\n\t\t};\n\n\t\tif (this._isMobile)\n\t\t{\n\t\t\tvideoSpec.facingMode = this._spec.useBackCam ? { exact: 'environment' } : 'user';\n\t\t}\n\t\tif (this._spec.attributes)\n\t\t{\n\t\t\t// Obsolate the attribute.resolution field.\n\t\t\t// But Keep the attribute.resolution field for compatible less than 3.2.0 version's SDK.\n\t\t\tif (this._spec.attributes.resolution)\n\t\t\t{\n\t\t\t\tif (this._spec.attributes.resolution.toUpperCase() === 'HD720P')\n\t\t\t\t{\n\t\t\t\t\tvideoSpec.width.ideal = config.videoAttributes.hd720p[0];\n\t\t\t\t\tvideoSpec.height.ideal = config.videoAttributes.hd720p[1];\n\t\t\t\t}\n\n\t\t\t\tif (this._spec.attributes.resolution.toUpperCase() === 'VGA')\n\t\t\t\t{\n\t\t\t\t\tvideoSpec.width.ideal = config.videoAttributes.vga[0];\n\t\t\t\t\tvideoSpec.height.ideal = config.videoAttributes.vga[1];\n\t\t\t\t}\n\n\t\t\t\tif (this._spec.attributes.resolution.toUpperCase() === 'SIF')\n\t\t\t\t{\n\t\t\t\t\tvideoSpec.width.ideal = config.videoAttributes.sif[0];\n\t\t\t\t\tvideoSpec.height.ideal = config.videoAttributes.sif[1];\n\t\t\t\t}\n\n\t\t\t\tif (typeof this._spec.attributes.width !== 'undefined' &&\n\t\t\t\t\ttypeof this._spec.attributes.height !== 'undefined')\n\t\t\t\t{\n\t\t\t\t\tvideoSpec.width.ideal = this._spec.attributes.width;\n\t\t\t\t\tvideoSpec.height.ideal = this._spec.attributes.height;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._spec.attributes.minFrameRate && this._spec.attributes.maxFrameRate)\n\t\t\t{\n\t\t\t\tvideoSpec.frameRate.min = this._spec.attributes.minFrameRate;\n\t\t\t\tvideoSpec.frameRate.max = this._spec.attributes.maxFrameRate;\n\t\t\t\tif (typeof this._spec.attributes.idealFrameRate !== 'undefined')\n\t\t\t\t{\n\t\t\t\t\tvideoSpec.frameRate.ideal = this._spec.attributes.idealFrameRate;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvideoSpec.frameRate.ideal = Math.floor((this._spec.attributes.maxFrameRate - this._spec.attributes.minFrameRate) / 2 + this._spec.attributes.minFrameRate);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// leaveage the videoProfile filed from the 3.2.0 version.\n\t\t\tif (this._spec.attributes.videoProfile)\n\t\t\t{\n\t\t\t\tlet resolution = this._getResolutionByVideoProfile(this._spec.attributes.videoProfile);\n\t\t\t\tvideoSpec.width.ideal = resolution.width;\n\t\t\t\tvideoSpec.height.ideal = resolution.height;\n\t\t\t}\n\t\t}\n\n\t\t// Determine the audio | video | screen stream constrains.\n\t\tif (this._spec.video && this._spec.audio)\n\t\t{ /**has video and audio */\n\t\t\tconstraints = {\n\t\t\t\tvideo: videoSpec\n\t\t\t};\n\n\t\t\tif (this._spec.microphoneId)\n\t\t\t{\n\t\t\t\tlet deviceId = this._spec.microphoneId ? { exact: this._spec.microphoneId } : undefined\n\t\t\t\tconstraints.audio = {\n\t\t\t\t\tdeviceId,\n\t\t\t\t\tsampleRate: config.audioSpec.sampleRate,\n\t\t\t\t\tchannelCount: config.audioSpec.channelCount\n\t\t\t\t}\n\t\t\t\t// 记录设备ID\n\t\t\t\tthis._specialMicId = deviceId;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconstraints.audio = {\n\t\t\t\t\taudio: true\n\t\t\t\t\t// sampleRate: config.audioSpec.sampleRate,    // for compatibility\n\t\t\t\t\t// channelCount: config.audioSpec.channelCount // for compatibility\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._spec.cameraId)\n\t\t\t{\n\t\t\t\tconstraints.video.deviceId = this._spec.cameraId ? { exact: this._spec.cameraId } : undefined;\n\t\t\t\t// 记录 deviceId\n\t\t\t\tthis._specialCameraId = constraints.video.deviceId;\n\t\t\t}\n\t\t}\n\t\telse if (this._spec.audio && !this._spec.screen && !this._spec.video)\n\t\t{ /** only has audio*/\n\t\t\tconstraints = {\n\t\t\t\tvideo: false\n\t\t\t};\n\n\t\t\tif (this._spec.microphoneId)\n\t\t\t{\n\t\t\t\tlet deviceId = this._spec.microphoneId ? { exact: this._spec.microphoneId } : undefined;\n\t\t\t\tconstraints.audio = { deviceId };\n\t\t\t\t// 记录设备ID\n\t\t\t\tthis._specialMicId = deviceId;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tconstraints.audio = {\n\t\t\t\t\taudio: true\n\t\t\t\t\t// sampleRate: config.audioSpec.sampleRate,    // compatibility\n\t\t\t\t\t// channelCount: config.audioSpec.channelCount // compatibility\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (this._spec.video && !this._spec.audio && !this._spec.screen)\n\t\t{ /** only has video */\n\t\t\tconstraints = {\n\t\t\t\taudio: false,\n\t\t\t\tvideo: videoSpec\n\t\t\t};\n\n\t\t\tif (this._spec.cameraId)\n\t\t\t{\n\t\t\t\tconstraints.video.deviceId = this._spec.cameraId ? { exact: this._spec.cameraId } : undefined;\n\t\t\t\t// 记录 deviceId\n\t\t\t\tthis._specialCameraId = constraints.video.deviceId;\n\t\t\t}\n\t\t}\n\t\telse if (this._spec.screen && this._spec.video)\n\t\t{ /** has video and screen */\n\t\t\tlogger.warn('API init() error - cannot set screen and video simultaneously with true. the video property more high than screen then will ignore the screen setting.')\n\t\t}\n\t\telse if (this._spec.screen)\n\t\t{ /** has screen */\n\t\t\tlet latest_chrome = false;\n\t\t\tif (browser.name.toLowerCase() === 'chrome')\n\t\t\t{\n\t\t\t\tif (parseInt(browser.version, 10) >= 72)\n\t\t\t\t{\n\t\t\t\t\tlatest_chrome = true;\n\t\t\t\t\tawait this._startScreenCapture()\n\t\t\t\t\t\t.then(async s =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis._isLocalStream = true;\n\n\t\t\t\t\t\t\t// \n\t\t\t\t\t\t\tthis._streamObjOrigin = s;\n\t\t\t\t\t\t\tthis.streamObj = s;\n\t\t\t\t\t\t\tthis._screenStreamEnded(s);\n\n\t\t\t\t\t\t\tthis._innerStreamID = Stream._getInnerStreamID(this.userID, this.userID, 0, this, this._isSubStream);\n\t\t\t\t\t\t\t// if screen simultaneously go with audio track.\n\t\t\t\t\t\t\tif (this._spec.audio)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlet audio = await this.audioStream();\n\t\t\t\t\t\t\t\t\tlet track = audio.getAudioTracks()[0];\n\t\t\t\t\t\t\t\t\tthis.audioTracks = track;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch (error)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlogger.error(`API init() error - stream of screen init failed for obtain audio track. error: ${JSON.stringify(error)}`);\n\t\t\t\t\t\t\t\t\tonFailure(error);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlogger.debug(`API init() _startScreenCapture() success - this.userID: ${this.userID} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\t\t\t\t\t\tonSuccess();\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogger.error(`API init() error - screen capture error. error: ${JSON.stringify(err)}`);\n\t\t\t\t\t\t\treturn onFailure(err);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!latest_chrome)\n\t\t\t{\n\t\t\t\tgetScreenId((error, sourceId, screen_constraints) =>\n\t\t\t\t{\n\t\t\t\t\t// error    == null || 'permission-denied' || 'not-installed' || 'installed-disabled' || 'not-chrome'\n\t\t\t\t\t// sourceId == null || 'string' || 'firefox'\n\n\t\t\t\t\tif (sourceId !== 'firefox')\n\t\t\t\t\t{\n\t\t\t\t\t\tscreen_constraints = {\n\t\t\t\t\t\t\tvideo: {\n\t\t\t\t\t\t\t\tmandatory: {\n\t\t\t\t\t\t\t\t\tchromeMediaSource: 'screen',\n\t\t\t\t\t\t\t\t\tmaxWidth: 1920,\n\t\t\t\t\t\t\t\t\tmaxHeight: 1080,\n\t\t\t\t\t\t\t\t\tminAspectRatio: 1.77\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (error === 'permission-denied')\n\t\t\t\t\t\t\treturn alert('Permission is denied.');\n\t\t\t\t\t\tif (error === 'not-chrome')\n\t\t\t\t\t\t\treturn alert('Please use chrome.');\n\n\t\t\t\t\t\tif (!error && sourceId)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tscreen_constraints.video.mandatory.chromeMediaSource = 'desktop';\n\t\t\t\t\t\t\tscreen_constraints.video.mandatory.chromeMediaSourceId = sourceId;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnavigator.getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia;\n\t\t\t\t\tnavigator.getUserMedia(screen_constraints, async stream =>\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._isLocalStream = true;\n\n\t\t\t\t\t\tthis._streamObjOrigin = stream;\n\t\t\t\t\t\tthis.streamObj = stream;\n\t\t\t\t\t\tthis._innerStreamID = Stream._getInnerStreamID(this.userID, this.userID, 0, this, this._isSubStream);\n\t\t\t\t\t\t// if screen simultaneously go with audio track.\n\t\t\t\t\t\tif (this._spec.audio)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlet audio = await this.audioStream(),\n\t\t\t\t\t\t\t\t\ttrack = audio.getAudioTracks()[0];\n\t\t\t\t\t\t\t\tthis.audioTracks = track;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (error)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlogger.error(`API init() getScreenId() error - stream of screen init failed for obtain audio track. error: ${error.toString()}`);\n\t\t\t\t\t\t\t\tonFailure(error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlogger.debug(`API init() getScreenId() success - this.userID: ${this.userID} this._innerStreamID: ${this._innerStreamID} screen_constraints: ${JSON.stringify(screen_constraints)}`);\n\n\t\t\t\t\t\tonSuccess();\n\t\t\t\t\t\t// share this 'MediaStream' object using RTCPeerConnection API\n\t\t\t\t\t}, (error) =>\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.error(`API init() getScreenId() error: ${JSON.stringify(error)}`);\n\t\t\t\t\t\tonFailure(error);\n\t\t\t\t\t});\n\t\t\t\t}, this._spec.audio);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._spec.video || this._spec.audio)\n\t\t{\n\t\t\tnavigator.mediaDevices.getUserMedia(constraints)\n\t\t\t\t.then(stream =>\n\t\t\t\t{\n\t\t\t\t\tthis._isLocalStream = true;\n\n\t\t\t\t\tthis._streamObjOrigin = stream;\n\n\t\t\t\t\tlet videoTracks = stream.getVideoTracks();\n\t\t\t\t\tlet audioTracks = stream.getAudioTracks();\n\t\t\t\t\tif (audioTracks.length > 0 && !!this._audioCtx)\n\t\t\t\t\t{\n\t\t\t\t\t\t// 音量调节节点\n\t\t\t\t\t\tthis._gainNode = this._audioCtx.createGain();\n\t\t\t\t\t\tlet source = this._audioCtx.createMediaStreamSource(stream);\n\t\t\t\t\t\tthis.target = this._audioCtx.createMediaStreamDestination();\n\t\t\t\t\t\tsource.connect(this._gainNode);\n\t\t\t\t\t\tthis._gainNode.connect(this.target);\n\t\t\t\t\t\tif (videoTracks.length)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.target.stream.addTrack(videoTracks[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.streamObj = this.target.stream;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.streamObj = stream;\n\t\t\t\t\t}\n\n\t\t\t\t\t// the inner stream id.\n\t\t\t\t\tthis._innerStreamID = Stream._getInnerStreamID(this.userID, this.userID, 0, this, this._isSubStream);\n\t\t\t\t\tlogger.debug(`API init() getUserMedia() success - this.userID: ${this.userID} this._innerStreamID: ${this._innerStreamID} constraints: ${JSON.stringify(constraints)}`);\n\n\t\t\t\t\tonSuccess();\n\t\t\t\t})\n\t\t\t\t.catch((err) =>\n\t\t\t\t{\n\t\t\t\t\tlogger.error(`API init() getUserMedia() error - ${err.toString()}`);\n\t\t\t\t\tonFailure(err);\n\t\t\t\t});\n\t\t}\n\t\telse if (this._spec.mediasource)\n\t\t{\n\t\t\tconst constraints = {\n\t\t\t\taudio: true,\n\t\t\t\tvideo: false\n\t\t\t};\n\n\t\t\tnavigator.mediaDevices.getUserMedia(constraints)\n\t\t\t\t.then((stream) => {\n\t\t\t\t\tlet videoTracks = stream.getVideoTracks();\n\t\t\t\t\tlet audioTracks = stream.getAudioTracks();\n\n\t\t\t\t\tlet oldTrack = null;\n\t\t\t\t\tif (audioTracks.length > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\toldTrack = audioTracks[0];\n\t\t\t\t\t\tstream.removeTrack(oldTrack);\n\t\t\t\t\t}\n\t\t\t\t\t// \n\t\t\t\t\tif (!!this._audioSource)\n\t\t\t\t\t{\n\t\t\t\t\t\tstream.addTrack(this._audioSource);\n\t\t\t\t\t}\n\t\t\t\t\tif (!!this._videoSource)\n\t\t\t\t\t{\n\t\t\t\t\t\tstream.addTrack(this._videoSource);\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.streamObj = stream;\n\n\t\t\t\t\t// the inner stream id.\n\t\t\t\t\tthis._innerStreamID = Stream._getInnerStreamID(this.userID, this.userID, 0, this, this._isSubStream);\n\t\t\t\t\tlogger.debug(`API init() getUserMedia() success - this.userID: ${this.userID} this._innerStreamID: ${this._innerStreamID} constraints: ${JSON.stringify(constraints)}`);\n\n\t\t\t\t\tonSuccess();\n\t\t\t\t})\n\t\t\t\t.catch((e) => {\n\t\t\t\t\tlogger.error(`API init() getUserMedia() error - ${e.toString()}`);\n\t\t\t\t\tonFailure(e);\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * \n\t */\n\tcreateAudioContext()\n\t{\n\t\tif (!!this._audioCtx)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlet audioContext = window.AudioContext || window.webkitAudioContext;\n\t\tthis._audioCtx = new audioContext();\n\n\t\t// \n\t\tif (!!this._streamObjOrigin)\n\t\t{\n\t\t\tlet videoTracks = this._streamObjOrigin.getVideoTracks();\n\t\t\tlet audioTracks = this._streamObjOrigin.getAudioTracks();\n\t\t\tif (audioTracks.length > 0 && !!this._audioCtx)\n\t\t\t{\n\t\t\t\t// 音量调节节点\n\t\t\t\tthis._gainNode = this._audioCtx.createGain();\n\t\t\t\tlet source = this._audioCtx.createMediaStreamSource(this._streamObjOrigin);\n\t\t\t\tthis.target = this._audioCtx.createMediaStreamDestination();\n\t\t\t\tsource.connect(this._gainNode);\n\t\t\t\tthis._gainNode.connect(this.target);\n\t\t\t\tif (videoTracks.length)\n\t\t\t\t{\n\t\t\t\t\tthis.target.stream.addTrack(videoTracks[0]);\n\t\t\t\t}\n\t\t\t\tthis.streamObj = this.target.stream;\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug('API createAudioContext() success');\n\t}\n\n    /**\n     * Only obtain audio stream.\n     * \n     * @private\n     */\n\taudioStream()\n\t{\n\t\tlogger.debug(`API audioStream() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\t// only obtain audio stream.\n\t\tlet constraints = {\n\t\t\taudio: true\n\t\t}\n\n\t\t// mandatory microphone device.\n\t\tif (this._spec.microphoneId)\n\t\t{\n\t\t\tif (this._spec.microphoneId.trim() !== '')\n\t\t\t{\n\t\t\t\tconstraints.deviceId = this._spec.microphoneId;\n\t\t\t\t// 记录设备ID\n\t\t\t\tthis._specialMicId = constraints.deviceId;\n\t\t\t}\n\t\t}\n\n\t\tnavigator.getUserMedia = navigator.mozGetUserMedia || navigator.webkitGetUserMedia;\n\t\treturn new Promise((resovle, reject) =>\n\t\t{\n\t\t\tnavigator.mediaDevices.getUserMedia(constraints)\n\t\t\t\t.then(stream =>\n\t\t\t\t{\n\t\t\t\t\tif (!!this._audioCtx)\n\t\t\t\t\t{\n\t\t\t\t\t\t// 音量调节节点\n\t\t\t\t\t\tthis._gainNode = this._audioCtx.createGain();\n\t\t\t\t\t\tlet source = this._audioCtx.createMediaStreamSource(stream);\n\t\t\t\t\t\tthis.target = this._audioCtx.createMediaStreamDestination();\n\t\t\t\t\t\tsource.connect(this._gainNode);\n\t\t\t\t\t\tthis._gainNode.connect(this.target);\n\t\t\t\t\t\tresovle(this.target.stream);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tresovle(stream);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.catch(error =>\n\t\t\t\t{\n\t\t\t\t\treject(error);\n\t\t\t\t})\n\t\t})\n\t}\n\n    /**\n     * Get the inner stream identity.\n     * \n     * @private\n     * @param {string} userID \n     * @param {string} streamID \n     * @param {string} number \n     * @param {Any} stream \n     * @param {Boolean} isSubStream \n     */\n\tstatic _getInnerStreamID(userID, streamID, number, stream, isSubStream = false)\n\t{\n\t\tif (userID === '')\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\tlet s = S_STREAM_MAP.get(streamID);\n\t\tif (typeof s === 'undefined')\n\t\t{\n\t\t\tS_STREAM_MAP.set(streamID, stream);\n\t\t\treturn streamID;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (isSubStream)\n\t\t\t{\n\t\t\t\t// The formation is contract with other Entpoints version's SDK.\n\t\t\t\tif (number === 0)\n\t\t\t\t{\n\t\t\t\t\treturn Stream._getInnerStreamID(userID, `${userID}:${userID}_low`, number + 1, stream);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn Stream._getInnerStreamID(userID, `${userID}:${userID}_${number}_low`, number + 1, stream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Stream._getInnerStreamID(userID, `${userID}:${userID}_${number + 1}`, number + 1, stream);\n\t\t}\n\t}\n\n    /**\n     * @private\n     */\n\tset streamObj(streamObj)\n\t{\n\t\tthis._streamObj = streamObj;\n\t\tif (!streamObj)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// Obtain some setting of tracks if is local stream.\n\t\tif (this._isLocalStream)\n\t\t{\n\t\t\tlet tracks = this.videoTracks;\n\t\t\tif (tracks.length > 0)\n\t\t\t{\n\t\t\t\tlet videoTrack = tracks[0];\n\t\t\t\tthis._videoSetting = videoTrack.getSettings();\n\t\t\t\tthis._setKeyResolution(videoTrack);\n\t\t\t}\n\n\t\t\ttracks = this.audioTracks;\n\t\t\tif (tracks.length > 0)\n\t\t\t{\n\t\t\t\tlet audioTrack = tracks[0];\n\t\t\t\tthis._audioSetting = audioTrack.getSettings();\n\t\t\t}\n\t\t}\n\n\t\t// hark can be created only have audio tracks.\n\t\tif (streamObj.getAudioTracks().length > 0)\n\t\t{\n\t\t\tthis._speechEvents(streamObj);\n\t\t}\n\t}\n\n    /**\n     * @private\n     * \n     * @param {Any} stream \n     */\n\t_speechEvents(stream)\n\t{\n\t\tthis._speach = new hark(stream, {});\n\t\tlet that = this;\n\t\tthis._speach.on('volume_change', (volume, threshold) =>\n\t\t{\n\t\t\tif (volume < threshold)\n\t\t\t\treturn;\n\t\t\tthat._volume = Math.round((volume - threshold) * (-10) / threshold);\n\t\t\tthis.emit('volume-change', { userID: this.userID, volume: that._volume });\n\t\t});\n\n\t\tthis._speach.on('speaking', () =>\n\t\t{\n\t\t\tthis.emit('speaking', { userID: this.userID });\n\t\t});\n\n\t\tthis._speach.on('stopped_speaking', () =>\n\t\t{\n\t\t\tthat._volume = 0;\n\t\t\t// \n\t\t\tthis.emit('stopped-speaking', { userID: this.userID });\n\t\t});\n\t}\n\n    /**\n     * Get stream object property\n     * \n     * @private\n     */\n\tget streamObj()\n\t{\n\t\treturn this._streamObj;\n\t}\n\n\tget streamType()\n\t{\n\t\treturn this._streamType;\n\t}\n\n\tget specialCameraId()\n\t{\n\t\treturn this._specialCameraId;\n\t}\n\n\tget specialMicId()\n\t{\n\t\treturn this._specialMicId;\n\t}\n\n    /**\n     * Set stream identity property.\n     * \n     * @private\n     */\n\tset streamID(id)\n\t{\n\t\tthis._customStreamID = id;\n\t}\n\n    /**\n     * Get stream identity property.\n     * \n     * @private\n     * \n     * stream id is unique identity of stream.\n     */\n\tget streamID()\n\t{\n\t\treturn this._customStreamID;\n\t}\n\n    /**\n     * Set user identity property.\n     * \n     * @private\n     */\n\tset userID(id)\n\t{\n\t\tthis._userId = id;\n\t}\n\n    /**\n     * Get user identity property.\n     * @private\n     * \n     * user id represent witch belong to peer(user). \n     */\n\tget userID()\n\t{\n\t\treturn this._userId;\n\t}\n\n    /**\n     * Get inner stream identity property.\n     * \n     * @private\n     */\n\tget innerStreamID()\n\t{\n\t\tif (this._innerStreamID === '')\n\t\t{\n\t\t\tthis._innerStreamID = Stream._getInnerStreamID(this._userId, this.streamID, 0, this, this._isSubStream);\n\t\t}\n\n\t\treturn this._innerStreamID;\n\t}\n\n    /**\n     * Set audio tracks property.\n     * \n     * @private\n     */\n\tset audioTracks(track)\n\t{\n\t\tlogger.debug(`API audioTracks() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\tif (!track)\n\t\t{\n\t\t\tlogger.error('API audioTracks() error - parameter track is NULL');\n\t\t\treturn new TypeError('track');\n\t\t}\n\n\t\tif (track.kind !== 'audio')\n\t\t{\n\t\t\tlogger.error('API audioTracks() error - parameter track.kind is node audio');\n\t\t\treturn new TypeError('track is not audio kind');\n\t\t}\n\n\t\t// TODO : remove old track\n\t\t// \n\t\tif (this._streamObjOrigin != null)\n\t\t{\n\t\t\tthis._streamObjOrigin.addTrack(track);\n\t\t}\n\t\tif (this._streamObj !== null)\n\t\t{\n\t\t\tthis._streamObj.addTrack(track);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger.error('API audioTracks() error - this._streamObj is NULL');\n\t\t\tthrow new Error('stream object is null.');\n\t\t}\n\n\t\tif (!!this._video)\n\t\t{\n\t\t\tthis._video.srcObject = this._streamObj;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// logger.error('API audioTracks() error - this._video is NULL');\n\t\t}\n\n\t\tthis._speechEvents(this._streamObj);\n\t}\n\n    /**\n     * Set video tracks property.\n     * \n     * @private\n     */\n\tset videoTracks(track)\n\t{\n\t\tlogger.debug(`API videoTracks() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\tif (!track)\n\t\t{\n\t\t\tlogger.error('API videoTracks() error - parameter track is NULL');\n\t\t\treturn new TypeError('track');\n\t\t}\n\n\t\tif (track.kind !== 'video')\n\t\t{\n\t\t\tlogger.error('API videoTracks() error - parameter track.kind is node video');\n\t\t\treturn new TypeError('track is not video kind');\n\t\t}\n\n\t\t// TODO : remove old track\n\t\t// \n\t\tif (this._streamObjOrigin != null)\n\t\t{\n\t\t\tthis._streamObjOrigin.addTrack(track);\n\t\t}\n\n\t\tif (this._streamObj !== null)\n\t\t{\n\t\t\tthis._streamObj.addTrack(track);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger.error('API videoTracks() error - this._streamObj is NULL');\n\t\t\tthrow new Error('stream object is null.');\n\t\t}\n\n\t\tif (!!this._video)\n\t\t{\n\t\t\tthis._video.srcObject = this._streamObj;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// logger.error('API audioTracks() error - this._video is NULL');\n\t\t}\n\t}\n\n    /**\n     * Get audio tracks property.\n     * \n     * @private\n     */\n\tget audioTracks()\n\t{\n\t\tif (!this._streamObj)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._streamObj.getAudioTracks();\n\t}\n\n    /**\n     * Get video tracks property.\n     * \n     * @private\n     */\n\tget videoTracks()\n\t{\n\t\tif (!this._streamObj)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this._streamObj.getVideoTracks();\n\t}\n\n    /**\n     * Get tracks property.\n     * \n     * @private\n     */\n\tget tracks()\n\t{\n\t\treturn this._streamObj.getTracks();\n\t}\n\n    /**\n     * Get track's number property.\n     * \n     * @private\n     */\n\tget trackNumber()\n\t{\n\t\tif (!this._streamObj)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this._streamObj.getTracks().length;\n\t}\n\n    /**\n     * Set subscribed property.\n     * \n     * @public\n     */\n\tset subscribed(value)\n\t{\n\t\tthis._subscribed = value;\n\t}\n\n    /**\n     * Get subscribed property.\n     * \n     * @public\n     */\n\tget subscribed()\n\t{\n\t\treturn this._subscribed;\n\t}\n\n    /**\n     * default is video.\n     * stream type { video | audio }\n     * @returns {boolean}\n     */\n\tget type()\n\t{\n\t\treturn this.trackNumber === 1 && this.audioTracks.length > 0 ? 'audio' : 'video';\n\t}\n\n\tget published()\n\t{\n\t\treturn this._published;\n\t}\n\n\tget videoType()\n\t{\n\t\treturn this._videoType;\n\t}\n    /**\n     * Get stream id.\n     * \n     * @public\n     */\n\tgetId()\n\t{\n\t\treturn this._customStreamID;\n\t}\n\n    /**\n     * Get attributes.\n     * \n     * @private\n     */\n\tgetAttributes()\n\t{\n\t}\n\n    /**\n     * Get audio volume\n     * \n     * @public\n     */\n\tgetAudioLevel()\n\t{\n\t\treturn this._volume;\n\t}\n\n    /**\n     * Check has video track.\n     * \n     * @public\n     */\n\thasVideo()\n\t{\n\t\t// checking video presence\n\t\tif (this._streamObj === null)\n\t\t\treturn false;\n\n\t\treturn !!this._streamObj.getVideoTracks().length;\n\t}\n\n    /**\n     * Check has audio track.\n     * \n     * @public\n     */\n\thasAudio()\n\t{\n\t\t// checking audio presence\n\t\tif (this._streamObj === null)\n\t\t\treturn false;\n\n\t\treturn !!this._streamObj.getAudioTracks().length;\n\t}\n\n    /**\n     * Enable video track.\n     * \n     * @public\n     */\n\tenableVideo()\n\t{\n\t\tif (!this._isLocalStream)\n\t\t{\n\t\t\tlogger.error('API enableVideo() error - only local stream can enable video, you can utilize subscribe function.');\n\t\t\tthrow Error('only local stream can enable video, you can utilize subscribe function.');\n\t\t}\n\n\t\tlogger.debug(`API enableVideo() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\t\tif (this._published)\n\t\t{\n\t\t\tif (global.g_client !== null)\n\t\t\t{\n\t\t\t\tglobal.g_client.resumeWebcam(this);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogger.error('API enableVideo() error - global.g_client is NULL');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (this._video)\n\t\t\t{\n\t\t\t\tthis._video.play();\n\t\t\t}\n\t\t}\n\t}\n\n    /**\n     * Disable video track.\n     * \n     * @public\n     */\n\tdisableVideo()\n\t{\n\t\tif (!this._isLocalStream)\n\t\t{\n\t\t\tlogger.error('API disableVideo() error - only local stream can enable video, you can utilize unsubscribe function.');\n\n\t\t\tthrow Error('only local stream can enable video, you can utilize unsubscribe function.');\n\t\t}\n\n\t\tlogger.debug(`API disableVideo() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\t\tif (global.g_client !== null)\n\t\t{\n\t\t\tglobal.g_client.pauseWebcam(this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger.error('API disableVideo() error - global.g_client is NULL');\n\t\t}\n\t}\n\n    /**\n     * Enable audio track.\n     * \n     * @public\n     */\n\tenableAudio()\n\t{\n\t\tif (!this._isLocalStream)\n\t\t{\n\t\t\tlogger.error('API enableAudio() error - only local stream can enable video, you can utilize subscribe function.');\n\n\t\t\tthrow Error('only local stream can enable video, you can utilize subscribe function.');\n\t\t}\n\n\t\tlogger.debug(`API enableAudio() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\t\tif (this._published)\n\t\t{\n\t\t\tif (global.g_client !== null)\n\t\t\t{\n\t\t\t\tglobal.g_client.resumeMic(this);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogger.error('API enableAudio() error - global.g_client is NULL');\n\t\t\t}\n\t\t}\n\t}\n\n    /**\n     * Disable audio track.\n     * \n     * @public\n     */\n\tdisableAudio()\n\t{\n\t\tif (!this._isLocalStream)\n\t\t{\n\t\t\tlogger.error('API disableAudio() error - only local stream can enalbe video, you can utilize unsubscribe function.');\n\n\t\t\tthrow Error('only local stream can enalbe video, you can utilize unsubscribe function.');\n\t\t}\n\n\t\tlogger.debug(`API disableAudio() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\t\tif (global.g_client !== null)\n\t\t{\n\t\t\tglobal.g_client.pauseMic(this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger.error('API disableAudio() error - global.g_client is NULL');\n\t\t}\n\t}\n\n    /**\n     * @public\n     */\n\tenableVideoAndAudio()\n\t{\n\t\tlogger.debug(`API enableVideoAndAudio() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\tif (global.g_client !== null)\n\t\t{\n\t\t\tglobal.g_client.resumeMic();\n\t\t\tglobal.g_client.resumeWebcam(this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger.error('API enableVideoAndAudio() error - global.g_client is NULL');\n\t\t}\n\t}\n\n    /**\n     * @public\n     */\n\tdisableVideoAndAudio()\n\t{\n\t\tlogger.debug(`API disableVideoAndAudio() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\tif (global.g_client !== null)\n\t\t{\n\t\t\tglobal.g_client.pauseMic(this);\n\t\t\tglobal.g_client.pauseWebcam(this);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger.error('API disableVideoAndAudio() error - global.g_client is NULL');\n\t\t}\n\t}\n\n\t// \n\t// profile : 音频 profile\n\t// 取值 : 'speech_low_quality' | 'speech_standard' | 'music_standard' | 'standard_stereo' | 'high_quality' | 'high_quality_stereo'\n\tsetAudioProfile(profile)\n\t{\n\t\tconst audioProfile = config.audioProfileSpec.get(profile);\n\t\tthis._audioProfile = (!audioProfile) ? null : audioProfile;\n\n\t\t// \n\t\tlogger.debug(`API setAudioProfile() profile: ${profile} ${JSON.stringify(this._audioProfile)}`);\n\t}\n\n\t// \n\tgetAudioProfile()\n\t{\n\t\treturn this._audioProfile;\n\t}\n\n    /**\n     * Set video profile.\n     * \n     * @public\n     * @param {string} videoProfile defined in the config.js.\n     * @param {function} onSuccess \n     * @param {function} onFailure \n     * @param {Any} codecOptions   \n     *   {\n     *       startBitrate: @type {number},\n     *       maxBitrate: @type {number},\n     *       minBitrate: @type {number}\n     *   }\n     */\n\tsetVideoProfile(videoProfile, onSuccess, onFailure, codecOptions = null)\n\t{\n\t\tlogger.debug(`API setVideoProfile() - this._userId: ${this._userId} videoProfile: ${videoProfile} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\t// check parames.\n\t\tif (this._streamObj === null)\n\t\t{\n\t\t\tlogger.error('API setVideoProfile() error - stream is null, please init it at first.');\n\t\t\tthrow Error('stream is null, please init it at first.');\n\t\t}\n\n\t\tif (!this._isLocalStream)\n\t\t{\n\t\t\tlogger.error('API setVideoProfile() error - only local stream can set video profile.');\n\t\t\tthrow Error('only local stream can set video profile.');\n\t\t}\n\n\t\tif (typeof onSuccess !== 'function')\n\t\t{\n\t\t\tlogger.error('API setVideoProfile() error - onSuccess have to be a function.');\n\t\t\tthrow TypeError('onSuccess have to be a function.');\n\t\t}\n\n\t\tif (typeof onFailure !== 'function')\n\t\t{\n\t\t\tlogger.error('API setVideoProfile() error - onFailure have to be a function.');\n\t\t\tthrow TypeError('onFailure have to be a function.');\n\t\t}\n\n\t\tlet tracks = this._streamObj.getVideoTracks();\n\t\tif (tracks.length <= 0)\n\t\t{\n\t\t\tlogger.error('API setVideoProfile() error - have no video track.');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (codecOptions)\n\t\t{\n\t\t\tif (!codecOptions.minBandwidth || !codecOptions.maxBandwidth || !codecOptions.startBitrate)\n\t\t\t{\n\t\t\t\tlogger.error('API setVideoProfile() error - codecOptions parameters invalid.');\n\t\t\t\tthrow TypeError(codecOptions);\n\t\t\t}\n\n\t\t\tif (typeof codecOptions.minBandwidth !== 'number' || typeof codecOptions.maxBandwidth !== 'number' || typeof codecOptions.startBitrate !== 'number')\n\t\t\t{\n\t\t\t\tlogger.error('API setVideoProfile() error - codecOptions parameters invalid.');\n\t\t\t\tthrow TypeError(codecOptions);\n\t\t\t}\n\n\t\t\tif (codecOptions.minBandwidth >= codecOptions.maxBandwidth)\n\t\t\t{\n\t\t\t\tlogger.error('API setVideoProfile() error - codecOptions parameters invalid.');\n\t\t\t\tthrow TypeError('minBandwidth > = maxBandwidth');\n\t\t\t}\n\n\t\t\tthis._spec.codecOptions = codecOptions;\n\t\t}\n\n\t\tlet track = tracks[0];\n\t\tlet constraints;\n\t\tlet resolution = this._getResolutionByVideoProfile(videoProfile);\n\t\tlet in_width = resolution.width;\n\t\tlet in_height = resolution.height;\n\t\tconstraints = {\n\t\t\twidth: in_width,\n\t\t\theight: in_height\n\t\t\t// aspectRatio: 3 / 2\n\t\t};\n\n\t\ttrack.applyConstraints(constraints)\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\tlogger.debug(`API setVideoProfile() track.applyConstraints ok -- constraints: ${JSON.stringify(constraints)}`);\n\n\t\t\t\tthis.replaceTrack(track);\n\t\t\t\tonSuccess('applyConstraint success');\n\t\t\t})\n\t\t\t.catch(err =>\n\t\t\t{\n\t\t\t\t//\n\t\t\t\tlogger.error('API setVideoProfile() error - track.applyConstraints failed.');\n\n\t\t\t\tonFailure(err);\n\t\t\t});\n\t}\n\n    /**\n     * Get video profile.\n     * @public\n     */\n\tgetVideoProfile()\n\t{\n\t\tif (!this._streamObj)\n\t\t{\n\t\t\tlogger.error('API getVideoProfile() error - this._streamObj is NULL');\n\t\t\treturn {};\n\t\t}\n\n\t\tlet mediaTracks = this._streamObj.getVideoTracks();\n\t\tif (mediaTracks.length <= 0)\n\t\t{\n\t\t\tlogger.error('API getVideoProfile() error - getVideoProfile: no video track');\n\t\t\treturn {};\n\t\t}\n\n\t\tlet setting = mediaTracks[0].getSettings();\n\t\tlet resoultion = {\n\t\t\twidth: setting.width,\n\t\t\theight: setting.height\n\t\t};\n\n\t\tlogger.debug(`API getVideoProfile() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID} resoultion: ${JSON.stringify(resoultion)}`);\n\n\t\treturn resoultion;\n\t}\n\n    /**\n     * Set screen profile.\n     * TODO.\n     */\n\tsetScreenProfile()\n\t{\n\t}\n\n    /**\n     * Play stream.\n     * \n     * @public\n     * @param {string} elementID. video|audio tag id\n     * @param {string} assetsURL\n\t * @param {boolen} isControls show control panel \n     */\n\tplay(elementID, isControls, assetsURL)\n\t{\n\t\tlogger.debug(`API play() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\tif (!this._streamObj)\n\t\t{\n\t\t\tlogger.error('API play() error - stream is NULL.');\n\t\t\tthrow Error('stream is null, please init it at first.');\n\t\t}\n\n\t\tif (this.type === 'audio')\n\t\t{\n\t\t\tthis.audioElement = document.createElement('audio');\n\t\t\tthis.audioElement.srcObject = this._streamObj;\n\t\t\treturn this.audioElement.play();\n\t\t}\n\t\tthis._video = document.getElementById(elementID);\n\t\tif (!this._video)\n\t\t{\n\t\t\tlogger.error(`API play() error - Not found video -- id: ${elementID}.`);\n\t\t\tthrow Error('video id can not find ' + elementID);\n\t\t}\n\n\t\tif (!this._streamObj.active)\n\t\t{\n\t\t\tlogger.debug('API play() - stream active is false');\n\t\t}\n\n\t\t// TODO : this._video.muted = Boolean(this.audioElement);\n\t\tthis._video.autoplay = true;\n\t\tthis._video.controls = !!isControls;// false;\n\t\tthis._video.playsinline = true;\n\t\tthis._video.srcObject = this._streamObj;\n\t}\n\n    /**\n     * Stop stream.\n     */\n\tstop()\n\t{\n\t}\n\n    /**\n     * Close stream.\n     * \n     * @public\n     */\n\tclose()\n\t{\n\t\tlogger.debug(`API close() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\tlet client = window.g_client;\n\t\tif (this._closed)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._streamObj)\n\t\t{\n\t\t\tlogger.error('API close() error - stream is null, please init it at first.');\n\t\t\treturn;\n\t\t}\n\n\t\t// TODO : 对 stream 增加 类型（producer、consumer）\n\t\tif (client)\n\t\t{\n\t\t\tlet micProducer = client._mapMicProducers.get(this._innerStreamID),\n\t\t\t\twebcamProducer = client._mapWebcamProducers.get(this._innerStreamID);\n\t\t\tif (micProducer)\n\t\t\t\tmicProducer.pause();\n\t\t\tif (webcamProducer)\n\t\t\t\twebcamProducer.close();\n\t\t}\n\n\t\tthis._streamObj.getTracks().forEach(track => track.stop());\n\t\tthis._streamObj = null;\n\t\tthis._streamObjOrigin = null;\n\n\t\tthis.removeAllListeners();\n\t\t// S_STREAM_MAP.delete(this._innerStreamID);\n\t\tthis._closed = true;\n\n\t\tif (this._video)\n\t\t{\n\t\t\tthis._video.srcObject = null;\n\t\t}\n\t\tthis._gainNode = null;\n\t\tthis._audioCtx = null;\n\n\t\t//stream.stop() was deprecated.\n\t\t//ref: https://stackoverflow.com/questions/34966809/stop-kill-webrtc-media-stream\n\t}\n\n    /**\n     * @private\n     */\n\t_startScreenCapture()\n\t{\n\t\tlet videoConstraints = {\n\t\t\taspectRatio: config.screenSpec.s_1080p.maxAspectRatio,\n\t\t\t// 'deviceId': 'screen:0:0',\n\t\t\tframeRate: config.screenSpec.s_frameRate,\n\t\t\theight: config.screenSpec.s_1080p.maxHeight,\n\t\t\tresizeMode: 'crop-and-scale',\n\t\t\twidth: config.screenSpec.s_1080p.maxWidth,\n\t\t\tcursor: 'always',\n\t\t\t// 'displaySurface': 'monitor',\n\t\t\t// logicalSurface: true\n\t\t};\n\n\t\tlet displayMediaStreamConstraints = {\n\t\t\tvideo: videoConstraints\n\t\t};\n\n\t\tif (navigator.getDisplayMedia)\n\t\t{\n\t\t\treturn navigator.getDisplayMedia(displayMediaStreamConstraints);\n\t\t}\n\t\telse if (navigator.mediaDevices.getDisplayMedia)\n\t\t{\n\t\t\treturn navigator.mediaDevices.getDisplayMedia(displayMediaStreamConstraints);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn navigator.mediaDevices.getUserMedia({ video: { mediaSource: 'screen' } });\n\t\t}\n\t}\n\n    /**\n     * End stream(of screen) track.\n     *\n     * @private\n     * @param {Any} track \n     */\n\tasync _screenStreamEnded(stream)\n\t{\n\t\tlet track = stream.getVideoTracks()[0];\n\t\ttrack.onended = e =>\n\t\t{\n\t\t\tlogger.debug(`_screenStreamEnded() track.onended - ${e.toString()} - Emit [screen-close]`);\n\t\t\t// g_client.unpublishScreen(this,\n\t\t\t//     () => {\n\t\t\t//         logger.debug('end and unpbulish screen');\n\t\t\t//         this._streamObj = null;\n\t\t\t//     },\n\t\t\t//     e => {\n\t\t\t//         logger.error('end and uppbublish screen error ', e.message);\n\t\t\t//     })\n\n\t\t\tthis.emit('screen-close', { streamID: this.streamID, stream : this });\n\t\t}\n\t}\n\n    /**\n     * Take a photo for your playing stream.\n     * \n     * @public\n     * @param {String} retType return type of base64|file\n     * @param {String} filename\n     * @param {Function} onSuccess the sucess call back.\n     */\n\tcapture(retType, filename = new Date().toISOString().replace(/[-:TZ.]/g, '') + this._customStreamID, onSuccess = new Function())\n\t{\n\t\tlogger.debug(`API capture() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\tif (!this._streamObj)\n\t\t{\n\t\t\tlogger.error('API capture() error - this._streamObj is NULL.');\n\t\t\tthrow Error('stream is null, please init it at first.');\n\t\t}\n\t\tif (!this._video)\n\t\t{\n\t\t\tlogger.error('API capture() error - this._video is NULL.');\n\t\t\tthrow Error('this stream has not be played: ' + this._streamObj);\n\t\t}\n\t\tif (!/[\\\\\\/\\*\\:\\<\\>\\|\\?\\\"]/g.test(filename) && filename.length > 255)\n\t\t{\n\t\t\tlogger.error('API capture() error - illegal filename.');\n\t\t\tthrow Error('illegal filename ');\n\t\t}\n\n\t\tlet canvas = document.createElement('canvas');\n\t\tcanvas.width = this._video.videoWidth;\n\t\tcanvas.height = this._video.videoHeight;\n\t\tlet context = canvas.getContext('2d');\n\t\tcontext.drawImage(this._video, 0, 0, canvas.width, canvas.height);\n\n\t\tif (retType === 'file')\n\t\t{\n\t\t\tcanvas.toBlob(blob =>\n\t\t\t{\n\t\t\t\tonSuccess(new File([blob], filename + '.jpeg', { type: 'image/jpeg' }));\n\t\t\t})\n\t\t}\n\t\telse\n\t\t{\n\t\t\tonSuccess(canvas.toDataURL('image/jpeg'));\n\t\t}\n\t}\n\n    /**\n     * 调节输入音量\n     * @param {number} volume 音量 [0, 1.5]    0 ----------------> 1 ----------------> 1.5\n     *                                        静音                正常                 增大\n     */\n\tsetInputVolume(volume)\n\t{\n\t\tif (typeof volume !== 'number')\n\t\t{\n\t\t\tlogger.warn(`API setInputVolume() TypeError - volume: ${volume}`);\n\t\t\tthrow TypeError('Wrong arguments: volume must be number.');\n\t\t}\n\t\tif (!this._gainNode)\n\t\t{\n\t\t\tlogger.warn('API setInputVolume() error - no gainNode existed.');\n\t\t\tthrow Error('setInputVolume() error - no gainNode existed.');\n\t\t}\n\t\tif (volume < 0)\n\t\t{\n\t\t\tvolume = 0;\n\t\t}\n\t\telse if (volume > 1.5)\n\t\t{\n\t\t\tvolume = 1.5;\n\t\t}\n\t\tthis._gainNode.gain.value = volume;\n\t\tlogger.debug(`API setInputVolume() success - volume: ${volume}`);\n\t}\n\n    /**\n     * @public\n     * @param {Any} track \n     */\n\taddTrack(track)\n\t{\n\t\t// TODO.\n\t}\n\n    /**\n     * @public\n     * @param {Any} track \n     */\n\tremoveTrack(track)\n\t{\n\t\t// TODO.\n\t}\n\n    /**\n     * Replace old track with new track.\n     * \n     * @public\n     * @param {MediaStreamTrack} track\n     */\n\tasync replaceTrack(track)\n\t{\n\t\tlogger.debug(`API replaceTrack() - this._userId: ${this._userId} this._innerStreamID: ${this._innerStreamID}`);\n\n\t\tif (!track)\n\t\t{\n\t\t\tlogger.warn('API replaceTrack() error - parameter [trank] is INVALID.');\n\t\t\tthrow TypeError('track');\n\t\t}\n\n\t\tlet tracks = null;\n\t\tlet oldTrack = null;\n\t\tswitch (track.kind)\n\t\t{\n\t\t\tcase 'video':\n\t\t\t\ttracks = this._streamObj.getVideoTracks();\n\t\t\t\toldTrack = tracks[0];\n\t\t\t\tthis._streamObj.removeTrack(oldTrack);\n\t\t\t\tthis.videoTracks = track;\n\t\t\t\tthis._videoSetting = track.getSettings();\n\t\t\t\tthis._setKeyResolution(track);\n\n\t\t\t\tif (global.g_client)\n\t\t\t\t{\n\t\t\t\t\tawait global.g_client._replaceTrack(this, track);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlogger.error('API replaceTrack() error - global.g_client is NULL.');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'audio':\n\t\t\t\t// TODO.\n\t\t\t\tthrow TypeError('Cannot support audio track replace now.');\n\t\t\tdefault:\n\t\t\t\tthrow TypeError('track have no audio or video.');\n\t\t}\n\t}\n\n    /**\n     * Properties of audio tracks\n     * autoGainControl\n     * channelCount\n     * echoCancellation\n     * latency\n     * noiseSuppression\n     * sampleRate\n     * sampleSize\n     * volume\n     * \n     * Properties of video tracks\n     * aspectRatio\n     * facingMode\n     * {\n     *  'user'\n     *  'environment'\n     *  'left'\n     *  'right'\n     * }\n     * frameRate\n     * height\n     * width\n     * resizeMode\n     * {\n     *  'none'\n     *  'crop-and-scale'\n     * }\n     * \n     * Properties of shared screen tracks\n     * cursor\n     * {\n     *  always\n     *  motion\n     *  never\n     * }\n     * displaySurface\n     * {\n     *  application\n     *  browser\n     *  monitor\n     *  window\n     * }\n     * logicalSurface\n     * \n     * More detail information about it please Reference below links.\n     * 1: https://www.w3.org/TR/webrtc/#mediatracksupportedconstraints-mediatrackcapabilities-mediatrackconstraints-and-mediatracksettings\n     * 2: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings\n     * \n     * @public\n     */\n\tgetVideoTrackSettings()\n\t{\n\t\treturn this._videoSetting;\n\t}\n\n    /**\n     * @public\n     */\n\tgetAudioTrackSetting()\n\t{\n\t\treturn this._audioSetting;\n\t}\n\n    /**\n     * The video(track) width normalize.\n     * \n     * @private\n     * @param {MediaStreamTrack} track\n     */\n\t_setKeyResolution(track)\n\t{\n\t\tif (!track)\n\t\t\tthrow new TypeError('track');\n\n\t\tif (track.kind !== 'video')\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlet setting = track.getSettings();\n\n\t\tif (setting.height <= 80)\n\t\t{\n\t\t\tthis._keyResolution = 80;\n\t\t}\n\t\telse if (setting.height > 80 && setting.height <= 120)\n\t\t{\n\t\t\tthis._keyResolution = 120;\n\t\t}\n\t\telse if (setting.height > 120 && setting.height <= 160)\n\t\t{\n\t\t\tthis._keyResolution = 160;\n\t\t}\n\t\telse if (setting.height > 160 && setting.height <= 200)\n\t\t{\n\t\t\tthis._keyResolution = 200;\n\t\t}\n\t\telse if (setting.height > 200 && setting.height <= 240)\n\t\t{\n\t\t\tthis._keyResolution = 240;\n\t\t}\n\t\telse if (setting.height > 240 && setting.height <= 320)\n\t\t{\n\t\t\tthis._keyResolution = 320;\n\t\t}\n\t\telse if (setting.height > 320 && setting.height <= 360)\n\t\t{\n\t\t\tthis._keyResolution = 360;\n\t\t}\n\t\telse if (setting.height > 360 && setting.height <= 480)\n\t\t{\n\t\t\tthis._keyResolution = 480;\n\t\t}\n\t\telse if (setting.height > 480 && setting.height <= 540)\n\t\t{\n\t\t\tthis._keyResolution = 540;\n\t\t}\n\t\telse if (setting.height > 480 && setting.height <= 720)\n\t\t{\n\t\t\tthis._keyResolution = 720;\n\t\t}\n\t\telse if (setting.height > 720 && setting.height <= 1080)\n\t\t{\n\t\t\tthis._keyResolution = 1080;\n\t\t}\n\t\telse if (setting.height > 1080 && setting.height <= 1920)\n\t\t{\n\t\t\tthis._keyResolution = 1920;\n\t\t}\n\t\telse if (setting.height > 1920)\n\t\t{\n\t\t\tthis._keyResolution = 1920;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._keyResolution = 480;\n\t\t}\n\t}\n\n    /**\n     * Get ideal bandwidth.\n     * \n     * @private\n     */\n\tget idealBandwidth()\n\t{\n\t\tif (typeof this._spec.codecOptions !== 'undefined')\n\t\t{\n\t\t\tif (typeof this._spec.codecOptions.startBitrate !== 'undefined')\n\t\t\t{\n\t\t\t\tif (typeof this._spec.codecOptions.startBitrate === 'number')\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('idealBandwidth() error - spec.codecOptions.startBitrate type error');\n\t\t\t\t\treturn this._spec.codecOptions.startBitrate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn config.videoResolution.get(this._keyResolution).bps.ideal / 1000;\n\t}\n\n    /**\n     * Get Minimum Bandwidth.\n     * \n     * @private\n     */\n\tget minBandwidth()\n\t{\n\t\tif (typeof this._spec.codecOptions !== 'undefined')\n\t\t{\n\t\t\tif (typeof this._spec.codecOptions.minBitrate !== 'undefined')\n\t\t\t{\n\t\t\t\tif (typeof this._spec.codecOptions.minBitrate === 'number')\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('minBandwidth() error - spec.codecOptions.minBitrate type error');\n\t\t\t\t\treturn this._spec.codecOptions.minBitrate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn config.videoResolution.get(this._keyResolution).bps.min / 1000;\n\t}\n\n    /**\n     * Get maximum Bandwidth.\n     * \n     * @private\n     */\n\tget maxBandwidth()\n\t{\n\t\tif (typeof this._spec.codecOptions !== 'undefined')\n\t\t{\n\t\t\tif (typeof this._spec.codecOptions.maxBitrate !== 'undefined')\n\t\t\t{\n\t\t\t\tif (typeof this._spec.codecOptions.maxBitrate === 'number')\n\t\t\t\t{\n\t\t\t\t\tlogger.warn('maxBandwidth() error - spec.codecOptions.maxBitrate type error');\n\t\t\t\t\treturn this._spec.codecOptions.maxBitrate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn config.videoResolution.get(this._keyResolution).bps.max / 1000;\n\t}\n\n    /**\n     * Get video resolution by video's profile.\n     * \n     * @private\n     * @param {string} profile REF: config.js: videoProfile variable. \n     */\n\t_getResolutionByVideoProfile(profile)\n\t{\n\t\tif (!profile)\n\t\t{\n\t\t\tthrow TypeError('profile');\n\t\t}\n\n\t\tlet resolution = { width: 0, height: 0 }\n\t\t// The default resolution is 480p.\n\t\tlet in_width = 640;\n\t\tlet in_height = 480;\n\t\tlet s_in_height, s_in_width;\n\t\tlet _videoProfile = profile.toLowerCase();\n\t\tswitch (_videoProfile)\n\t\t{\n\t\t\tcase config.videoProfile.Profile_80p:\n\t\t\tcase config.videoProfile.Profile_120p:\n\t\t\tcase config.videoProfile.Profile_160p:\n\t\t\tcase config.videoProfile.Profile_200p:\n\t\t\tcase config.videoProfile.Profile_240p:\n\t\t\tcase config.videoProfile.Profile_320p:\n\t\t\tcase config.videoProfile.Profile_360p:\n\t\t\tcase config.videoProfile.Profile_480p:\n\t\t\tcase config.videoProfile.Profile_540p:\n\t\t\tcase config.videoProfile.Profile_720p:\n\t\t\tcase config.videoProfile.Profile_1080p:\n\t\t\t\t// eslint-disable-next-line no-case-declarations\n\t\t\t\ts_in_height = _videoProfile.slice(0, -1);\n\t\t\t\tin_height = parseInt(s_in_height, 10);\n\t\t\t\tin_width = config.videoResolution.get(in_height).width;\n\t\t\t\tbreak;\n\t\t\tcase config.videoProfile.Profile_3840p:\n\t\t\tcase config.videoProfile.Profile_7680p:\n\t\t\t\t// eslint-disable-next-line no-case-declarations\n\t\t\t\ts_in_width = _videoProfile.slice(0, -1);\n\t\t\t\tin_width = parseInt(s_in_width, 10);\n\t\t\t\tin_height = config.videoResolution.get(in_width).height;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tlogger.warn(`Resolution params error - Using default resolution 640*480. Profile ref: ${JSON.stringify(config.videoProfile)}`);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tresolution.width = in_width;\n\t\tresolution.height = in_height;\n\t\treturn resolution;\n\t}\n}\n\nmodule.exports = Stream;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./lib/stream.js?");

/***/ }),

/***/ "./lib/utils.js":
/*!**********************!*\
  !*** ./lib/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction getProtooUrl(peerName, roomId, appId = '', hostname = '',audioPt='isac32') {\n\t// const hostname = config.mediaServerAddress;\n\t// const url = `wss://${hostname}:3443/?peerName=${peerName}&roomId=${roomId}`;\n\tconst url = `wss://${hostname}:3443/?peerName=${peerName}&roomId=${roomId}_${appId}&audioPt=${audioPt}`;\n\treturn url;\n}\n\nfunction uuid() {\n\tlet s = [];\n\tlet hexDigits = '0123456789abcdef';\n\tfor (let i = 0; i < 36; i++) {\n\t\ts[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n\t}\n\t\n\ts[14] = '4';  // bits 12-15 of the time_hi_and_version field to 0010\n\ts[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01\n\ts[8] = s[13] = s[18] = s[23] = '-';\n\n\tlet uuid = s.join('');\n\treturn uuid;\n}\n\nmodule.exports = {\n\tgetProtooUrl: getProtooUrl,\n\tuuid: uuid\n}\n\n//# sourceURL=webpack:///./lib/utils.js?");

/***/ }),

/***/ "./node_modules/bowser/src/bowser.js":
/*!*******************************************!*\
  !*** ./node_modules/bowser/src/bowser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Bowser - a browser detector\n * https://github.com/ded/bowser\n * MIT License | (c) Dustin Diaz 2015\n */\n\n!function (root, name, definition) {\n  if ( true && module.exports) module.exports = definition()\n  else if (true) __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")(name, definition)\n  else {}\n}(this, 'bowser', function () {\n  /**\n    * See useragents.js for examples of navigator.userAgent\n    */\n\n  var t = true\n\n  function detect(ua) {\n\n    function getFirstMatch(regex) {\n      var match = ua.match(regex);\n      return (match && match.length > 1 && match[1]) || '';\n    }\n\n    function getSecondMatch(regex) {\n      var match = ua.match(regex);\n      return (match && match.length > 1 && match[2]) || '';\n    }\n\n    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()\n      , likeAndroid = /like android/i.test(ua)\n      , android = !likeAndroid && /android/i.test(ua)\n      , nexusMobile = /nexus\\s*[0-6]\\s*/i.test(ua)\n      , nexusTablet = !nexusMobile && /nexus\\s*[0-9]+/i.test(ua)\n      , chromeos = /CrOS/.test(ua)\n      , silk = /silk/i.test(ua)\n      , sailfish = /sailfish/i.test(ua)\n      , tizen = /tizen/i.test(ua)\n      , webos = /(web|hpw)(o|0)s/i.test(ua)\n      , windowsphone = /windows phone/i.test(ua)\n      , samsungBrowser = /SamsungBrowser/i.test(ua)\n      , windows = !windowsphone && /windows/i.test(ua)\n      , mac = !iosdevice && !silk && /macintosh/i.test(ua)\n      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)\n      , edgeVersion = getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.\\d+)?)/i)\n      , versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i)\n      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)\n      , mobile = !tablet && /[^-]mobi/i.test(ua)\n      , xbox = /xbox/i.test(ua)\n      , result\n\n    if (/opera/i.test(ua)) {\n      //  an old Opera\n      result = {\n        name: 'Opera'\n      , opera: t\n      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    } else if (/opr\\/|opios/i.test(ua)) {\n      // a new Opera\n      result = {\n        name: 'Opera'\n        , opera: t\n        , version: getFirstMatch(/(?:opr|opios)[\\s\\/](\\d+(\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (/SamsungBrowser/i.test(ua)) {\n      result = {\n        name: 'Samsung Internet for Android'\n        , samsungBrowser: t\n        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/Whale/i.test(ua)) {\n      result = {\n        name: 'NAVER Whale browser'\n        , whale: t\n        , version: getFirstMatch(/(?:whale)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/MZBrowser/i.test(ua)) {\n      result = {\n        name: 'MZ Browser'\n        , mzbrowser: t\n        , version: getFirstMatch(/(?:MZBrowser)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/coast/i.test(ua)) {\n      result = {\n        name: 'Opera Coast'\n        , coast: t\n        , version: versionIdentifier || getFirstMatch(/(?:coast)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/focus/i.test(ua)) {\n      result = {\n        name: 'Focus'\n        , focus: t\n        , version: getFirstMatch(/(?:focus)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/yabrowser/i.test(ua)) {\n      result = {\n        name: 'Yandex Browser'\n      , yandexbrowser: t\n      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/ucbrowser/i.test(ua)) {\n      result = {\n          name: 'UC Browser'\n        , ucbrowser: t\n        , version: getFirstMatch(/(?:ucbrowser)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/mxios/i.test(ua)) {\n      result = {\n        name: 'Maxthon'\n        , maxthon: t\n        , version: getFirstMatch(/(?:mxios)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/epiphany/i.test(ua)) {\n      result = {\n        name: 'Epiphany'\n        , epiphany: t\n        , version: getFirstMatch(/(?:epiphany)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/puffin/i.test(ua)) {\n      result = {\n        name: 'Puffin'\n        , puffin: t\n        , version: getFirstMatch(/(?:puffin)[\\s\\/](\\d+(?:\\.\\d+)?)/i)\n      }\n    }\n    else if (/sleipnir/i.test(ua)) {\n      result = {\n        name: 'Sleipnir'\n        , sleipnir: t\n        , version: getFirstMatch(/(?:sleipnir)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/k-meleon/i.test(ua)) {\n      result = {\n        name: 'K-Meleon'\n        , kMeleon: t\n        , version: getFirstMatch(/(?:k-meleon)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (windowsphone) {\n      result = {\n        name: 'Windows Phone'\n      , osname: 'Windows Phone'\n      , windowsphone: t\n      }\n      if (edgeVersion) {\n        result.msedge = t\n        result.version = edgeVersion\n      }\n      else {\n        result.msie = t\n        result.version = getFirstMatch(/iemobile\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/msie|trident/i.test(ua)) {\n      result = {\n        name: 'Internet Explorer'\n      , msie: t\n      , version: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i)\n      }\n    } else if (chromeos) {\n      result = {\n        name: 'Chrome'\n      , osname: 'Chrome OS'\n      , chromeos: t\n      , chromeBook: t\n      , chrome: t\n      , version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      }\n    } else if (/edg([ea]|ios)/i.test(ua)) {\n      result = {\n        name: 'Microsoft Edge'\n      , msedge: t\n      , version: edgeVersion\n      }\n    }\n    else if (/vivaldi/i.test(ua)) {\n      result = {\n        name: 'Vivaldi'\n        , vivaldi: t\n        , version: getFirstMatch(/vivaldi\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (sailfish) {\n      result = {\n        name: 'Sailfish'\n      , osname: 'Sailfish OS'\n      , sailfish: t\n      , version: getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/seamonkey\\//i.test(ua)) {\n      result = {\n        name: 'SeaMonkey'\n      , seamonkey: t\n      , version: getFirstMatch(/seamonkey\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/firefox|iceweasel|fxios/i.test(ua)) {\n      result = {\n        name: 'Firefox'\n      , firefox: t\n      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \\/](\\d+(\\.\\d+)?)/i)\n      }\n      if (/\\((mobile|tablet);[^\\)]*rv:[\\d\\.]+\\)/i.test(ua)) {\n        result.firefoxos = t\n        result.osname = 'Firefox OS'\n      }\n    }\n    else if (silk) {\n      result =  {\n        name: 'Amazon Silk'\n      , silk: t\n      , version : getFirstMatch(/silk\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/phantom/i.test(ua)) {\n      result = {\n        name: 'PhantomJS'\n      , phantom: t\n      , version: getFirstMatch(/phantomjs\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/slimerjs/i.test(ua)) {\n      result = {\n        name: 'SlimerJS'\n        , slimer: t\n        , version: getFirstMatch(/slimerjs\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/blackberry|\\bbb\\d+/i.test(ua) || /rim\\stablet/i.test(ua)) {\n      result = {\n        name: 'BlackBerry'\n      , osname: 'BlackBerry OS'\n      , blackberry: t\n      , version: versionIdentifier || getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (webos) {\n      result = {\n        name: 'WebOS'\n      , osname: 'WebOS'\n      , webos: t\n      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\\/(\\d+(\\.\\d+)?)/i)\n      };\n      /touchpad\\//i.test(ua) && (result.touchpad = t)\n    }\n    else if (/bada/i.test(ua)) {\n      result = {\n        name: 'Bada'\n      , osname: 'Bada'\n      , bada: t\n      , version: getFirstMatch(/dolfin\\/(\\d+(\\.\\d+)?)/i)\n      };\n    }\n    else if (tizen) {\n      result = {\n        name: 'Tizen'\n      , osname: 'Tizen'\n      , tizen: t\n      , version: getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      };\n    }\n    else if (/qupzilla/i.test(ua)) {\n      result = {\n        name: 'QupZilla'\n        , qupzilla: t\n        , version: getFirstMatch(/(?:qupzilla)[\\s\\/](\\d+(?:\\.\\d+)+)/i) || versionIdentifier\n      }\n    }\n    else if (/chromium/i.test(ua)) {\n      result = {\n        name: 'Chromium'\n        , chromium: t\n        , version: getFirstMatch(/(?:chromium)[\\s\\/](\\d+(?:\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (/chrome|crios|crmo/i.test(ua)) {\n      result = {\n        name: 'Chrome'\n        , chrome: t\n        , version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (android) {\n      result = {\n        name: 'Android'\n        , version: versionIdentifier\n      }\n    }\n    else if (/safari|applewebkit/i.test(ua)) {\n      result = {\n        name: 'Safari'\n      , safari: t\n      }\n      if (versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    }\n    else if (iosdevice) {\n      result = {\n        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'\n      }\n      // WTF: version is not part of user agent in web apps\n      if (versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    }\n    else if(/googlebot/i.test(ua)) {\n      result = {\n        name: 'Googlebot'\n      , googlebot: t\n      , version: getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i) || versionIdentifier\n      }\n    }\n    else {\n      result = {\n        name: getFirstMatch(/^(.*)\\/(.*) /),\n        version: getSecondMatch(/^(.*)\\/(.*) /)\n     };\n   }\n\n    // set webkit or gecko flag for browsers based on these engines\n    if (!result.msedge && /(apple)?webkit/i.test(ua)) {\n      if (/(apple)?webkit\\/537\\.36/i.test(ua)) {\n        result.name = result.name || \"Blink\"\n        result.blink = t\n      } else {\n        result.name = result.name || \"Webkit\"\n        result.webkit = t\n      }\n      if (!result.version && versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    } else if (!result.opera && /gecko\\//i.test(ua)) {\n      result.name = result.name || \"Gecko\"\n      result.gecko = t\n      result.version = result.version || getFirstMatch(/gecko\\/(\\d+(\\.\\d+)?)/i)\n    }\n\n    // set OS flags for platforms that have multiple browsers\n    if (!result.windowsphone && (android || result.silk)) {\n      result.android = t\n      result.osname = 'Android'\n    } else if (!result.windowsphone && iosdevice) {\n      result[iosdevice] = t\n      result.ios = t\n      result.osname = 'iOS'\n    } else if (mac) {\n      result.mac = t\n      result.osname = 'macOS'\n    } else if (xbox) {\n      result.xbox = t\n      result.osname = 'Xbox'\n    } else if (windows) {\n      result.windows = t\n      result.osname = 'Windows'\n    } else if (linux) {\n      result.linux = t\n      result.osname = 'Linux'\n    }\n\n    function getWindowsVersion (s) {\n      switch (s) {\n        case 'NT': return 'NT'\n        case 'XP': return 'XP'\n        case 'NT 5.0': return '2000'\n        case 'NT 5.1': return 'XP'\n        case 'NT 5.2': return '2003'\n        case 'NT 6.0': return 'Vista'\n        case 'NT 6.1': return '7'\n        case 'NT 6.2': return '8'\n        case 'NT 6.3': return '8.1'\n        case 'NT 10.0': return '10'\n        default: return undefined\n      }\n    }\n\n    // OS version extraction\n    var osVersion = '';\n    if (result.windows) {\n      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i))\n    } else if (result.windowsphone) {\n      osVersion = getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i);\n    } else if (result.mac) {\n      osVersion = getFirstMatch(/Mac OS X (\\d+([_\\.\\s]\\d+)*)/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (iosdevice) {\n      osVersion = getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (android) {\n      osVersion = getFirstMatch(/android[ \\/-](\\d+(\\.\\d+)*)/i);\n    } else if (result.webos) {\n      osVersion = getFirstMatch(/(?:web|hpw)os\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.blackberry) {\n      osVersion = getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i);\n    } else if (result.bada) {\n      osVersion = getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.tizen) {\n      osVersion = getFirstMatch(/tizen[\\/\\s](\\d+(\\.\\d+)*)/i);\n    }\n    if (osVersion) {\n      result.osversion = osVersion;\n    }\n\n    // device type extraction\n    var osMajorVersion = !result.windows && osVersion.split('.')[0];\n    if (\n         tablet\n      || nexusTablet\n      || iosdevice == 'ipad'\n      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))\n      || result.silk\n    ) {\n      result.tablet = t\n    } else if (\n         mobile\n      || iosdevice == 'iphone'\n      || iosdevice == 'ipod'\n      || android\n      || nexusMobile\n      || result.blackberry\n      || result.webos\n      || result.bada\n    ) {\n      result.mobile = t\n    }\n\n    // Graded Browser Support\n    // http://developer.yahoo.com/yui/articles/gbs\n    if (result.msedge ||\n        (result.msie && result.version >= 10) ||\n        (result.yandexbrowser && result.version >= 15) ||\n\t\t    (result.vivaldi && result.version >= 1.0) ||\n        (result.chrome && result.version >= 20) ||\n        (result.samsungBrowser && result.version >= 4) ||\n        (result.whale && compareVersions([result.version, '1.0']) === 1) ||\n        (result.mzbrowser && compareVersions([result.version, '6.0']) === 1) ||\n        (result.focus && compareVersions([result.version, '1.0']) === 1) ||\n        (result.firefox && result.version >= 20.0) ||\n        (result.safari && result.version >= 6) ||\n        (result.opera && result.version >= 10.0) ||\n        (result.ios && result.osversion && result.osversion.split(\".\")[0] >= 6) ||\n        (result.blackberry && result.version >= 10.1)\n        || (result.chromium && result.version >= 20)\n        ) {\n      result.a = t;\n    }\n    else if ((result.msie && result.version < 10) ||\n        (result.chrome && result.version < 20) ||\n        (result.firefox && result.version < 20.0) ||\n        (result.safari && result.version < 6) ||\n        (result.opera && result.version < 10.0) ||\n        (result.ios && result.osversion && result.osversion.split(\".\")[0] < 6)\n        || (result.chromium && result.version < 20)\n        ) {\n      result.c = t\n    } else result.x = t\n\n    return result\n  }\n\n  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')\n\n  bowser.test = function (browserList) {\n    for (var i = 0; i < browserList.length; ++i) {\n      var browserItem = browserList[i];\n      if (typeof browserItem=== 'string') {\n        if (browserItem in bowser) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get version precisions count\n   *\n   * @example\n   *   getVersionPrecision(\"1.10.3\") // 3\n   *\n   * @param  {string} version\n   * @return {number}\n   */\n  function getVersionPrecision(version) {\n    return version.split(\".\").length;\n  }\n\n  /**\n   * Array::map polyfill\n   *\n   * @param  {Array} arr\n   * @param  {Function} iterator\n   * @return {Array}\n   */\n  function map(arr, iterator) {\n    var result = [], i;\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, iterator);\n    }\n    for (i = 0; i < arr.length; i++) {\n      result.push(iterator(arr[i]));\n    }\n    return result;\n  }\n\n  /**\n   * Calculate browser version weight\n   *\n   * @example\n   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1\n   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1\n   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0\n   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1\n   *\n   * @param  {Array<String>} versions versions to compare\n   * @return {Number} comparison result\n   */\n  function compareVersions(versions) {\n    // 1) get common precision for both versions, for example for \"10.0\" and \"9\" it should be 2\n    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));\n    var chunks = map(versions, function (version) {\n      var delta = precision - getVersionPrecision(version);\n\n      // 2) \"9\" -> \"9.0\" (for precision = 2)\n      version = version + new Array(delta + 1).join(\".0\");\n\n      // 3) \"9.0\" -> [\"000000000\"\", \"000000009\"]\n      return map(version.split(\".\"), function (chunk) {\n        return new Array(20 - chunk.length).join(\"0\") + chunk;\n      }).reverse();\n    });\n\n    // iterate in reverse order by reversed chunks array\n    while (--precision >= 0) {\n      // 4) compare: \"000000009\" > \"000000010\" = false (but \"9\" > \"10\" = true)\n      if (chunks[0][precision] > chunks[1][precision]) {\n        return 1;\n      }\n      else if (chunks[0][precision] === chunks[1][precision]) {\n        if (precision === 0) {\n          // all version chunks are same\n          return 0;\n        }\n      }\n      else {\n        return -1;\n      }\n    }\n  }\n\n  /**\n   * Check if browser is unsupported\n   *\n   * @example\n   *   bowser.isUnsupportedBrowser({\n   *     msie: \"10\",\n   *     firefox: \"23\",\n   *     chrome: \"29\",\n   *     safari: \"5.1\",\n   *     opera: \"16\",\n   *     phantom: \"534\"\n   *   });\n   *\n   * @param  {Object}  minVersions map of minimal version to browser\n   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map\n   * @param  {String}  [ua] user agent string\n   * @return {Boolean}\n   */\n  function isUnsupportedBrowser(minVersions, strictMode, ua) {\n    var _bowser = bowser;\n\n    // make strictMode param optional with ua param usage\n    if (typeof strictMode === 'string') {\n      ua = strictMode;\n      strictMode = void(0);\n    }\n\n    if (strictMode === void(0)) {\n      strictMode = false;\n    }\n    if (ua) {\n      _bowser = detect(ua);\n    }\n\n    var version = \"\" + _bowser.version;\n    for (var browser in minVersions) {\n      if (minVersions.hasOwnProperty(browser)) {\n        if (_bowser[browser]) {\n          if (typeof minVersions[browser] !== 'string') {\n            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));\n          }\n\n          // browser version and min supported version.\n          return compareVersions([version, minVersions[browser]]) < 0;\n        }\n      }\n    }\n\n    return strictMode; // not found\n  }\n\n  /**\n   * Check if browser is supported\n   *\n   * @param  {Object} minVersions map of minimal version to browser\n   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map\n   * @param  {String}  [ua] user agent string\n   * @return {Boolean}\n   */\n  function check(minVersions, strictMode, ua) {\n    return !isUnsupportedBrowser(minVersions, strictMode, ua);\n  }\n\n  bowser.isUnsupportedBrowser = isUnsupportedBrowser;\n  bowser.compareVersions = compareVersions;\n  bowser.check = check;\n\n  /*\n   * Set our detect method to the main bowser object so we can\n   * reuse it to test other user agents.\n   * This is needed to implement future tests.\n   */\n  bowser._detect = detect;\n\n  /*\n   * Set our detect public method to the main bowser object\n   * This is needed to implement bowser in server side\n   */\n  bowser.detect = detect;\n  return bowser\n});\n\n\n//# sourceURL=webpack:///./node_modules/bowser/src/bowser.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\nfunction log(...args) {\n\t// This hackery is required for IE8/9, where\n\t// the `console.log` function doesn't have 'apply'\n\treturn typeof console === 'object' &&\n\t\tconsole.log &&\n\t\tconsole.log(...args);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* Active `debug` instances.\n\t*/\n\tcreateDebug.instances = [];\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.enabled = createDebug.enabled(namespace);\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = selectColor(namespace);\n\t\tdebug.destroy = destroy;\n\t\tdebug.extend = extend;\n\t\t// Debug.formatArgs = formatArgs;\n\t\t// debug.rawLog = rawLog;\n\n\t\t// env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\tcreateDebug.instances.push(debug);\n\n\t\treturn debug;\n\t}\n\n\tfunction destroy() {\n\t\tconst index = createDebug.instances.indexOf(this);\n\t\tif (index !== -1) {\n\t\t\tcreateDebug.instances.splice(index, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < createDebug.instances.length; i++) {\n\t\t\tconst instance = createDebug.instances[i];\n\t\t\tinstance.enabled = createDebug.enabled(instance.namespace);\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/common.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/hark/hark.js":
/*!***********************************!*\
  !*** ./node_modules/hark/hark.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var WildEmitter = __webpack_require__(/*! wildemitter */ \"./node_modules/wildemitter/wildemitter.js\");\n\nfunction getMaxVolume (analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n\n  for(var i=4, ii=fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  };\n\n  return maxVolume;\n}\n\n\nvar audioContextType;\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n}\n// use a single audio context due to hardware limits\nvar audioContext = null;\nmodule.exports = function(stream, options) {\n  var harker = new WildEmitter();\n\n  // make it not break in non-supported browsers\n  if (!audioContextType) return harker;\n\n  //Config\n  var options = options || {},\n      smoothing = (options.smoothing || 0.1),\n      interval = (options.interval || 50),\n      threshold = options.threshold,\n      play = options.play,\n      history = options.history || 10,\n      running = true;\n\n  // Ensure that just a single AudioContext is internally created\n  audioContext = options.audioContext || audioContext || new audioContextType();\n\n  var sourceNode, fftBins, analyser;\n\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n\n  if (stream.jquery) stream = stream[0];\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n\n  harker.speaking = false;\n\n  harker.suspend = function() {\n    return audioContext.suspend();\n  }\n  harker.resume = function() {\n    return audioContext.resume();\n  }\n  Object.defineProperty(harker, 'state', { get: function() {\n    return audioContext.state;\n  }});\n  audioContext.onstatechange = function() {\n    harker.emit('state_change', audioContext.state);\n  }\n\n  harker.setThreshold = function(t) {\n    threshold = t;\n  };\n\n  harker.setInterval = function(i) {\n    interval = i;\n  };\n\n  harker.stop = function() {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n  harker.speakingHistory = [];\n  for (var i = 0; i < history; i++) {\n      harker.speakingHistory.push(0);\n  }\n\n  // Poll the analyser node to determine if speaking\n  // and emit events if changed\n  var looper = function() {\n    setTimeout(function() {\n\n      //check if stop has been called\n      if(!running) {\n        return;\n      }\n\n      var currentVolume = getMaxVolume(analyser, fftBins);\n\n      harker.emit('volume_change', currentVolume, threshold);\n\n      var history = 0;\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n\n      looper();\n    }, interval);\n  };\n  looper();\n\n  return harker;\n}\n\n\n//# sourceURL=webpack:///./node_modules/hark/hark.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\-?\\d?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/random-number/index.js":
/*!*********************************************!*\
  !*** ./node_modules/random-number/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("void function(root){\n\n  function defaults(options){\n    var options = options || {}\n    var min = options.min\n    var max = options.max\n    var integer = options.integer || false\n    if ( min == null && max == null ) {\n      min = 0\n      max = 1\n    } else if ( min == null ) {\n      min = max - 1\n    } else if ( max == null ) {\n      max = min + 1\n    }\n    if ( max < min ) throw new Error('invalid options, max must be >= min')\n    return {\n      min:     min\n    , max:     max\n    , integer: integer\n    }\n  }\n\n  function random(options){\n    options = defaults(options)\n    if ( options.max === options.min ) return options.min\n    var r = Math.random() * (options.max - options.min + Number(!!options.integer)) + options.min\n    return options.integer ? Math.floor(r) : r\n  }\n\n  function generator(options){\n    options = defaults(options)\n    return function(min, max, integer){\n      options.min     = min != null ? min : options.min\n      options.max     = max != null ? max : options.max\n      options.integer = integer != null ? integer : options.integer\n      return random(options)\n    }\n  }\n\n  module.exports =  random\n  module.exports.generator = generator\n  module.exports.defaults = defaults\n}(this)\n\n\n//# sourceURL=webpack:///./node_modules/random-number/index.js?");

/***/ }),

/***/ "./node_modules/retry/index.js":
/*!*************************************!*\
  !*** ./node_modules/retry/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/retry */ \"./node_modules/retry/lib/retry.js\");\n\n//# sourceURL=webpack:///./node_modules/retry/index.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry.js":
/*!*****************************************!*\
  !*** ./node_modules/retry/lib/retry.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var RetryOperation = __webpack_require__(/*! ./retry_operation */ \"./node_modules/retry/lib/retry_operation.js\");\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && options.forever,\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry.js?");

/***/ }),

/***/ "./node_modules/retry/lib/retry_operation.js":
/*!***************************************************!*\
  !*** ./node_modules/retry/lib/retry_operation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts;\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(this._errors.length - 1, this._errors.length);\n      this._timeouts = this._cachedTimeouts.slice(0);\n      timeout = this._timeouts.shift();\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  var timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n\n\n//# sourceURL=webpack:///./node_modules/retry/lib/retry_operation.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _global = (function() { return this; })();\nvar NativeWebSocket = _global.WebSocket || _global.MozWebSocket;\nvar websocket_version = __webpack_require__(/*! ./version */ \"./node_modules/websocket/lib/version.js\");\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n\n\n//# sourceURL=webpack:///./node_modules/websocket/lib/browser.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ../package.json */ \"./node_modules/websocket/package.json\").version;\n\n\n//# sourceURL=webpack:///./node_modules/websocket/lib/version.js?");

/***/ }),

/***/ "./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, browser, bugs, config, contributors, dependencies, description, devDependencies, directories, engines, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_args\\\":[[\\\"websocket@1.0.28\\\",\\\"D:\\\\\\\\00-3t\\\\\\\\01-proj\\\\\\\\websdk\\\\\\\\clientsdk\\\"]],\\\"_from\\\":\\\"websocket@1.0.28\\\",\\\"_id\\\":\\\"websocket@1.0.28\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-00y/20/80P7H4bCYkzuuvvfDvh+dgtXi5kzDf3UcZwN6boTYaKvsrtZ5lIYm1Gsg48siMErd9M4zjSYfYFHTrA==\\\",\\\"_location\\\":\\\"/websocket\\\",\\\"_phantomChildren\\\":{},\\\"_requested\\\":{\\\"type\\\":\\\"version\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"websocket@1.0.28\\\",\\\"name\\\":\\\"websocket\\\",\\\"escapedName\\\":\\\"websocket\\\",\\\"rawSpec\\\":\\\"1.0.28\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"1.0.28\\\"},\\\"_requiredBy\\\":[\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/websocket/-/websocket-1.0.28.tgz\\\",\\\"_spec\\\":\\\"1.0.28\\\",\\\"_where\\\":\\\"D:\\\\\\\\00-3t\\\\\\\\01-proj\\\\\\\\websdk\\\\\\\\clientsdk\\\",\\\"author\\\":{\\\"name\\\":\\\"Brian McKelvey\\\",\\\"email\\\":\\\"theturtle32@gmail.com\\\",\\\"url\\\":\\\"https://github.com/theturtle32\\\"},\\\"browser\\\":\\\"lib/browser.js\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/theturtle32/WebSocket-Node/issues\\\"},\\\"config\\\":{\\\"verbose\\\":false},\\\"contributors\\\":[{\\\"name\\\":\\\"Iñaki Baz Castillo\\\",\\\"email\\\":\\\"ibc@aliax.net\\\",\\\"url\\\":\\\"http://dev.sipdoc.net\\\"}],\\\"dependencies\\\":{\\\"debug\\\":\\\"^2.2.0\\\",\\\"nan\\\":\\\"^2.11.0\\\",\\\"typedarray-to-buffer\\\":\\\"^3.1.5\\\",\\\"yaeti\\\":\\\"^0.0.6\\\"},\\\"description\\\":\\\"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\\\",\\\"devDependencies\\\":{\\\"buffer-equal\\\":\\\"^1.0.0\\\",\\\"faucet\\\":\\\"^0.0.1\\\",\\\"gulp\\\":\\\"git+https://github.com/gulpjs/gulp.git#4.0\\\",\\\"gulp-jshint\\\":\\\"^2.0.4\\\",\\\"jshint\\\":\\\"^2.0.0\\\",\\\"jshint-stylish\\\":\\\"^2.2.1\\\",\\\"tape\\\":\\\"^4.9.1\\\"},\\\"directories\\\":{\\\"lib\\\":\\\"./lib\\\"},\\\"engines\\\":{\\\"node\\\":\\\">=0.10.0\\\"},\\\"homepage\\\":\\\"https://github.com/theturtle32/WebSocket-Node\\\",\\\"keywords\\\":[\\\"websocket\\\",\\\"websockets\\\",\\\"socket\\\",\\\"networking\\\",\\\"comet\\\",\\\"push\\\",\\\"RFC-6455\\\",\\\"realtime\\\",\\\"server\\\",\\\"client\\\"],\\\"license\\\":\\\"Apache-2.0\\\",\\\"main\\\":\\\"index\\\",\\\"name\\\":\\\"websocket\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/theturtle32/WebSocket-Node.git\\\"},\\\"scripts\\\":{\\\"gulp\\\":\\\"gulp\\\",\\\"install\\\":\\\"(node-gyp rebuild 2> builderror.log) || (exit 0)\\\",\\\"test\\\":\\\"faucet test/unit\\\"},\\\"version\\\":\\\"1.0.28\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/websocket/package.json?");

/***/ }),

/***/ "./node_modules/wildemitter/wildemitter.js":
/*!*************************************************!*\
  !*** ./node_modules/wildemitter/wildemitter.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\nWildEmitter.js is a slim little event emitter by @henrikjoreteg largely based\r\non @visionmedia's Emitter from UI Kit.\r\n\r\nWhy? I wanted it standalone.\r\n\r\nI also wanted support for wildcard emitters like this:\r\n\r\nemitter.on('*', function (eventName, other, event, payloads) {\r\n\r\n});\r\n\r\nemitter.on('somenamespace*', function (eventName, payloads) {\r\n\r\n});\r\n\r\nPlease note that callbacks triggered by wildcard registered events also get\r\nthe event name as the first argument.\r\n*/\r\n\r\nmodule.exports = WildEmitter;\r\n\r\nfunction WildEmitter() { }\r\n\r\nWildEmitter.mixin = function (constructor) {\r\n    var prototype = constructor.prototype || constructor;\r\n\r\n    prototype.isWildEmitter= true;\r\n\r\n    // Listen on the given `event` with `fn`. Store a group name if present.\r\n    prototype.on = function (event, groupName, fn) {\r\n        this.callbacks = this.callbacks || {};\r\n        var hasGroup = (arguments.length === 3),\r\n            group = hasGroup ? arguments[1] : undefined,\r\n            func = hasGroup ? arguments[2] : arguments[1];\r\n        func._groupName = group;\r\n        (this.callbacks[event] = this.callbacks[event] || []).push(func);\r\n        return this;\r\n    };\r\n\r\n    // Adds an `event` listener that will be invoked a single\r\n    // time then automatically removed.\r\n    prototype.once = function (event, groupName, fn) {\r\n        var self = this,\r\n            hasGroup = (arguments.length === 3),\r\n            group = hasGroup ? arguments[1] : undefined,\r\n            func = hasGroup ? arguments[2] : arguments[1];\r\n        function on() {\r\n            self.off(event, on);\r\n            func.apply(this, arguments);\r\n        }\r\n        this.on(event, group, on);\r\n        return this;\r\n    };\r\n\r\n    // Unbinds an entire group\r\n    prototype.releaseGroup = function (groupName) {\r\n        this.callbacks = this.callbacks || {};\r\n        var item, i, len, handlers;\r\n        for (item in this.callbacks) {\r\n            handlers = this.callbacks[item];\r\n            for (i = 0, len = handlers.length; i < len; i++) {\r\n                if (handlers[i]._groupName === groupName) {\r\n                    //console.log('removing');\r\n                    // remove it and shorten the array we're looping through\r\n                    handlers.splice(i, 1);\r\n                    i--;\r\n                    len--;\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n\r\n    // Remove the given callback for `event` or all\r\n    // registered callbacks.\r\n    prototype.off = function (event, fn) {\r\n        this.callbacks = this.callbacks || {};\r\n        var callbacks = this.callbacks[event],\r\n            i;\r\n\r\n        if (!callbacks) return this;\r\n\r\n        // remove all handlers\r\n        if (arguments.length === 1) {\r\n            delete this.callbacks[event];\r\n            return this;\r\n        }\r\n\r\n        // remove specific handler\r\n        i = callbacks.indexOf(fn);\r\n        callbacks.splice(i, 1);\r\n        if (callbacks.length === 0) {\r\n            delete this.callbacks[event];\r\n        }\r\n        return this;\r\n    };\r\n\r\n    /// Emit `event` with the given args.\r\n    // also calls any `*` handlers\r\n    prototype.emit = function (event) {\r\n        this.callbacks = this.callbacks || {};\r\n        var args = [].slice.call(arguments, 1),\r\n            callbacks = this.callbacks[event],\r\n            specialCallbacks = this.getWildcardCallbacks(event),\r\n            i,\r\n            len,\r\n            item,\r\n            listeners;\r\n\r\n        if (callbacks) {\r\n            listeners = callbacks.slice();\r\n            for (i = 0, len = listeners.length; i < len; ++i) {\r\n                if (!listeners[i]) {\r\n                    break;\r\n                }\r\n                listeners[i].apply(this, args);\r\n            }\r\n        }\r\n\r\n        if (specialCallbacks) {\r\n            len = specialCallbacks.length;\r\n            listeners = specialCallbacks.slice();\r\n            for (i = 0, len = listeners.length; i < len; ++i) {\r\n                if (!listeners[i]) {\r\n                    break;\r\n                }\r\n                listeners[i].apply(this, [event].concat(args));\r\n            }\r\n        }\r\n\r\n        return this;\r\n    };\r\n\r\n    // Helper for for finding special wildcard event handlers that match the event\r\n    prototype.getWildcardCallbacks = function (eventName) {\r\n        this.callbacks = this.callbacks || {};\r\n        var item,\r\n            split,\r\n            result = [];\r\n\r\n        for (item in this.callbacks) {\r\n            split = item.split('*');\r\n            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {\r\n                result = result.concat(this.callbacks[item]);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n\r\n};\r\n\r\nWildEmitter.mixin(WildEmitter);\r\n\n\n//# sourceURL=webpack:///./node_modules/wildemitter/wildemitter.js?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, description, buildDate, main, scripts, author, license, dependencies, devDependencies, files, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"name\\\":\\\"tttwebsdk\\\",\\\"version\\\":\\\"3.4.6\\\",\\\"description\\\":\\\"webrtc of 3ttech.cn\\\",\\\"buildDate\\\":\\\"Feb_20_2020\\\",\\\"main\\\":\\\"lib/TTTRtcWeb.js\\\",\\\"scripts\\\":{\\\"test\\\":\\\"jest\\\",\\\"start\\\":\\\"webpack-dev-server --open\\\",\\\"build:app\\\":\\\"webpack\\\",\\\"build:demo\\\":\\\"webpack --config webpack.config/webpack.config.demo.js\\\",\\\"build:prod\\\":\\\"webpack --config webpack.config/webpack.config.prod.js\\\",\\\"build:proddemo\\\":\\\"webpack --config webpack.config/webpack.config.proddemo.js\\\",\\\"build:demo-multistream\\\":\\\"webpack --config webpack.config/webpack.config.demo_multistream.js\\\",\\\"build:sdk\\\":\\\"webpack --config webpack.config/webpack.config.sdk.js --mode development\\\",\\\"lint\\\":\\\"eslint -c .eslintrc.js lib/protoo lib/client.js lib/index.js lib/stats.js lib/config.js lib/utils.js lib/stream.js lib/TTTRtcWeb.js\\\",\\\"3.1:test\\\":\\\"webpack --config ./tests/3.1.test.pages/webpack.config.js\\\"},\\\"author\\\":\\\"3ttech.cn\\\",\\\"license\\\":\\\"ISC\\\",\\\"dependencies\\\":{\\\"debug\\\":\\\"^4.1.1\\\",\\\"hark\\\":\\\"^1.2.3\\\",\\\"jsonp\\\":\\\"^0.2.1\\\",\\\"bowser\\\":\\\"^1.9.3\\\",\\\"random-number\\\":\\\"^0.0.9\\\",\\\"retry\\\":\\\"^0.12.0\\\",\\\"websocket\\\":\\\"^1.0.28\\\"},\\\"devDependencies\\\":{\\\"sweetalert2\\\":\\\"^8.11.4\\\",\\\"webpack-jquery-ui\\\":\\\"^2.0.1\\\",\\\"copy-webpack-plugin\\\":\\\"^5.0.4\\\",\\\"eslint\\\":\\\"^5.16.0\\\",\\\"eslint-plugin-react\\\":\\\"^7.13.0\\\",\\\"html-webpack-plugin\\\":\\\"^3.2.0\\\",\\\"http-server\\\":\\\"^0.11.1\\\",\\\"jest\\\":\\\"^24.9.0\\\",\\\"jest-websocket-mock\\\":\\\"^1.5.0\\\",\\\"mock-socket\\\":\\\"^9.0.0\\\",\\\"webpack\\\":\\\"^4.41.0\\\",\\\"webpack-cli\\\":\\\"^3.2.3\\\",\\\"webpack-dev-server\\\":\\\"^3.1.14\\\"},\\\"files\\\":[\\\"lib/\\\",\\\"screen/\\\",\\\"docs/\\\",\\\"README.md\\\",\\\"CHANGELOG.md\\\"]}\");\n\n//# sourceURL=webpack:///./package.json?");

/***/ })

/******/ });